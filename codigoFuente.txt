package Enum;

public enum RolEnum {
    MECANICO("Mecánico"),
    MANTENIMIENTO("Personal de mantenimiento"),
    ADMINISTRADOR("Administrador"),
    USUARIO_STANDARD("Usuario estándar"), 
    USUARIO_PREMIUM("Usuario premium");
    
    private final String textoMostrado;
    
    RolEnum(String textoMostrado) {
        this.textoMostrado = textoMostrado;
    }
    
    @Override
    public String toString() {
        return textoMostrado;
    }
}

package Enum;
public enum VehiculoEnum {
    MOTOPEQUENA(10.0, 10.0, 0.4, "Moto Pequeña"),
    MOTOGRANDE(20.0, 5.0, 0.25, "Moto Grande"),
    BICICLETA(5.0, 7.0, 1.0, "Bicicleta"),
    PATINETE(3.0, 15.0, 0.5, "Patinete");

    private double tarifa;
    private double descuento;
    private double ritmoConsumo;
    private final String textoMostrado;

    VehiculoEnum(double tarifa, double descuento, double ritmoConsumo, String textoMostrado) {
        this.tarifa = tarifa;
        this.descuento = descuento;
        this.ritmoConsumo = ritmoConsumo;
        this.textoMostrado = textoMostrado;
    }

    public double getTarifa() {
        return tarifa;
    }
    
    public void setTarifa(double tarifa) {
        this.tarifa = tarifa;
    }
    
    public double getDescuento() {
        return descuento;
    }
    
    public void setDescuento(double descuento) {
        this.descuento = descuento;
    }

    public double getRitmoConsumo() {
        return ritmoConsumo;
    }
    
    public void setRitmoConsumo(double ritmoConsumo) {
        this.ritmoConsumo = ritmoConsumo;
    }
    
    @Override
    public String toString() {
        return textoMostrado;
    }
}

package GestorPersonas.Personas;

import Enum.RolEnum;

public class Administrador extends Trabajador {

    public Administrador(String nombre, String apellidos, String DNI) {
        super(nombre, apellidos, DNI, RolEnum.ADMINISTRADOR);
    }
}

package GestorPersonas.Personas;

import Enum.RolEnum;

public class Administrador extends Trabajador {

    public Administrador(String nombre, String apellidos, String DNI) {
        super(nombre, apellidos, DNI, RolEnum.ADMINISTRADOR);
    }
}

package GestorPersonas.Personas;
import Enum.RolEnum;
import GestorVehiculosBases.Facturas.FacturaReparacionBase;
import GestorVehiculosBases.Facturas.FacturaReparacionVehiculo;
import GestorVehiculosBases.Localizaciones.Base;
import GestorVehiculosBases.Vehiculos.Vehiculo;
import java.util.ArrayList;
import java.util.List;

public class Mecanico extends Trabajador {
    private List<Vehiculo> vehiculosAveriados; // Lista de vehículos asignados al mecánico
    private List<Base> basesAveriadas; // Lista de bases asignadas al mecánico
    private List<FacturaReparacionVehiculo> reparacionesVehiculos;
    private List<FacturaReparacionBase> reparacionesBases;
    private int intervencionesRealizadas; // Contador de intervenciones realizadas

    public Mecanico(String nombre, String apellidos, String DNI) {
        super(nombre, apellidos, DNI, RolEnum.MECANICO);
        this.vehiculosAveriados = new ArrayList<>();
        this.basesAveriadas = new ArrayList<>();
        this.reparacionesVehiculos = new ArrayList<>();
        this.reparacionesBases = new ArrayList<>();
        this.intervencionesRealizadas = 0;
    }

    public List<Vehiculo> getVehiculosAveriados() {
        return vehiculosAveriados;
    }
    public void setVehiculosAveriados(List<Vehiculo> vehiculosAveriados) {
        this.vehiculosAveriados = vehiculosAveriados;
    }
    public List<Base> getBasesAveriadas() {
        return basesAveriadas;
    }
    public void setBasesAveriadas(List<Base> basesAveriadas) {
        this.basesAveriadas = basesAveriadas;
    }
    public void addVehiculoAveriado(Vehiculo vehiculo) {
        this.vehiculosAveriados.add(vehiculo);
    }
    public void removeVehiculoAveriado(Vehiculo vehiculo) {
        this.vehiculosAveriados.remove(vehiculo);
    }
    public void addBaseAveriada(Base base) {
        this.basesAveriadas.add(base);
    }
    public void removeBaseAveriada(Base base) {
        this.basesAveriadas.remove(base);
    }

    public List<FacturaReparacionVehiculo> getReparacionesVehiculosRealizadas() {
        if (reparacionesVehiculos == null) {
            reparacionesVehiculos = new ArrayList<>();
        }
        return reparacionesVehiculos;
    }

    public void addReparacionVehiculo(FacturaReparacionVehiculo reparacion) {
        getReparacionesVehiculosRealizadas().add(reparacion);
    }

    public List<FacturaReparacionBase> getReparacionesBasesRealizadas() {
        if (reparacionesBases == null) {
            reparacionesBases = new ArrayList<>();
        }
        return reparacionesBases;
    }

    public void addReparacionBase(FacturaReparacionBase reparacion) {
        getReparacionesBasesRealizadas().add(reparacion);
    }

    public void incrementarIntervenciones() {
        this.intervencionesRealizadas++;
    }

    public int getIntervencionesRealizadas() {
        return intervencionesRealizadas;
    }
}


package GestorPersonas.Personas;
import Enum.RolEnum;

public abstract class Persona {
    private  String nombre;
    private  String apellidos;
    private  final String DNI;
    private  RolEnum rol;

    public Persona(String nombre, String apellidos, String DNI, RolEnum rol) {
        this.nombre = nombre;
        this.apellidos = apellidos;
        this.DNI = DNI;
        this.rol = rol;
    }

    public String getNombre() {
        return nombre;
    }

    public void setNombre(String nombre) {
        this.nombre = nombre;
    }

    public String getApellidos() {
        return apellidos;
    }

    public void setApellidos(String apellidos) {
        this.apellidos = apellidos;
    }

    public String getDNI() {
        return DNI;
    }

    public RolEnum getRol() {
        return rol;
    }

    public void setRol(RolEnum rol) {
        this.rol = rol;
    }
}

 
package GestorPersonas.Personas;
import Enum.RolEnum;

public class Premium extends Usuario {

    public Premium(String nombre, String apellidos, String DNI) {
        super(nombre, apellidos, DNI, RolEnum.USUARIO_PREMIUM);
    }

}


package GestorPersonas.Personas;
import Enum.RolEnum;

public class Standard extends Usuario {

    public Standard(String nombre, String apellidos, String DNI) {
        super(nombre, apellidos, DNI, RolEnum.USUARIO_STANDARD);
    }

}

package GestorPersonas.Personas;
import Enum.RolEnum;

public abstract class Trabajador extends Persona {

    public Trabajador(String nombre, String apellidos, String DNI, RolEnum rol) {
        super(nombre, apellidos, DNI, rol);
    }

}

package GestorPersonas.Personas;
import Enum.RolEnum;
import GestorViajes.Viaje;
import java.util.ArrayList;
import java.util.List;

public abstract class Usuario extends Persona {

    // =========================
    // ATRIBUTOS
    // =========================
    private double saldo; // Saldo del usuario
    private List<Viaje> historialViajes; // Lista de viajes del usuario

    // =========================
    // CONSTRUCTOR
    // =========================
    // Constructor de Usuario
    public Usuario(String nombre, String apellidos, String DNI, RolEnum rol) {
        super(nombre, apellidos, DNI, rol);
        this.saldo = 0.0; // Inicializar el saldo en 0
        this.historialViajes = new ArrayList<>(); // Inicializar la lista de viajes
    }

    // =========================
    // MÉTODOS DE SALDO
    // =========================

    // Devuelve el saldo actual del usuario
    public double getSaldo() {
        return saldo;
    }

    // Agrega saldo al usuario
    public void agregarSaldo(double cantidad) {
        if (cantidad <= 0) {
            return;
        }
        this.saldo += cantidad;
    }

    // Descuenta una cantidad del saldo del usuario
    public boolean descontarCosto(double cantidad) {
        if (cantidad <= 0) {
            return false;
        }
        this.saldo -= cantidad;
        return true;
    }

    // Establece el saldo del usuario
    public void setSaldo(double saldo) {
        if (saldo < 0) {
            return;
        }
        this.saldo = saldo;
    }
    
    // =========================
    // MÉTODOS DE VIAJES
    // =========================

    // Devuelve una copia del historial de viajes del usuario
    public List<Viaje> getHistorialViajes() {
        return new ArrayList<>(historialViajes); // Devuelve una copia para evitar modificaciones directas
    }
    
    // Registra un nuevo viaje en el historial del usuario
    public void registrarViaje(Viaje viaje) {
        if (viaje != null) {
            this.historialViajes.add(viaje);
        }
    }
}

package GestorPersonas;
import Enum.RolEnum;
import GestorPersonas.Personas.Administrador;
import GestorPersonas.Personas.Mantenimiento;
import GestorPersonas.Personas.Mecanico;
import GestorPersonas.Personas.Persona;
import GestorPersonas.Personas.Premium;
import GestorPersonas.Personas.Standard;
import GestorPersonas.Personas.Usuario;
import GestorViajes.Viaje;
import Utilidades.UtilidadesEntradaDatos;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class GestorPersonas {

    //=================================================
    // ATRIBUTOS Y SINGLETON
    //=================================================
    private static GestorPersonas gestorPersonas;
    private final Map<String, Persona> personas = new HashMap<>();
    private final Set<String> DNISet = new HashSet<>();
    private boolean administradorInicialCreado = false;

    //=================================================
    // CONSTRUCTOR Y SINGLETON
    //=================================================
    private GestorPersonas() {
    }

    public static GestorPersonas getInstancia() {
        if (gestorPersonas == null) {
            gestorPersonas = new GestorPersonas();
        }
        return gestorPersonas;
    }

    //=================================================
    // ADMINISTRADOR INICIAL
    //=================================================
    // Agrega un administrador inicial
    public boolean addAdministradorInicial(Administrador admin) {
        // Verifica si ya existe un administrador o si el sistema no está vacío
        if (administradorInicialCreado || !personas.isEmpty() || !DNISet.isEmpty()) {
            System.out.println("Error: No se puede agregar el administrador inicial. Ya existe un administrador o el sistema no está vacío.");
            return false;
        }
        // Agrega el administrador al mapa y al set de DNIs
        personas.put(admin.getDNI(), admin);
        DNISet.add(admin.getDNI());
        administradorInicialCreado = true;
        System.out.println("Administrador inicial agregado correctamente: " + admin.getDNI() + " - " + admin.getNombre() + " " + admin.getApellidos());
        return true;
    }

    //=================================================
    // VALIDACIÓN DE DATOS
    //=================================================
    // Verifica si un DNI ya existe
    public boolean existeDNI(String DNI) {
        return DNISet.contains(DNI);
    }

    // Valida el formato del DNI (8 dígitos y una letra mayúscula)
    public boolean esDNIValido(String DNI) {
        return DNI != null && DNI.matches("\\d{8}[A-Z]");
    }

    // Valida que nombre y apellidos no sean nulos ni vacíos
    private boolean sonNombreApellidosValidos(String nombre, String apellidos) {
        if (nombre == null || nombre.trim().isEmpty()) return false;
        if (apellidos == null || apellidos.trim().isEmpty()) return false;
        return true;
    }

    //=================================================
    // CRUD DE PERSONAS
    //=================================================
    // Agrega una nueva persona según el rol
    public void addPersona(String nombre, String apellidos, String DNI, RolEnum rol) {
        // Verifica si el DNI ya existe
        if (existeDNI(DNI)) {
            System.out.println("Error: No se pudo agregar la persona. El DNI ya existe en el sistema.");
            return;
        }
        // Valida los datos de entrada
        if (!sonNombreApellidosValidos(nombre, apellidos) || !esDNIValido(DNI)) {
            System.out.println("Error: No se pudo agregar la persona. Verifica el formato de los datos ingresados.");
            return;
        }
        // Crea la persona según el rol
        Persona persona;
        switch (rol) {
            case USUARIO_STANDARD:
                persona = new Standard(nombre, apellidos, DNI);
                break;
            case MECANICO:
                persona = new Mecanico(nombre, apellidos, DNI);
                break;
            case MANTENIMIENTO:
                persona = new Mantenimiento(nombre, apellidos, DNI);
                break;
            case ADMINISTRADOR:
                persona = new Administrador(nombre, apellidos, DNI);
                break;
            default:
                throw new IllegalArgumentException("Error: Rol no reconocido.");
        }
        // Agrega la persona al sistema
        personas.put(DNI, persona);
        DNISet.add(DNI);
        System.out.println("Persona agregada correctamente.");
    }

    // Obtiene una persona por DNI
    public Persona getPersonaPorDNI(String DNI) {
        // Valida el formato del DNI
        if (!esDNIValido(DNI)) {
            System.out.println("Error: Verifica el formato de los datos ingresados. Deben ser 8 dígitos seguidos de una letra mayúscula.");
            return null;
        }
        // Verifica si el DNI existe
        if (!existeDNI(DNI)) {
            System.out.println("Error: No se pudo eliminar la persona. El DNI no existe en el sistema.");
            return null;
        }
        // Retorna la persona correspondiente
        return personas.get(DNI);
    }

    // Elimina una persona por DNI
    public boolean removePersona(String DNI) {
        // Valida el formato del DNI
        if (!esDNIValido(DNI)) {
            System.out.println("Error: Verifica el formato de los datos ingresados. Deben ser 8 dígitos seguidos de una letra mayúscula.");
            return false;
        }
        // Verifica si el DNI existe
        if (!existeDNI(DNI)) {
            System.out.println("Error: No se pudo eliminar la persona. El DNI no existe en el sistema.");
            return false;
        }
        // Elimina la persona del sistema
        personas.remove(DNI);
        DNISet.remove(DNI);
        System.out.println("Persona eliminada correctamente.");
        return true;
    }

    // Modifica una persona por DNI
    public boolean modificarPersona(String DNI, String nuevoNombre, String nuevosApellidos, RolEnum nuevoRol) {
        // Valida los datos de entrada
        if (!sonNombreApellidosValidos(nuevoNombre, nuevosApellidos)) {
            System.out.println("Error: No se pudo modificar la persona. Verifica el formato de los datos ingresados.");
            return false;
        }
        // Valida el formato del DNI
        if (!esDNIValido(DNI)) {
            System.out.println("Error: Verifica el formato de los datos ingresados. Deben ser 8 dígitos seguidos de una letra mayúscula.");
            return false;
        }
        // Verifica si el DNI existe
        if (!existeDNI(DNI)) {
            System.out.println("Error: No se pudo modificar la persona. El DNI no existe en el sistema.");
            return false;
        }
        // Modifica los datos de la persona
        Persona persona = personas.get(DNI);
        if (persona != null) {
            persona.setNombre(nuevoNombre);
            persona.setApellidos(nuevosApellidos);
            persona.setRol(nuevoRol);
            System.out.println("Persona modificada correctamente.");
            return true;
        }
        return false;
    }

    // Obtiene el rol de una persona por DNI
    public RolEnum getRolPersona(String DNI) {
        Persona persona = getPersonaPorDNI(DNI);
        if (persona != null) {
            return persona.getRol();
        } else {
            System.out.println("Error: Persona no encontrada.");
            return null;
        }
    }

    //=================================================
    // USUARIOS Y ROLES
    //=================================================
    // Devuelve una lista con todos los usuarios registrados
    public List<Usuario> obtenerTodosLosUsuarios() {
        List<Usuario> resultado = new ArrayList<>();
        // Filtra solo las instancias de Usuario
        for (Persona persona : personas.values()) {
            if (persona instanceof Usuario) {
                resultado.add((Usuario) persona);
            }
        }
        return resultado;
    }

    // Cambia el rol de un usuario a PREMIUM o STANDARD
    public boolean cambiarRolUsuario(String DNI, boolean hacerPremium) {
        // Valida el formato del DNI
        if (!esDNIValido(DNI)) {
            System.out.println("Error: Formato de DNI inválido.");
            return false;
        }
        // Verifica si el DNI existe
        if (!existeDNI(DNI)) {
            System.out.println("Error: El DNI no existe en el sistema.");
            return false;
        }
        // Verifica que la persona sea un usuario
        Persona persona = getPersonaPorDNI(DNI);
        if (!(persona instanceof Usuario)) {
            System.out.println("Error: El DNI proporcionado no corresponde a un usuario.");
            return false;
        }
        Usuario usuario = (Usuario) persona;
        // Verifica si ya tiene el rol deseado
        if ((hacerPremium && usuario.getRol() == RolEnum.USUARIO_PREMIUM) ||
            (!hacerPremium && usuario.getRol() == RolEnum.USUARIO_STANDARD)) {
            System.out.println("El usuario ya tiene el estado " + 
                               (hacerPremium ? "PREMIUM" : "STANDARD"));
            return false;
        }
        // Si se va a hacer premium, verifica condiciones de promoción
        if (hacerPremium) {
            GestorPromocion ayudantePromocion = GestorPromocion.getInstancia();
            Map<String, Object> infoUsuario = ayudantePromocion.obtenerDetallesPromocionUsuario(usuario);
            if (infoUsuario == null) {
                System.out.println("Error: El usuario no cumple con las condiciones necesarias para ser promovido a PREMIUM.");
                System.out.println("Consulte las estadísticas de uso para más información.");
                return false;
            }
            System.out.println("El usuario cumple las siguientes condiciones para promoción:");
            if ((boolean) infoUsuario.get("condicion1")) {
                System.out.println("- Al menos 15 viajes en el último mes (" + infoUsuario.get("viajesUltimoMes") + " viajes)");
            }
            if ((boolean) infoUsuario.get("condicion2")) {
                System.out.println("- Al menos 10 viajes mensuales durante 3 meses consecutivos");
            }
            if ((boolean) infoUsuario.get("condicion3")) {
                System.out.println("- Uso de todos los tipos de vehículos durante 6 meses consecutivos");
            }
        }
        // Conserva los datos del usuario anterior
        String nombre = usuario.getNombre();
        String apellidos = usuario.getApellidos();
        double saldo = usuario.getSaldo();
        List<Viaje> viajes = usuario.getHistorialViajes();
        // Crea el nuevo usuario con el rol actualizado
        Usuario nuevoUsuario;
        if (hacerPremium) {
            nuevoUsuario = new Premium(nombre, apellidos, DNI);
            System.out.println("Usuario promovido a PREMIUM exitosamente.");
        } else {
            nuevoUsuario = new Standard(nombre, apellidos, DNI);
            System.out.println("Usuario convertido a STANDARD exitosamente.");
        }
        // Restaura saldo e historial de viajes
        nuevoUsuario.setSaldo(saldo);
        for (Viaje viaje : viajes) {
            nuevoUsuario.registrarViaje(viaje);
        }
        // Actualiza el usuario en el sistema
        personas.put(DNI, nuevoUsuario);
        return true;
    }

    //=================================================
    // UTILIDADES
    //=================================================
    // Devuelve todas las personas
    public Collection<Persona> getPersonas() {
        return personas.values();
    }

    // ==========================
    // BÚSQUEDA POR DNI
    // ==========================
    public void buscarPersonaPorDNI() {
        // Solicitar DNI
        System.out.print("Introduce el DNI a buscar: ");
        String DNI = UtilidadesEntradaDatos.getDNI("Introduce el DNI a buscar: ");

        // Buscar y mostrar resultado
        Persona persona = gestorPersonas.getPersonaPorDNI(DNI);
        if (persona == null) {
            System.out.println("No se encontró ninguna persona con ese DNI.");
        } else {
            System.out.println("\nPersona encontrada:");
            mostrarDetallesPersona(persona);
        }
    }

    // ==========================
    // BÚSQUEDA POR NOMBRE
    // ==========================
    public void buscarPersonaPorNombre() {
        // Solicitar nombre o parte
        System.out.print("Introduce el nombre o parte del nombre: ");
        String nombre = UtilidadesEntradaDatos.getStringLongitud("Introduce el nombre o parte del nombre: ", 1, 50).toLowerCase();

        List<Persona> resultados = new ArrayList<>();
        // Buscar coincidencias en nombre o apellidos
        for (Persona persona : gestorPersonas.getPersonas()) {
            if (persona.getNombre().toLowerCase().contains(nombre) ||
                persona.getApellidos().toLowerCase().contains(nombre)) {
                resultados.add(persona);
            }
        }

        // Mostrar resultados
        if (resultados.isEmpty()) {
            System.out.println("No se encontraron personas con ese nombre o apellido.");
        } else {
            System.out.println("\nSe encontraron " + resultados.size() + " resultados:");
            for (Persona persona : resultados) {
                mostrarDetallesPersona(persona);
                System.out.println("-------------------------");
            }
        }
    }

    // ==========================
    // BÚSQUEDA POR APELLIDO
    // ==========================
    public void buscarPersonaPorApellido() {
        // Solicitar apellido o parte
        System.out.print("Introduce el apellido o parte del apellido: ");
        String apellido = UtilidadesEntradaDatos.getStringLongitud("Introduce el apellido o parte del apellido: ", 1, 50).toLowerCase();

        List<Persona> resultados = new ArrayList<>();
        // Buscar coincidencias solo en apellidos
        for (Persona persona : gestorPersonas.getPersonas()) {
            if (persona.getApellidos().toLowerCase().contains(apellido)) {
                resultados.add(persona);
            }
        }

        // Mostrar resultados
        if (resultados.isEmpty()) {
            System.out.println("No se encontraron personas con ese apellido.");
        } else {
            System.out.println("\nSe encontraron " + resultados.size() + " resultados:");
            for (Persona persona : resultados) {
                mostrarDetallesPersona(persona);
                System.out.println("-------------------------");
            }
        }
    }

    // ==========================
    // FILTRAR PERSONAS POR ROL
    // ==========================
    public void filtrarPersonasPorRol() {
        // Mostrar opciones de rol
        System.out.println("Selecciona el rol a filtrar:");
        System.out.println("1. " + RolEnum.USUARIO_STANDARD);
        System.out.println("2. " + RolEnum.USUARIO_PREMIUM);
        System.out.println("3. " + RolEnum.MECANICO);
        System.out.println("4. " + RolEnum.MANTENIMIENTO);
        System.out.println("5. " + RolEnum.ADMINISTRADOR);

        System.out.print("Introduce opción: ");
        int opcion = UtilidadesEntradaDatos.getEnteroPositivo("Selecciona una opción (1-5): ", 1, 5);

        RolEnum rolFiltro;
        switch (opcion) {
            case 1 -> rolFiltro = RolEnum.USUARIO_STANDARD;
            case 2 -> rolFiltro = RolEnum.USUARIO_PREMIUM;
            case 3 -> rolFiltro = RolEnum.MECANICO;
            case 4 -> rolFiltro = RolEnum.MANTENIMIENTO;
            case 5 -> rolFiltro = RolEnum.ADMINISTRADOR;
            default -> {
                System.out.println("Opción no válida.");
                return;
            }
        }

        // Filtrar personas por rol
        List<Persona> personasFiltradas = new ArrayList<>();
        for (Persona persona : gestorPersonas.getPersonas()) {
            if (persona.getRol() == rolFiltro) {
                personasFiltradas.add(persona);
            }
        }

        // Mostrar resultados
        if (personasFiltradas.isEmpty()) {
            System.out.println("No se encontraron personas con el rol " + rolFiltro);
        } else {
            System.out.println("\nSe encontraron " + personasFiltradas.size() + " personas con rol " + rolFiltro + ":");
            for (Persona persona : personasFiltradas) {
                mostrarDetallesPersona(persona);
                System.out.println("-------------------------");
            }
        }
    }

     // ==========================
    // MOSTRAR DETALLES DE UNA PERSONA
    // ==========================
    private void mostrarDetallesPersona(Persona persona) {
        // Mostrar datos básicos
        System.out.println("DNI: " + persona.getDNI());
        System.out.println("Nombre: " + persona.getNombre() + " " + persona.getApellidos());
        System.out.println("Rol: " + persona.getRol());

        // Si es usuario, mostrar info adicional
        if (persona instanceof Usuario usuario) {
            System.out.println("Tipo: " + usuario.getRol());
            System.out.println("Viajes realizados: " + usuario.getHistorialViajes().size());
        }
    }
}

package GestorPersonas;
import Enum.VehiculoEnum;
import GestorPersonas.Personas.Usuario;
import GestorVehiculosBases.Vehiculos.Vehiculo;
import GestorViajes.GestorViajes;
import GestorViajes.Viaje;
import java.time.Instant;
import java.time.LocalDate;
import java.time.ZoneId;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class GestorPromocion {

    //=================================================
    // ATRIBUTOS Y PATRÓN SINGLETON
    //=================================================
    private static GestorPromocion instancia;

    // Constructor privado para patrón Singleton
    private GestorPromocion() {}

    // Devuelve la instancia única de GestorPromocion
    public static GestorPromocion getInstancia() {
        if (instancia == null) {
            instancia = new GestorPromocion();
        }
        return instancia;
    }

    //=================================================
    // MÉTODOS PRINCIPALES DE PROMOCIÓN
    //=================================================

    // Devuelve la lista de usuarios elegibles para promoción a PREMIUM
    public List<Usuario> getListaCandidatosPremium(Map<Usuario, List<Viaje>> viajesPorUsuarioMap) {
        List<Usuario> usuariosParaPromocion = new ArrayList<>();

        // Fechas de referencia para los últimos 1, 3 y 6 meses
        LocalDate ahora = LocalDate.now();
        LocalDate haceUnMes = ahora.minusMonths(1);
        LocalDate haceTresMeses = ahora.minusMonths(3);
        LocalDate haceSeisMeses = ahora.minusMonths(6);

        // Iterar sobre cada usuario y sus viajes
        for (Map.Entry<Usuario, List<Viaje>> entry : viajesPorUsuarioMap.entrySet()) {
            Usuario usuario = entry.getKey();
            List<Viaje> viajes = entry.getValue();

            // Filtrar viajes según las fechas de referencia
            List<Viaje> viajesUltimoMes = filtrarViajesPorFecha(
                viajes, 
                haceUnMes.atStartOfDay(ZoneId.systemDefault()).toInstant().toEpochMilli()
            );
            List<Viaje> viajesUltimosTresMeses = filtrarViajesPorFecha(
                viajes, 
                haceTresMeses.atStartOfDay(ZoneId.systemDefault()).toInstant().toEpochMilli()
            );
            List<Viaje> viajesUltimosSeisMeses = filtrarViajesPorFecha(
                viajes, 
                haceSeisMeses.atStartOfDay(ZoneId.systemDefault()).toInstant().toEpochMilli()
            );

            // Verificar condiciones de promoción
            boolean cumpleCondicion1 = verificarViajesUltimoMes(viajesUltimoMes); // 15 viajes último mes
            boolean cumpleCondicion2 = verificarViajesConsecutivos(viajesUltimosTresMeses, 10, 3); // 10 viajes/mes 3 meses consecutivos
            boolean cumpleCondicion3 = verificarUsoDeTodosLosTipos(viajesUltimosSeisMeses); // Todos los tipos 6 meses consecutivos

            // Si cumple al menos una condición, agregar a la lista de promoción
            if (cumpleCondicion1 || cumpleCondicion2 || cumpleCondicion3) {
                usuariosParaPromocion.add(usuario);
            }
        }

        return usuariosParaPromocion;
    }

    //=================================================
    // MÉTODOS AUXILIARES DE PROMOCIÓN
    //=================================================

    // Verifica si un usuario realizó al menos 15 viajes en el último mes
    private boolean verificarViajesUltimoMes(List<Viaje> viajesUltimoMes) {
        // Retorna true si el tamaño de la lista es mayor o igual a 15
        return viajesUltimoMes.size() >= 15;
    }

    // Filtra los viajes que ocurrieron después de una fecha específica (en milisegundos)
    private List<Viaje> filtrarViajesPorFecha(List<Viaje> viajes, long fechaInicioMillis) {
        List<Viaje> viajesFiltrados = new ArrayList<>();
        for (Viaje viaje : viajes) {
            // Si el viaje ocurrió después de la fecha indicada, se añade a la lista
            if (viaje.getTiempoInicio() >= fechaInicioMillis) {
                viajesFiltrados.add(viaje);
            }
        }
        return viajesFiltrados;
    }

    // Verifica si un usuario realizó un número mínimo de viajes durante meses consecutivos
    private boolean verificarViajesConsecutivos(List<Viaje> viajes, int minimoViajes, int mesesConsecutivos) {
        // Mapa para contar viajes por mes (clave: "YYYY-MM", valor: cantidad de viajes)
        Map<String, Integer> viajesPorMes = new HashMap<>();

        // Agrupar viajes por mes
        for (Viaje viaje : viajes) {
            String mesId = calcularMesId(viaje.getTiempoInicio());
            viajesPorMes.put(mesId, viajesPorMes.getOrDefault(mesId, 0) + 1);
        }

        // Ordenar los meses cronológicamente
        List<String> mesesOrdenados = new ArrayList<>(viajesPorMes.keySet());
        mesesOrdenados.sort(String::compareTo);

        int mesesCumplidos = 0; // Contador de meses consecutivos que cumplen la condición

        // Recorrer los meses ordenados y verificar si cumplen el mínimo de viajes
        for (String mes : mesesOrdenados) {
            if (viajesPorMes.get(mes) >= minimoViajes) {
                mesesCumplidos++;
                // Si ya se cumplieron los meses consecutivos requeridos, retornar true
                if (mesesCumplidos >= mesesConsecutivos) {
                    return true;
                }
            } else {
                // Si no cumple en un mes, reiniciar el contador
                mesesCumplidos = 0;
            }
        }
        // Si no se encontraron los meses consecutivos requeridos, retornar false
        return false;
    }

    // Verifica si un usuario utilizó todos los tipos de vehículos durante 6 meses consecutivos
    private boolean verificarUsoDeTodosLosTipos(List<Viaje> viajes) {
        // Mapa para agrupar, por mes, los tipos de vehículo usados
        Map<String, Set<VehiculoEnum>> tiposPorMes = new HashMap<>();

        // Agrupar los tipos de vehículo usados en cada mes
        for (Viaje viaje : viajes) {
            String mesId = calcularMesId(viaje.getTiempoInicio()); // Obtener identificador de mes (YYYY-MM)
            tiposPorMes.putIfAbsent(mesId, new HashSet<>()); // Si no existe el mes, crear el set
            // Añadir el tipo de vehículo usado en este viaje al set del mes correspondiente
            tiposPorMes.get(mesId).add((VehiculoEnum) ((Vehiculo) viaje.getVehiculo()).getVehiculoEnum());
        }

        // Ordenar los meses cronológicamente
        List<String> mesesOrdenados = new ArrayList<>(tiposPorMes.keySet());
        mesesOrdenados.sort(String::compareTo);

        int mesesCumplidos = 0; // Contador de meses consecutivos que cumplen la condición

        // Recorrer los meses ordenados y verificar si en cada uno se usaron todos los tipos de vehículo
        for (String mes : mesesOrdenados) {
            Set<VehiculoEnum> tiposEnMes = tiposPorMes.get(mes);

            // Comprobar si en este mes se usaron los tres tipos de vehículo requeridos
            if (tiposEnMes.contains(VehiculoEnum.BICICLETA) &&
                tiposEnMes.contains(VehiculoEnum.PATINETE) &&
                tiposEnMes.contains(VehiculoEnum.MOTOPEQUENA)) {
                mesesCumplidos++; // Sumar mes consecutivo que cumple
                // Si ya se cumplieron 6 meses consecutivos, retornar true
                if (mesesCumplidos >= 6) {
                    return true;
                }
            } else {
                // Si falta algún tipo en el mes, reiniciar el contador de meses consecutivos
                mesesCumplidos = 0;
            }
        }

        // Si no se encontraron 6 meses consecutivos, retornar false
        return false;
    }

    // Calcula el identificador de un mes en formato "YYYY-MM" a partir de un tiempo en milisegundos
    private String calcularMesId(long tiempoInicio) {
        Instant instant = Instant.ofEpochMilli(tiempoInicio);
        ZoneId zone = ZoneId.systemDefault();
        int year = instant.atZone(zone).getYear();
        int month = instant.atZone(zone).getMonthValue();
        // Formato con cero a la izquierda para el mes
        return year + "-" + (month < 10 ? "0" + month : month);
    }

    //=================================================
    // CONSULTAS Y UTILIDADES DE PROMOCIÓN
    //=================================================

    // Muestra en consola los usuarios que cumplen con las condiciones para ser promovidos
    public void mostrarUsuariosPromocion() {
        GestorViajes gestorViajes = GestorViajes.getInstancia();
        Map<Usuario, List<Viaje>> viajesPorUsuario = gestorViajes.getMapaViajesPorUsuario();
        List<Usuario> usuariosPromocion = getListaCandidatosPremium(viajesPorUsuario);

        System.out.println("\n===== USUARIOS QUE CUMPLEN CONDICIONES PARA PROMOCIÓN =====");

        if (usuariosPromocion.isEmpty()) {
            System.out.println("No hay usuarios que cumplan las condiciones para promoción.");
            return;
        }

        System.out.println("Se encontraron " + usuariosPromocion.size() + " usuarios elegibles para promoción:");
        System.out.println("------------------------------------------------------------");

        for (Usuario usuario : usuariosPromocion) {
            System.out.println("DNI: " + usuario.getDNI() + " | Nombre: " + usuario.getNombre() + " " + usuario.getApellidos());
            List<Viaje> viajes = viajesPorUsuario.get(usuario);

            // Calcular fechas de referencia
            LocalDate ahora = LocalDate.now();
            LocalDate haceUnMes = ahora.minusMonths(1);
            LocalDate haceTresMeses = ahora.minusMonths(3);
            LocalDate haceSeisMeses = ahora.minusMonths(6);

            // Filtrar viajes por periodo
            List<Viaje> viajesUltimoMes = filtrarViajesPorFecha(viajes, haceUnMes.atStartOfDay(ZoneId.systemDefault()).toInstant().toEpochMilli());
            List<Viaje> viajesUltimosTresMeses = filtrarViajesPorFecha(viajes, haceTresMeses.atStartOfDay(ZoneId.systemDefault()).toInstant().toEpochMilli());
            List<Viaje> viajesUltimosSeisMeses = filtrarViajesPorFecha(viajes, haceSeisMeses.atStartOfDay(ZoneId.systemDefault()).toInstant().toEpochMilli());

            // Verificar condiciones para mostrar cuáles cumple
            boolean condicion1 = verificarViajesUltimoMes(viajesUltimoMes);
            boolean condicion2 = verificarViajesConsecutivos(viajesUltimosTresMeses, 10, 3);
            boolean condicion3 = verificarUsoDeTodosLosTipos(viajesUltimosSeisMeses);

            System.out.println("  Condiciones cumplidas:");
            if (condicion1) {
                System.out.println("  - Al menos 15 viajes en el último mes (" + viajesUltimoMes.size() + " viajes)");
            }
            if (condicion2) {
                System.out.println("  - Al menos 10 viajes mensuales durante 3 meses consecutivos");
            }
            if (condicion3) {
                System.out.println("  - Uso de todos los tipos de vehículos durante 6 meses consecutivos");
            }
            System.out.println("------------------------------------------------------------");
        }
        System.out.println("============================================================");
        System.out.println("Total de usuarios elegibles para promoción: " + usuariosPromocion.size());
    }

    // Obtiene información detallada de por qué un usuario específico es elegible para promoción
    public Map<String, Object> obtenerDetallesPromocionUsuario(Usuario usuario) {
        GestorViajes gestorViajes = GestorViajes.getInstancia();
        Map<Usuario, List<Viaje>> viajesPorUsuario = gestorViajes.getMapaViajesPorUsuario();

        // Si el usuario no tiene viajes registrados, retornar null
        if (!viajesPorUsuario.containsKey(usuario)) {
            return null;
        }

        List<Viaje> viajes = viajesPorUsuario.get(usuario);
        Map<String, Object> detalles = new HashMap<>();

        // Calcular fechas de referencia
        LocalDate ahora = LocalDate.now();
        LocalDate haceUnMes = ahora.minusMonths(1);
        LocalDate haceTresMeses = ahora.minusMonths(3);
        LocalDate haceSeisMeses = ahora.minusMonths(6);

        // Filtrar viajes por periodo
        List<Viaje> viajesUltimoMes = filtrarViajesPorFecha(viajes, haceUnMes.atStartOfDay(ZoneId.systemDefault()).toInstant().toEpochMilli());
        List<Viaje> viajesUltimosTresMeses = filtrarViajesPorFecha(viajes, haceTresMeses.atStartOfDay(ZoneId.systemDefault()).toInstant().toEpochMilli());
        List<Viaje> viajesUltimosSeisMeses = filtrarViajesPorFecha(viajes, haceSeisMeses.atStartOfDay(ZoneId.systemDefault()).toInstant().toEpochMilli());

        // Verificar condiciones
        boolean condicion1 = verificarViajesUltimoMes(viajesUltimoMes);
        boolean condicion2 = verificarViajesConsecutivos(viajesUltimosTresMeses, 10, 3);
        boolean condicion3 = verificarUsoDeTodosLosTipos(viajesUltimosSeisMeses);

        // Si no cumple ninguna condición, retornar null
        if (!condicion1 && !condicion2 && !condicion3) {
            return null;
        }

        // Guardar detalles de las condiciones cumplidas
        detalles.put("condicion1", condicion1);
        detalles.put("condicion2", condicion2);
        detalles.put("condicion3", condicion3);
        detalles.put("viajesUltimoMes", viajesUltimoMes.size());

        return detalles;
    }

    // Verifica si un usuario específico es elegible para promoción
    public boolean esUsuarioElegibleParaPromocion(Usuario usuario) {
        return obtenerDetallesPromocionUsuario(usuario) != null;
    }

}

package GestorVehiculosBases.Facturas;

// Una clase genérica para cualquier reparación

import GestorVehiculosBases.Localizaciones.Base;

public class FacturaReparacionBase {

    Base base;
    Double coste;

    public FacturaReparacionBase(Base base) {
        this.base = base;
        this.coste = 120.0; // Coste fijo de reparación de base
    }

    public Base getBase() {
        return base;
    }

    public double getCoste() {
        return coste;
    }

}

package GestorVehiculosBases.Facturas;

import Enum.VehiculoEnum;
import GestorVehiculosBases.Vehiculos.Vehiculo;
import java.time.LocalDate;

public class FacturaReparacionVehiculo {

    private Vehiculo vehiculo;
    private int coste;
    private LocalDate fecha; // NUEVO CAMPO

    public FacturaReparacionVehiculo(Vehiculo vehiculo, LocalDate fecha) {
        this.vehiculo = vehiculo;
        this.fecha = fecha; // ASIGNAR FECHA
        VehiculoEnum tipo = vehiculo.getVehiculoEnum();
        switch (tipo) {
            case MOTOGRANDE:
                this.coste = 85;
                break;
            case MOTOPEQUENA:
                this.coste = 70;
                break;
            case PATINETE:
                this.coste = 50;
                break;
            case BICICLETA:
                this.coste = 35;
                break;
            default:
                this.coste = 0;
        }
    }

    public Vehiculo getVehiculo() {
        return vehiculo;
    }

    public int getCoste() {
        return coste;
    }

    public LocalDate getFecha() { // GETTER PARA LA FECHA
        return fecha;
    }
}

package GestorVehiculosBases.Localizaciones;

import Enum.VehiculoEnum;
import GestorPersonas.Personas.Usuario;
import GestorVehiculosBases.Vehiculos.Vehiculo;
import GestorVehiculosBases.Vehiculos.VehiculoDeCoordenadas;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class Base {

    //=================================================
    // ATRIBUTOS
    //=================================================
    private String nombre;
    private int coordenadaX;
    private int coordenadaY;
    private int capacidad;
    private boolean averias;
    private int viajesIniciados = 0;
    private int viajesFinalizados = 0;
    private List<Vehiculo> vehiculos = new ArrayList<>();
    private Map<Integer, Vehiculo> mapaVehiculosPorID = new HashMap<>();

    //=================================================
    // CONSTRUCTOR
    //=================================================
    public Base(String nombre, int coordenadaX, int coordenadaY, int capacidad) {
        this.nombre = nombre;
        this.coordenadaX = coordenadaX;
        this.coordenadaY = coordenadaY;
        this.capacidad = capacidad;
        this.vehiculos = new ArrayList<>();
        this.mapaVehiculosPorID = new HashMap<>();
    }

    //=================================================
    // MÉTODOS PARA AÑADIR/ELIMINAR VEHÍCULOS
    //=================================================

    /*
    Método para añadir un vehículo a la base.
    Verificas si el vehiculo es nulo y si hay espacio libre en la base.
    Si hay espacio, se añade el vehículo a la lista de vehículos de la base.
    Si el vehículo es nulo, se imprime un mensaje de error y se devuelve false.
    Solo puede ser llamado desde este paquete.
    */

    public boolean addVehiculo(Vehiculo vehiculo, int ID) {
        if (vehiculo == null) {
            System.out.println("El vehiculo no puede ser nulo");
            return false;
        }
        if (vehiculo instanceof VehiculoDeCoordenadas) {
            System.out.println("El vehiculo no puede ser una moto");
            return false;
        }
        if (ID <= 0) {
            System.out.println("El ID del vehículo no puede ser menor o igual a cero");
            return false;
        }
        if (getEspaciosLibres() > 0) {
            mapaVehiculosPorID.put(ID, vehiculo);
            vehiculos.add(vehiculo);
                return true; 
            } else {
                System.out.println("No hay espacio libre en la base");
                return false;
            }
    }

    /*
    Método para eliminar un vehículo de la base.
    Verificas si el ID del vehículo es válido y si existe en la lista de vehículos de la base.
    Si existe, se elimina el vehículo de la lista de vehículos de la base.
    Si no existe, se imprime un mensaje de error y se devuelve false.
     */
     public boolean removeVehiculoPorID(int ID) {   
        if (ID <= 0) {
            System.out.println("El ID del vehículo no puede ser menor o igual a cero");
            return false;
        }
        if (mapaVehiculosPorID.containsKey(ID)) {
            Vehiculo vehiculo = mapaVehiculosPorID.get(ID);
            vehiculos.remove(vehiculo);
            mapaVehiculosPorID.remove(ID);
            return true;
        } else {
            System.out.println("El vehículo con ID " + ID + " no existe en la base");
            return false;
        }
    }

    //=================================================
    // GETTER ASIGNAR VEHÍCULO
    //=================================================
    // Regresa un vehiculo de la base del tipo VehiculoEnum que no tenga averias y que tenga bateria suficiente
    public Vehiculo getVehiculoActivoPorTipo(VehiculoEnum vehiculoEnum, Usuario usuario) {
        for (Vehiculo vehiculo : vehiculos) {
            if (vehiculo.getVehiculoEnum() == vehiculoEnum && vehiculo.getDisponible(usuario)) {
                return vehiculo;
            }
        }
        return null;
    }

    //=================================================
    // GETTERS
    //=================================================
    public String getNombre() {
        return nombre;
    }

    public int getCoordenadaX() {
        return coordenadaX;
    }

    public int getCoordenadaY() {
        return coordenadaY;
    }

    public int getCapacidad() {
        return capacidad;
    }

    public boolean getAverias() {
        return averias;
    }

    public int getEspaciosLibres() {
        return capacidad - vehiculos.size();
    }

    public int getEspaciosOcupados() {
        return vehiculos.size();
    }

    public List<Vehiculo> getListaVehiculos() {
        return new ArrayList<>(vehiculos);
    }

    public int getViajesIniciadosEnBase() {
        return viajesIniciados;
    }

    public int getViajesFinalizadosEnBase() {
        return viajesFinalizados;
    }

    public int getPatinetesDisponibles(Usuario usuario) {
        return getListaPatinetesDisponibles(usuario).size();
    }

    public int getBicicletasDisponibles(Usuario usuario) {
        return getListaBicicletasDisponibles(usuario).size();
    }

    public int getVehiculosDisponibles(Usuario usuario) {
        return getPatinetesDisponibles(usuario) + getBicicletasDisponibles(usuario);
    }

    public int getTotalPatinetes() {
        int contador = 0;
        for (Vehiculo vehiculo : vehiculos) {
            if (vehiculo.getVehiculoEnum() == VehiculoEnum.PATINETE) {
                contador++;
            }
        }
        return contador;    
    }

    public int getTotalBicicletas() {
        int contador = 0;
        for (Vehiculo vehiculo : vehiculos) {
            if (vehiculo.getVehiculoEnum() == VehiculoEnum.BICICLETA) {
                contador++;
            }
        }
        return contador;    
    }
    
    //=================================================
    // GETTERS PARA LISTAS DE VEHÍCULOS
    //=================================================
    public List<Vehiculo> getListaVehiculosDisponibles(Usuario usuario) {
        List<Vehiculo> vehiculosActivos = new ArrayList<>();
        vehiculosActivos.addAll(getListaPatinetesDisponibles(usuario));
        vehiculosActivos.addAll(getListaBicicletasDisponibles(usuario));
        return vehiculosActivos;
    }

    private List<Vehiculo> getListaVehiculosActivosPorTipo(VehiculoEnum tipo, Usuario usuario) {
        List<Vehiculo> vehiculosActivos = new ArrayList<>();
        for (Vehiculo vehiculo : vehiculos) {
            if (vehiculo.getVehiculoEnum() == tipo && vehiculo.getDisponible(usuario)) {
                vehiculosActivos.add(vehiculo);
            }
        }
        return vehiculosActivos;
    }

    public List<Vehiculo> getListaPatinetesDisponibles(Usuario usuario) {
        return getListaVehiculosActivosPorTipo(VehiculoEnum.PATINETE, usuario);
    }

    public List<Vehiculo> getListaBicicletasDisponibles(Usuario usuario) {
        return getListaVehiculosActivosPorTipo(VehiculoEnum.BICICLETA, usuario);
    }

    //=================================================
    // SETTERS
    //=================================================
    public void setAverias(boolean averias) {
        this.averias = averias;
    }

    public void incrementarViajesIniciadosBase() {
        this.viajesIniciados++;
    }

    public void incrementarViajesFinalizadosBase() {
        this.viajesFinalizados++;
    }
}

package GestorVehiculosBases.Localizaciones;

import GestorVehiculosBases.Vehiculos.MotoGrande;
import GestorVehiculosBases.Vehiculos.Vehiculo;
import GestorVehiculosBases.Vehiculos.VehiculoDeCoordenadas;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class Mapa {

    //=================================================
    // ATRIBUTOS
    //=================================================

    private static Mapa instancia;
    private String nombreMapa;
    private int maxCoordenadaX;
    private int maxCoordenadaY;
    private Object[][] mapaCiudadEnCoordenadas;
    
    private final Map<String, Base> mapaBasesPorNombre = new HashMap<>();
    private Map<Integer, Vehiculo> mapaMotosPorID = new HashMap<>();

    //=================================================
    // CONSTRUCTOR Y SINGLETON
    //=================================================
    private Mapa() {}

    public static Mapa getInstancia() {
        if (instancia == null) {
            instancia = new Mapa();
        }
        return instancia;
    }

    //=================================================
    // INICIALIZACIÓN Y CONFIGURACIÓN
    //=================================================

    /**
     * Método para inicializar el mapa con un nombre y dimensiones.
     * El mapa tendrá las coordenadas desde (0,0) hasta (maxX,maxY).
     */
    public boolean inicializarMapa(String nombreMapa, int maxCoordenadaX, int maxCoordenadaY) {
        if (maxCoordenadaX <= 0 || maxCoordenadaY <= 0) {
            System.out.println("Error: Límites inválidos.");
            return false;
        }
        this.nombreMapa = nombreMapa;
        this.maxCoordenadaX = maxCoordenadaX;
        this.maxCoordenadaY = maxCoordenadaY;
        this.mapaCiudadEnCoordenadas = new Object[maxCoordenadaX + 1][maxCoordenadaY + 1];
        
        System.out.println("Mapa '" + nombreMapa + "' inicializado con dimensiones (" + maxCoordenadaX + ", " + maxCoordenadaY + ").");
        return true;
    }

    //=================================================
    // GESTIÓN DE COORDENADAS Y VALIDACIÓN
    //=================================================

    public boolean sonCoordenadasValidas(int x, int y) {
        return x >= 0 && x <= maxCoordenadaX && y >= 0 && y <= maxCoordenadaY;
    }

    public boolean sonCoordenadasOcupadas(int x, int y) {
        return mapaCiudadEnCoordenadas[x][y] != null;
    }

    public Object getContenidoCelda(int x, int y) {
        if (sonCoordenadasValidas(x, y)) {
            return mapaCiudadEnCoordenadas[x][y];
        }
        return null;
    }

    public Object[][] getMapaCiudadEnCoordenadas() {
        return mapaCiudadEnCoordenadas;
    }

    //=================================================
    // GESTIÓN DE BASES
    //=================================================

    /*
    Método para agregar una base al mapa, indicando su nombre, coordenadas y capacidad
    Devuelve true si se ha añadido correctamente, false si hay un error
    */
    public boolean addBase(String nombreBase, int x, int y, int capacidad) {
        if (!sonCoordenadasValidas(x, y) || sonCoordenadasOcupadas(x, y)) {
            System.out.println("Error: Coordenada ocupada o fuera de límites.");
            return false;
        }
        
        Base base = new Base(nombreBase, x, y, capacidad);
        mapaCiudadEnCoordenadas[x][y] = base;
        mapaBasesPorNombre.put(nombreBase, base);
        
        return true;
    }

    /*
    Método para eliminar una base del mapa indicando sus coordenadas
    Devuelve true si se ha eliminado correctamente, false si hay un error
    */
    public boolean removeBase(int x, int y) {
        if (sonCoordenadasValidas(x, y) && mapaCiudadEnCoordenadas[x][y] instanceof Base) {
            Base base = (Base) mapaCiudadEnCoordenadas[x][y];
            mapaBasesPorNombre.remove(base.getNombre());
            mapaCiudadEnCoordenadas[x][y] = null;
            System.out.println("Base '" + base.getNombre() + "' eliminada.");
            return true;
        }
        System.out.println("Error: No se puede eliminar la base en las coordenadas (" + x + ", " + y + ").");
        return false;
    }

    public boolean removeBase(String nombreBase) {
        Base base = mapaBasesPorNombre.remove(nombreBase);
        if (base != null) {
            int x = base.getCoordenadaX();
            int y = base.getCoordenadaY();
            mapaCiudadEnCoordenadas[x][y] = null;
            System.out.println("Base '" + nombreBase + "' eliminada.");
            return true;
        }
        System.out.println("Error: No se puede eliminar la base con nombre '" + nombreBase + "'.");
        return false;
    }

    //=================================================
    // GETTERS BASES
    //=================================================

    public Base getBasePorNombre(String nombreBase) {
        return mapaBasesPorNombre.get(nombreBase);
    }

    public List<Base> getListaBases() {
        return new ArrayList<>(mapaBasesPorNombre.values());
    }

    public Map<String, Base> getMapaBasesPorNombre() {
        return mapaBasesPorNombre;
    }
    
        public List<Base> getListaBasesSinAverias() {
        List<Base> basesActivas = new ArrayList<>();
        for (Base base : getListaBases()) {
            if (!base.getAverias()) {
                basesActivas.add(base);
            }
        }
        return basesActivas;
    }

    public List<Base> getListaBasesConAverias() {
        List<Base> basesConAverias = new ArrayList<>();
        for (Base base : getListaBases()) {
            if (base.getAverias()) {
                basesConAverias.add(base);
            }
        }
        return basesConAverias;
    }

    //=================================================
    // GESTIÓN DE MOTOS
    //=================================================

    /*
    Método para registrar una moto en el mapa indicando sus coordenadas y el objeto VehiculoDeCoordenadas
    Vereficas si las coordenadas son válidas y si están ocupadas
    Devuelve true si se ha registrado correctamente, false si hay un error
    */
    public boolean addVehiculo(int x, int y, VehiculoDeCoordenadas vehiculo) {
        if (!sonCoordenadasValidas(x, y) || sonCoordenadasOcupadas(x, y)) {
            System.out.println("Error: Coordenada ocupada o fuera de límites.");
            return false;
        }
        if (vehiculo == null) {
            System.out.println("Error: Vehículo nulo.");
            return false;
        } else {
            mapaCiudadEnCoordenadas[x][y] = vehiculo;
            mapaMotosPorID.put(vehiculo.getID(), vehiculo);
            vehiculo.setCoordenadaX(x);
            vehiculo.setCoordenadaY(y);
            System.out.println("Moto registrada en (" + x + ", " + y + "). ID: " + vehiculo.getID());
            return true;
        }
        
    }

    // Eliminar una moto del mapa por sus coordenadas
    public boolean removeVehiculoPorCoordenadas(int x, int y) {
        if (sonCoordenadasValidas(x, y) && mapaCiudadEnCoordenadas[x][y] instanceof Vehiculo) {
            Vehiculo vehiculo = (Vehiculo) mapaCiudadEnCoordenadas[x][y];
            mapaMotosPorID.remove(vehiculo.getID());
            mapaCiudadEnCoordenadas[x][y] = null;
            System.out.println("Moto eliminada de (" + x + ", " + y + "). ID: " + vehiculo.getID());
            return true;
        }
        System.out.println("Error: No se puede eliminar la moto en las coordenadas (" + x + ", " + y + ").");
        return false;
    }

    public void removeVehiculoPorID(int ID) {
        Vehiculo vehiculo = mapaMotosPorID.remove(ID);
        if (vehiculo != null) {
            int x = ((VehiculoDeCoordenadas)vehiculo).getCoordenadaX();
            int y = ((VehiculoDeCoordenadas)vehiculo).getCoordenadaY();
            removeVehiculoPorCoordenadas(x, y);
            System.out.println("Vehículo con ID " + ID + " eliminado.");
        } else {
            System.out.println("Error: Vehículo con ID " + ID + " no encontrado.");
        }
    }

    //=================================================
    // GETTERS
    //=================================================
    public String getNombre() {
        return nombreMapa;
    }

    public int getMaxCoordenadaX() {
        return maxCoordenadaX;
    }

    public int getMaxCoordenadaY() {
        return maxCoordenadaY;
    }  

    //=================================================
    // VISUALIZACIÓN MAPA
    //================================================
    
    // Método para dibujar el mapa en consola con diferenciación de motos grandes y pequeñas
    public void dibujarMapa() {
        if (mapaCiudadEnCoordenadas == null) {
            System.out.println("El mapa no ha sido inicializado. Usa inicializarMapa() primero.");
            return;
        }
        System.out.println("\nMapa: " + nombreMapa + " (" + maxCoordenadaX + "x" + maxCoordenadaY + ")");
        
        System.out.print("   ");
        for (int x = 0; x <= maxCoordenadaX; x++) {
            System.out.print(x % 10);
        }
        System.out.println();
        
        System.out.print("  +");
        for (int x = 0; x <= maxCoordenadaX; x++) {
            System.out.print("-");
        }
        System.out.println("+");
        
        for (int y = maxCoordenadaY; y >= 0; y--) {  
            System.out.printf("%2d|", y);
            for (int x = 0; x <= maxCoordenadaX; x++) {
                if (mapaCiudadEnCoordenadas[x][y] == null) {
                    System.out.print(" ");
                } else if (mapaCiudadEnCoordenadas[x][y] instanceof Base) {
                    System.out.print("B"); 
                } else if (mapaCiudadEnCoordenadas[x][y] instanceof Vehiculo) {
                    Vehiculo moto = (Vehiculo) mapaCiudadEnCoordenadas[x][y];
                    if (mapaCiudadEnCoordenadas[x][y] instanceof MotoGrande) {
                        System.out.print("M");
                    } else {
                        System.out.print("m");
                    }
                } else {
                    System.out.print("?");
                }
            }
            System.out.println("|");
        }
        
        System.out.print("  +");
        for (int x = 0; x <= maxCoordenadaX; x++) {
            System.out.print("-");
        }
        System.out.println("+");
        
        // Añadir leyenda
        System.out.println("\nLeyenda:");
        System.out.println("B = Base");
        System.out.println("M = Moto Grande");
        System.out.println("m = Moto Pequeña");
        System.out.println("? = Otro objeto");
    } 
}

package GestorVehiculosBases.Vehiculos;

import Enum.VehiculoEnum;

public class Bicicleta extends VehiculoDeBase {
    
    public Bicicleta(int ID, VehiculoEnum tipo) {
        super(ID, tipo);
    }

    @Override
    public String getNombreVehiculo() {
        return "Bicicleta";
    }
}


package GestorVehiculosBases.Vehiculos;

import Enum.VehiculoEnum;

public class MotoGrande extends VehiculoDeCoordenadas {
    
    public MotoGrande(int ID, VehiculoEnum tipo) {
        super(ID, tipo);
    }

    @Override
    public String getNombreVehiculo() {
        return "Moto Grande";
    }
}

package GestorVehiculosBases.Vehiculos;

import Enum.VehiculoEnum;

public class MotoPequena extends VehiculoDeCoordenadas {
    
    public MotoPequena(int ID, VehiculoEnum tipo) {
        super(ID, tipo);
    }

    @Override
    public String getNombreVehiculo() {
        return "Moto Pequeña";
    }
}

package GestorVehiculosBases.Vehiculos;

import Enum.VehiculoEnum;

public class Patinete extends VehiculoDeBase {
    
    public Patinete(int ID, VehiculoEnum tipo) {
        super(ID, tipo);
    }

    @Override
    public String getNombreVehiculo() {
        return "Patinete";
    }
}


package GestorVehiculosBases.Vehiculos;

import Enum.VehiculoEnum;
import GestorPersonas.Personas.Premium;
import GestorPersonas.Personas.Usuario;
import GestorViajes.Beneficios;

public abstract class Vehiculo {

    private int ID;
    private VehiculoEnum tipoVehiculo;
    private double bateria;
    private boolean averias = false;
    private boolean reservado = false;
    private boolean enUso = false;

    public Vehiculo(int ID, VehiculoEnum tipoVehiculo) {
        this.tipoVehiculo = tipoVehiculo;
        this.ID = ID;
        this.bateria = Beneficios.getBateriaMaxima();
        this.averias = false;
        this.reservado = false;
    }

    public int getID() {
        return ID;
    }

    public double getBateria() {
        return bateria;
    }

    public void setBateria(double bateria) {
        this.bateria = bateria;
    }

    public VehiculoEnum getVehiculoEnum() {
        return tipoVehiculo;
    }

    public abstract String getNombreVehiculo();

    public boolean getAverias(){
        return averias;
    }

    public void setAverias(boolean averias) {
        this.averias = averias;
    }
    
    public boolean getReservado() {
        return reservado;
    }

    public double getBateriaMinima(Usuario usuario) {
        if (usuario instanceof Premium) {
            return Beneficios.getBateriaMinimaPremium();
        } else {
            return Beneficios.getBateriaMinimaStandard();
        }
    }

    public boolean getEnUso() {
        return enUso; 
    }

    public void setEnUso(boolean enUso) {
        this.enUso = enUso;
    }

    public boolean getDisponible(Usuario usuario) {
        return getBateria() > getBateriaMinima(usuario) && !getAverias() && !getReservado() && !getEnUso();
    }

    public void setReservado(boolean reservado) {
        this.reservado = reservado;
    }
}

package GestorVehiculosBases.Vehiculos;

import Enum.VehiculoEnum;
import GestorVehiculosBases.Localizaciones.Base;

public abstract class VehiculoDeBase extends Vehiculo {
    private Base base;
    
    public VehiculoDeBase(int ID, VehiculoEnum tipo) {
        super(ID, tipo);
    }
    
    public Base getBase() {
        return base;
    }
    
    public void setBase(Base base) {
        this.base = base;
    }
}

package GestorVehiculosBases.Vehiculos;

import Enum.VehiculoEnum;

public abstract class VehiculoDeCoordenadas extends Vehiculo {
    private int coordenadaX;
    private int coordenadaY;
    
    public VehiculoDeCoordenadas(int ID, VehiculoEnum tipo) {
        super(ID, tipo);
    }
    
    public int getCoordenadaX() {
        return coordenadaX;
    }
    
    public void setCoordenadaX(int coordenadaX) {
        this.coordenadaX = coordenadaX;
    }
    
    public int getCoordenadaY() {
        return coordenadaY;
    }
    
    public void setCoordenadaY(int coordenadaY) {
        this.coordenadaY = coordenadaY;
    }
}



package GestorVehiculosBases;

import GestorPersonas.GestorPersonas;
import GestorPersonas.Personas.Mecanico;
import GestorPersonas.Personas.Usuario;
import GestorVehiculosBases.Localizaciones.Mapa;
import GestorVehiculosBases.Localizaciones.Base;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class GestorBases {

    //=================================================
    // ATRIBUTOS
    //=================================================    
    
    private static GestorBases instancia;
    private Mapa mapa;
    private GestorVehiculos gestorVehiculos;
    private Map<String, LocalDateTime> basesDesactivadas = new HashMap<>();

    //=================================================
    // CONSTRUCTOR Y SINGLETON
    //=================================================

    private GestorBases() {
        this.gestorVehiculos = GestorVehiculos.getInstancia();
        this.mapa = Mapa.getInstancia();
    }

    public static GestorBases getInstancia() {
        if (instancia == null) {
            instancia = new GestorBases();
        }
        return instancia;
    }

    //=================================================
    // GESTIÓN DE BASES
    //=================================================

    // Añade una base por coordenadas, validando todos los parámetros de entrada y la existencia previa.
    public boolean addBasePorCoordenadas(String nombre, int x, int y, int capacidad) {
        // Validación de instancia de mapa
        if (mapa == null) {
            System.out.println("Error: El mapa no está inicializado.");
            return false;
        }
        // Validación de nombre
        if (nombre == null || nombre.trim().isEmpty()) {
            System.out.println("Error: El nombre de la base no puede estar vacío.");
            return false;
        }
        // Validación de coordenadas (puedes ajustar los límites según tu mapa)
        if (x < 0 || y < 0) {
            System.out.println("Error: Las coordenadas deben ser valores positivos.");
            return false;
        }
        // Validación de capacidad
        if (capacidad <= 0) {
            System.out.println("Error: La capacidad debe ser mayor que cero.");
            return false;
        }
        // Validación de duplicidad por nombre
        if (mapa.getBasePorNombre(nombre) != null) {
            System.out.println("Error: Ya existe una base con ese nombre.");
            return false;
        }
        // Llama al método addBase de Mapa y devuelve el resultado
        return mapa.addBase(nombre, x, y, capacidad);
    }

    // Elimina una base por coordenadas, validando todos los parámetros de entrada y la existencia previa.
    public boolean removeBasePorCoordenadas(int x, int y) {
        // Validación de instancia de mapa
        if (mapa == null) {
            System.out.println("Error: El mapa no está inicializado.");
            return false;
        }
        // Validación de coordenadas (puedes ajustar los límites según tu mapa)
        if (x < 0 || y < 0) {
            System.out.println("Error: Las coordenadas deben ser valores positivos.");
            return false;
        }
        // Llama al método removeBase de Mapa y devuelve el resultado
        return mapa.removeBase(x, y);
    }

    // Elimina una base por nombre
    public boolean removeBasePorNombre(String nombre) {
        // Validación de instancia de mapa
        if (mapa == null) {
            System.out.println("Error: El mapa no está inicializado.");
            return false;
        }
        // Validación de nombre
        if (nombre == null || nombre.trim().isEmpty()) {
            System.out.println("Error: El nombre de la base no puede estar vacío.");
            return false;
        }
        // Llama al método removeBase de Mapa y devuelve el resultado
        return mapa.removeBase(nombre);
    }

    //=================================================
    // ASIGNAR AVERIA BASE A MECANICO
    //=================================================

    // Asignar mecánico a avería en base
    public boolean asignarMecanicoAveriaBase(String DNIMecanico, String nombreBase) {
        if (DNIMecanico == null || DNIMecanico.isEmpty() || nombreBase == null || nombreBase.isEmpty()) {
            System.out.println("Error: DNI o nombre de base inválido");
            return false;
        }
        GestorPersonas gestorPersonas = GestorPersonas.getInstancia();
        Object personaMecanico = gestorPersonas.getPersonaPorDNI(DNIMecanico);
        if (!(personaMecanico instanceof Mecanico)) {
            System.out.println("Error: El DNI no corresponde a un mecánico.");
            return false;
        }
        Mecanico mecanico = (Mecanico) personaMecanico;

        Base base = mapa.getBasePorNombre(nombreBase);
        if (base == null) {
            System.out.println("Error: No se encontró la base '" + nombreBase + "'");
            return false;
        }

        if (base.getAverias()) {
            if (!mecanico.getBasesAveriadas().contains(base)) {
                mecanico.addBaseAveriada(base);
                System.out.println("Base '" + nombreBase + "' averiada asignada al mecánico " + DNIMecanico);
                return true;
            } else {
                System.out.println("La base '" + nombreBase + "' ya está asignada al mecánico.");
                return false;
            }
        } else {
            System.out.println("La base '" + nombreBase + "' no está averiada.");
            return false;
        }
    }

    //=================================================
    // INFORME BASES
    //=================================================

    // Muestra un informe detallado de todas las bases del sistema para el usuario dado.
    public void mostrarDetalleBases(Usuario usuario) {
        System.out.println("\n=== INFORME DETALLADO DE BASES ===");

        // Obtiene la lista de bases directamente desde el Mapa
        List<Base> bases = mapa.getListaBases();

        // Verifica si hay bases registradas
        if (bases == null || bases.isEmpty()) {
            System.out.println("No hay bases registradas en el sistema.");
            return;
        }

        // Cabecera del informe
        System.out.println("\n--- ESTADO GENERAL DE BASES ---");
        System.out.printf("%-15s %-12s %-10s %-12s %-12s %-12s %-12s %-10s\n",
                "Nombre", "Coord.", "Capacidad", "Patinetes", "Pat. Disp.", "Bicicletas", "Bici. Disp.", "Averías");
        System.out.println("------------------------------------------------------------------------------------------------------");

        // Estadísticas globales
        int baseConAverias = 0;
        int capacidadTotal = 0;
        int vehiculosEnBases = 0;
        int patineteTotal = 0;
        int bicicletaTotal = 0;
        int patineteDisponible = 0;
        int bicicletaDisponible = 0;

        // Recorre cada base y muestra su información
        for (Base base : bases) {
            int capacidad = base.getCapacidad();
            int ocupados = base.getEspaciosOcupados();
            int patinetes = base.getTotalPatinetes();
            int patinetesDisp = base.getPatinetesDisponibles(usuario);
            int bicicletas = base.getTotalBicicletas();
            int bicicletasDisp = base.getBicicletasDisponibles(usuario);
            boolean averias = base.getAverias();

            System.out.printf("%-15s (%2d,%2d)   %-10d %-12d %-12d %-12d %-12d %-10s\n",
                    base.getNombre(),
                    base.getCoordenadaX(), base.getCoordenadaY(),
                    capacidad,
                    patinetes, patinetesDisp,
                    bicicletas, bicicletasDisp,
                    averias ? "SÍ" : "NO");

            // Acumula estadísticas globales
            if (averias) baseConAverias++;
            capacidadTotal += capacidad;
            vehiculosEnBases += ocupados;
            patineteTotal += patinetes;
            patineteDisponible += patinetesDisp;
            bicicletaTotal += bicicletas;
            bicicletaDisponible += bicicletasDisp;
        }

        int porcentajeOcupacionGlobal = capacidadTotal > 0 ? vehiculosEnBases * 100 / capacidadTotal : 0;

        // Muestra estadísticas globales
        System.out.println("\n--- ESTADÍSTICAS GLOBALES DE BASES ---");
        System.out.println("Total de bases: " + bases.size());
        System.out.println("  - Con averías: " + baseConAverias);
        System.out.println("Capacidad total del sistema: " + capacidadTotal + " vehículos");
        System.out.println("Ocupación actual: " + vehiculosEnBases + " vehículos (" + porcentajeOcupacionGlobal + "%)");
        System.out.println("  - Patinetes: " + patineteTotal + " (Disponibles: " + patineteDisponible + ")");
        System.out.println("  - Bicicletas: " + bicicletaTotal + " (Disponibles: " + bicicletaDisponible + ")");
    }

    //=================================================
    // DESACTIVAR BASES
    //=================================================

    public boolean desactivarBase(String nombreBase, int minutos) {
        Base base = Mapa.getInstancia().getBasePorNombre(nombreBase);
        if (base == null) return false;

        LocalDateTime ahora = LocalDateTime.now();
        if (basesDesactivadas.containsKey(nombreBase)) {
            LocalDateTime fin = basesDesactivadas.get(nombreBase);
            if (ahora.isBefore(fin)) return false;
        }
        basesDesactivadas.put(nombreBase, ahora.plusMinutes(minutos));
        return true;
    }

    public boolean baseEstaDesactivada(String nombreBase) {
        if (!basesDesactivadas.containsKey(nombreBase)) return false;
        LocalDateTime ahora = LocalDateTime.now();
        LocalDateTime fin = basesDesactivadas.get(nombreBase);
        if (ahora.isAfter(fin)) {
            basesDesactivadas.remove(nombreBase);
            return false;
        }
        return true;
    }
}
package GestorVehiculosBases;

import Enum.VehiculoEnum;
import GestorPersonas.GestorPersonas;
import GestorPersonas.Personas.Mantenimiento;
import GestorPersonas.Personas.Mecanico;
import GestorPersonas.Personas.Usuario;
import GestorVehiculosBases.Localizaciones.Base;
import GestorVehiculosBases.Localizaciones.Mapa;
import GestorVehiculosBases.Vehiculos.Bicicleta;
import GestorVehiculosBases.Vehiculos.MotoGrande;
import GestorVehiculosBases.Vehiculos.MotoPequena;
import GestorVehiculosBases.Vehiculos.Patinete;
import GestorVehiculosBases.Vehiculos.Vehiculo;
import GestorVehiculosBases.Vehiculos.VehiculoDeBase;
import GestorVehiculosBases.Vehiculos.VehiculoDeCoordenadas;
import java.util.ArrayList;
import java.util.List;

public class GestorVehiculos {

    private static GestorVehiculos instancia;
    private List<Vehiculo> vehiculos = new ArrayList<>();
    private List<Vehiculo> vehiculosEnMapa = new ArrayList<>();
    private List<Vehiculo> vehiculosEnBases = new ArrayList<>();
    private int contadorID = 1;
    private Mapa mapa = Mapa.getInstancia();

    private GestorVehiculos() {
    }

    public static GestorVehiculos getInstancia() {
        if (instancia == null) {
            instancia = new GestorVehiculos();
        }
        return instancia;
    }

    //=================================================
    // GETTERS
    //=================================================
    public Vehiculo getVehiculoPorID(int ID) {
        for (Vehiculo vehiculo : vehiculos) {
            if (vehiculo.getID() == ID) {
                return vehiculo;
            }
        }
        return null;
    }

    public List<Vehiculo> getVehiculosEnMapa() {
        return new ArrayList<>(vehiculosEnMapa);
    }

    public List<Vehiculo> getVehiculosEnBases() {
        return new ArrayList<>(vehiculosEnBases);
    }

    public List<Vehiculo> getListaVehiculosAlmacenados() {
        List<Vehiculo> vehiculosAlmacenados = new ArrayList<>(vehiculos);
        vehiculosAlmacenados.removeAll(vehiculosEnMapa);
        vehiculosAlmacenados.removeAll(vehiculosEnBases);
        return vehiculosAlmacenados;
    }

    public List<Vehiculo> getListaVehiculos() {
        return new ArrayList<>(vehiculos);
    }

    //=================================================
    // MÉTODOS DE GESTIÓN DE VEHÍCULOS
    //=================================================

    /*
    Metodo para añadir un vehículo a la base  y a la lista completa de vehiculos
    Verifica si el vehiculo es nulo, si la base es nula y si la base tiene espacios libres.
     */
    public Vehiculo addVehiculoBase(VehiculoEnum tipoVehiculo, Base base) {
        if (base == null) {
            System.out.println("La base no puede ser nula");
            return null;
        }
        if (tipoVehiculo == null) {
            System.out.println("El tipo de vehículo no puede ser nulo");
            return null;
        }
        if (base.getEspaciosLibres() <= 0) {
            System.out.println("La base '" + base.getNombre() + "' no tiene espacios disponibles");
            return null;
        }
        VehiculoDeBase vehiculo;
        if (tipoVehiculo == VehiculoEnum.BICICLETA) {
            vehiculo = new Bicicleta(contadorID, tipoVehiculo);
            contadorID++;
        } else if (tipoVehiculo == VehiculoEnum.PATINETE) {
            vehiculo = new Patinete(contadorID, tipoVehiculo);
            contadorID++;
        } else {
            System.out.println("Tipo de vehículo no válido");
            return null;
        }
        if (base.addVehiculo(vehiculo, contadorID)) {
            vehiculosEnBases.add(vehiculo);
            vehiculos.add(vehiculo);
            vehiculo.setBase(base);
            return vehiculo;
        } else {
            return null;
        }
    }

    /*
    Metodo para sacar un vehículo de la base sin eliminarlo de la lista completa de vehiculos
    Verifica si el ID es valido, si el vehiculo es instancia de VehiculoDeBase y si la base es nula.
         */
    public boolean removeVehiculoBasePorID(int ID) {
        if (ID <= 0) {
            System.out.println("Error: ID inválido");
            return false;
        }
        Vehiculo vehiculo = getVehiculoPorID(ID);
        if (vehiculo instanceof VehiculoDeBase) {
            Base base = ((VehiculoDeBase) vehiculo).getBase();
            if (base == null) {
                System.out.println("Error: El vehículo con ID " + ID + " no está asociado a ninguna base.");
                return false;
            }
            if (base.removeVehiculoPorID(ID)) {
                vehiculosEnBases.remove(vehiculo);
                System.out.println("Vehículo ID " + ID + " retirado de la base y trasladado al almacen.");
                return true;
            } else {
                System.out.println("Error: No se pudo retirar el vehículo ID " + ID + " de la base.");
                return false;
            }
        } else {
            System.out.println("Error: El vehículo con ID " + ID + " no es un VehiculoDeBase.");
            return false;
        }
    }

    /*
    Método para añadir un vehículo al mapa y a la lista completa de vehículos.
    Verifica si el tipo de vehículo es nulo, si las coordenadas son válidas y si la posición está ocupada.
    */
    public Vehiculo addVehiculoMapa(VehiculoEnum tipoVehiculo, int x, int y) {
        if (tipoVehiculo == null) {
            System.out.println("El tipo dehículo no puede ser nulo");
            return null;
        }
        if (!mapa.sonCoordenadasValidas(x, y)) {
            System.out.println("Las coordenadas (" + x + ", " + y + ") son inválidas");
            return null;
        }
        if (mapa.sonCoordenadasOcupadas(x, y)) {
            System.out.println("La posición (" + x + ", " + y + ") ya está ocupada");
            return null;
        }
        VehiculoDeCoordenadas vehiculo;
        if (tipoVehiculo == VehiculoEnum.MOTOGRANDE) {
            vehiculo = new MotoGrande(contadorID, tipoVehiculo);
            contadorID++;
        } else if (tipoVehiculo == VehiculoEnum.MOTOPEQUENA) {
            vehiculo = new MotoPequena(contadorID, tipoVehiculo);
            contadorID++;
        } else
        {
            System.out.println("Tipo de vehículo no válido");
            return null;
        }
        if (mapa.addVehiculo(x, y, vehiculo)) {
            vehiculosEnMapa.add(vehiculo);
            vehiculos.add(vehiculo);
            vehiculo.setCoordenadaX(x);
            vehiculo.setCoordenadaY(y);
            return vehiculo;
        } else {
            return null;
        }
    }

    /*
    Metodo para sacar un vehículo del mapa sin eliminarlo de la lista completa de vehiculos
    Verifica si el ID es valido
    */
    public boolean removeVehiculoMapaPorCoordenadas(int x, int y) {
        if (!mapa.sonCoordenadasValidas(x, y)){
            System.out.println("Error: Las coordenadas (" + x + ", " + y + ") son inválidas");
            return false;
        }
        if (mapa.removeVehiculoPorCoordenadas(x, y)) {
            Object contenidoCelda = mapa.getContenidoCelda(x, y);
            int ID = ((Vehiculo) contenidoCelda).getID();
            if (contenidoCelda instanceof Vehiculo) {
                Vehiculo vehiculo = getVehiculoPorID(ID);
                vehiculosEnMapa.remove(vehiculo);
            }
            System.out.println("Vehículo ID " + ID + " retirado del mapa y trasladado al almacen.");
            return true;
        } else {
            System.out.println("Error: No se pudo retirar el vehículo de las coordenadas (" + x + ", " + y + ")");
            return false;
        }
    }

    

    public boolean desecharVehiculoPorID(int ID) {
        if (ID <= 0) {
            System.out.println("Error: ID inválido");
            return false;
        }
        Vehiculo vehiculo = getVehiculoPorID(ID);
        if (vehiculo != null) {
            if (vehiculo instanceof VehiculoDeCoordenadas) {
                vehiculosEnMapa.remove(vehiculo);
                mapa.removeVehiculoPorID(ID);
            } else if (vehiculo instanceof VehiculoDeBase) {
                Base base = ((VehiculoDeBase) vehiculo).getBase();
                if (base != null) {
                    base.removeVehiculoPorID(ID);
                    vehiculosEnBases.remove(vehiculo);
                }
            }
            vehiculos.remove(vehiculo);
            System.out.println("Vehículo ID " + ID + " retirado de la flota y desechado.");
            return true;
        } else {
            System.out.println("Error: No se encontró el vehículo con ID " + ID);
            return false;
        }
    }

    public Vehiculo addVehiculoAlmacen(VehiculoEnum tipoVehiculo) {
        Vehiculo vehiculo = null;
        switch (tipoVehiculo) {
            case BICICLETA:
                vehiculo = new Bicicleta(contadorID, tipoVehiculo);
                break;
            case PATINETE:
                vehiculo = new Patinete(contadorID, tipoVehiculo);
                break;
            case MOTOGRANDE:
                vehiculo = new MotoGrande(contadorID, tipoVehiculo);
                break;
            case MOTOPEQUENA:
                vehiculo = new MotoPequena(contadorID, tipoVehiculo);
                break;
        }
        if (vehiculo != null) {
            vehiculos.add(vehiculo);
            contadorID++;
        }
        return vehiculo;
    }

    //=================================================
    // MÉTODOS DE GESTIÓN DE VEHÍCULOS
    //=================================================

    /*
    Método para mover un vehículo de coordenadas a otra posición en el mapa.
    Verifica si el ID es válido, si el vehículo existe, si es un vehículo de coordenadas,
    si las nuevas coordenadas son válidas y si la posición está ocupada.
     */
    public boolean moverVehiculoACoordenadas(int ID, int nuevaCoordenadaX, int nuevaCoordenadaY) {
        if (ID <= 0) {
            System.out.println("Error: ID inválido");
            return false;
        }
        Vehiculo vehiculo = getVehiculoPorID(ID);
        if (vehiculo == null) {
            System.out.println("Error: No se encontró ningún vehículo con ID " + ID);
            return false;
        }
        if (!(vehiculo instanceof VehiculoDeCoordenadas)) {
            System.out.println("Error: El vehículo con ID " + ID + " no es un vehículo de coordenadas.");
            return false;
        }
        if (!vehiculosEnMapa.contains(vehiculo)) {
            System.out.println("Error: El vehículo con ID " + ID + " no está actualmente en el mapa.");
            return false;
        }
        if (!mapa.sonCoordenadasValidas(nuevaCoordenadaX, nuevaCoordenadaY)) {
            System.out.println("Error: Las coordenadas (" + nuevaCoordenadaX + ", " + nuevaCoordenadaY + ") están fuera de los límites del mapa.");
            return false;
        }
        VehiculoDeCoordenadas vehiculoMovido = (VehiculoDeCoordenadas) vehiculo;
        int coordenadaXActual = vehiculoMovido.getCoordenadaX();
        int coordenadaYActual = vehiculoMovido.getCoordenadaY();
        if (coordenadaXActual == nuevaCoordenadaX && coordenadaYActual == nuevaCoordenadaY) {
            System.out.println("El vehículo ya está en la posición (" + nuevaCoordenadaX + ", " + nuevaCoordenadaY + ")");
            return false;
        }
        if (mapa.sonCoordenadasOcupadas(nuevaCoordenadaX, nuevaCoordenadaY)) {
            System.out.println("Error: La posición (" + nuevaCoordenadaX + ", " + nuevaCoordenadaY + ") ya está ocupada.");
            return false;
        }
        if (!mapa.sonCoordenadasValidas(coordenadaXActual, coordenadaYActual)) {
            System.out.println("Error: Las coordenadas actuales del vehículo son inválidas.");
            return false;
        }
        if (mapa.removeVehiculoPorCoordenadas(coordenadaXActual, coordenadaYActual)) {
            vehiculoMovido.setCoordenadaX(nuevaCoordenadaX);
            vehiculoMovido.setCoordenadaY(nuevaCoordenadaY);
            if (mapa.addVehiculo(nuevaCoordenadaX, nuevaCoordenadaY, vehiculoMovido)) {
                System.out.println("Vehículo " + vehiculo.getVehiculoEnum() + " con ID " + ID
                        + " movido de (" + coordenadaXActual + ", " + coordenadaYActual + ") a (" + nuevaCoordenadaX + ", " + nuevaCoordenadaY + ")");
                return true;
            } else {
                System.out.println("Error: No se pudo mover el vehículo a la nueva posición.");
            }
        } else {
            System.out.println("Error: No se pudo quitar el vehículo de su posición actual.");
        }
        return false;
    }

    /*
    Método para mover un vehículo de una base a otra base.
    Verifica si el ID es válido, si el vehículo existe, si es un VehiculoDeBase,
    si la base destino existe, si tiene espacios disponibles y si el vehículo ya está en la base destino.
     */
    public boolean moverVehiculoABase(int ID, String nombre) {
        if (ID <= 0) {
            System.out.println("Error: ID inválido");
            return false;
        }
        if (nombre == null || nombre.isEmpty()) {
            System.out.println("Error: Nombre de base inválido");
            return false;
        }
        Vehiculo vehiculo = getVehiculoPorID(ID);
        if (vehiculo == null) {
            System.out.println("Error: No se encontró el vehículo con ID " + ID);
            return false;
        }
        if (!(vehiculo instanceof VehiculoDeBase)) {
            System.out.println("Error: El vehículo con ID " + ID + " no es un VehiculoDeBase.");
            return false;
        }
        Base baseDestino = mapa.getBasePorNombre(nombre);
        if (baseDestino == null) {
            System.out.println("Error: No se encontró la base '" + nombre + "'");
            return false;
        }
        if (baseDestino.getEspaciosLibres() <= 0) {
            System.out.println("Error: La base '" + nombre + "' no tiene espacios disponibles");
            return false;
        }
        Base baseActual = ((VehiculoDeBase) vehiculo).getBase();
        if (baseActual != null && baseActual.equals(baseDestino)) {
            System.out.println("Error: El vehículo ya está en la base '" + nombre + "'");
            return false;
        }
        // Quitar de la base actual si es necesario
        if (baseActual != null) {
            baseActual.removeVehiculoPorID(ID);
        }
        // Añadir a la base destino
        if (baseDestino.addVehiculo(vehiculo, ID)) {
            ((VehiculoDeBase) vehiculo).setBase(baseDestino);
            if (!vehiculosEnBases.contains(vehiculo)) {
                vehiculosEnBases.add(vehiculo);
            }
            System.out.println("Vehículo ID " + ID + " movido a la base '" + nombre + "'");
            return true;
        } else {
            System.out.println("Error: No se pudo añadir el vehículo a la base '" + nombre + "'");
            return false;
        }
    }

    
    //=================================================
    // MÉTODO LOCALIZAR VEHÍCULO MÁS CERCANO
    //=================================================

    public Vehiculo getVehiculoMasCercano(int x, int y, VehiculoEnum tipoVehiculo, Usuario usuario) {
        double distanciaMinima = 0;
        Vehiculo vehiculoMasCercano = null;
        boolean esPrimero = true;

        if (tipoVehiculo == VehiculoEnum.MOTOPEQUENA || tipoVehiculo == VehiculoEnum.MOTOGRANDE) {
            for (Vehiculo vehiculo : vehiculosEnMapa) {
                if (vehiculo.getVehiculoEnum() == tipoVehiculo && vehiculo.getDisponible(usuario)) {
                    double distancia = calcularDistancia(x, y, ((VehiculoDeCoordenadas) vehiculo).getCoordenadaX(), 
                    ((VehiculoDeCoordenadas) vehiculo).getCoordenadaY());
                    if (esPrimero || distancia < distanciaMinima) {
                        distanciaMinima = distancia;
                        vehiculoMasCercano = vehiculo;
                        esPrimero = false;
                    }
                }
            }
        } else if (tipoVehiculo == VehiculoEnum.BICICLETA || tipoVehiculo == VehiculoEnum.PATINETE) {
            for (Vehiculo vehiculo : vehiculosEnBases) {
                if (vehiculo.getVehiculoEnum() == tipoVehiculo && vehiculo.getDisponible(usuario)) {
                    double distancia = calcularDistancia(x, y, ((VehiculoDeBase) vehiculo).getBase().getCoordenadaX(), 
                    ((VehiculoDeBase) vehiculo).getBase().getCoordenadaY());
                    if (esPrimero || distancia < distanciaMinima) {
                        distanciaMinima = distancia;
                        vehiculoMasCercano = vehiculo;
                        esPrimero = false;
                    }
                }
            }
        }

        return vehiculoMasCercano;
    }

    // MÉTODOS AUXILIARES
    private double calcularDistancia(int x1, int y1, int x2, int y2) {
        return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
    }

    //=================================================
    // MÉTODOS DE VISUALIZACIÓN VEHÍCULOS
    //=================================================

    /**
     * Muestra un resumen y el detalle completo de todos los vehículos del sistema,
     * incluyendo estado de batería, averías, uso, reserva y ubicación.
     */
    public void mostrarDetallesVehiculos() {
        List<Vehiculo> vehiculosAlmacenados = getListaVehiculosAlmacenados();
        List<Vehiculo> vehiculosMapa = getVehiculosEnMapa();
        List<Vehiculo> vehiculosBases = getVehiculosEnBases();

        System.out.println("\n===============================");
        System.out.println("   RESUMEN DE VEHÍCULOS");
        System.out.println("===============================");
        System.out.printf("Total de vehículos: %d\n", getListaVehiculos().size());
        System.out.printf(" - En almacén: %d\n", vehiculosAlmacenados.size());
        System.out.printf(" - En mapa:    %d\n", vehiculosMapa.size());
        System.out.printf(" - En bases:   %d\n", vehiculosBases.size());

        System.out.println("\n-------------------------------------------------------------");
        System.out.println("DETALLE DE VEHÍCULOS");
        System.out.println("-------------------------------------------------------------");
        System.out.printf("%-5s %-15s %-10s %-8s %-8s %-10s %-20s\n",
                "ID", "Tipo", "Batería", "Averías", "En Uso", "Reservado", "Ubicación");
        System.out.println("-------------------------------------------------------------------------------");

        // Unificar todos los vehículos sin duplicados
        List<Vehiculo> todosLosVehiculos = new ArrayList<>();
        for (Vehiculo v : getListaVehiculos()) {
            if (!todosLosVehiculos.contains(v)) {
                todosLosVehiculos.add(v);
            }
        }

        for (Vehiculo vehiculo : todosLosVehiculos) {
            String ubicacion;
            if (vehiculosAlmacenados.contains(vehiculo)) {
                ubicacion = "Almacén";
            } else if (vehiculosMapa.contains(vehiculo)) {
                if (vehiculo instanceof VehiculoDeCoordenadas vdc) {
                    ubicacion = "Mapa (" + vdc.getCoordenadaX() + "," + vdc.getCoordenadaY() + ")";
                } else {
                    ubicacion = "Mapa";
                }
            } else if (vehiculosBases.contains(vehiculo)) {
                if (vehiculo instanceof VehiculoDeBase vdb) {
                    Base base = vdb.getBase();
                    if (base != null) {
                        ubicacion = "Base: " + base.getNombre();
                    } else {
                        ubicacion = "Sin base";
                    }
                } else {
                    ubicacion = "Base";
                }
            } else {
                ubicacion = "Desconocida";
            }

            String averias = vehiculo.getAverias() ? "SÍ" : "NO";
            String enUso = vehiculo.getEnUso() ? "SÍ" : "NO";
            String reservado = vehiculo.getReservado() ? "SÍ" : "NO";

            System.out.printf("%-5d %-15s %-10s %-8s %-8s %-10s %-20s\n",
                    vehiculo.getID(),
                    vehiculo.getVehiculoEnum(),
                    vehiculo.getBateria() + "%",
                    averias,
                    enUso,
                    reservado,
                    ubicacion);
        }
        System.out.println("-------------------------------------------------------------------------------");
        System.out.println("Fin del listado.\n");
    }
    

    //=================================================
    // MÉTODOS ASIGNACION MANTENIMIENTO Y MECANICO
    //=================================================
    public boolean asignarMantenimiento(String DNI, int idVehiculo) {
        if (DNI == null || DNI.isEmpty()) {
            System.out.println("Error: DNI inválido");
            return false;
        }

        // Buscar el trabajador de mantenimiento por DNI
        GestorPersonas gestorPersonas = GestorPersonas.getInstancia();
        Object persona = gestorPersonas.getPersonaPorDNI(DNI);
        if (!(persona instanceof Mantenimiento)) {
            System.out.println("Error: El DNI no corresponde a un trabajador de mantenimiento.");
            return false;
        }
        Mantenimiento mantenimiento = (Mantenimiento) persona;

        Vehiculo vehiculo = getVehiculoPorID(idVehiculo);
        if (vehiculo == null) {
            System.out.println("Error: Vehículo no encontrado.");
            return false;
        }

        boolean asignado = false;

        if (vehiculo.getBateria() < 20) {
            vehiculo.setEnUso(false);
            vehiculo.setReservado(true);
            if (!mantenimiento.getVehiculosSinBateria().contains(vehiculo)) {
                mantenimiento.getVehiculosSinBateria().add(vehiculo);
            }
            System.out.println("Vehículo ID " + vehiculo.getID() + " asignado a mantenimiento por batería baja.");
            asignado = true;
        }
        if (vehiculo.getAverias()) {
            vehiculo.setEnUso(false);
            vehiculo.setReservado(true);
            if (!mantenimiento.getVehiculosAveriados().contains(vehiculo)) {
                mantenimiento.getVehiculosAveriados().add(vehiculo);
            }
            System.out.println("Vehículo ID " + vehiculo.getID() + " asignado a mantenimiento por avería.");
            asignado = true;
        }

        if (!asignado) {
            System.out.println("El vehículo no requiere mantenimiento (ni batería baja ni avería).");
            return false;
        }

        return true;
    }

    /**
     * Asigna un vehículo a mantenimiento solo si tiene batería baja (<20%).
     */
    public boolean asignarMantenimientoBateriaBaja(String DNI, int idVehiculo) {
        if (DNI == null || DNI.isEmpty()) {
            System.out.println("Error: DNI inválido");
            return false;
        }
        GestorPersonas gestorPersonas = GestorPersonas.getInstancia();
        Object persona = gestorPersonas.getPersonaPorDNI(DNI);
        if (!(persona instanceof Mantenimiento)) {
            System.out.println("Error: El DNI no corresponde a un trabajador de mantenimiento.");
            return false;
        }
        Mantenimiento mantenimiento = (Mantenimiento) persona;

        Vehiculo vehiculo = getVehiculoPorID(idVehiculo);
        if (vehiculo == null) {
            System.out.println("Error: Vehículo no encontrado.");
            return false;
        }

        if (vehiculo.getBateria() < 20) {
            vehiculo.setEnUso(false);
            vehiculo.setReservado(true);
            if (!mantenimiento.getVehiculosSinBateria().contains(vehiculo)) {
                mantenimiento.getVehiculosSinBateria().add(vehiculo);
            }
            System.out.println("Vehículo ID " + vehiculo.getID() + " asignado a mantenimiento por batería baja.");
            return true;
        } else {
            System.out.println("El vehículo no tiene batería baja.");
            return false;
        }
    }

    public boolean asignarMantenimientoYMecanicoAveria(String DNIMantenimiento, String DNIMecanico, int idVehiculo) {
        if (DNIMantenimiento == null || DNIMantenimiento.isEmpty() || DNIMecanico == null || DNIMecanico.isEmpty()) {
            System.out.println("Error: DNI inválido");
            return false;
        }
        GestorPersonas gestorPersonas = GestorPersonas.getInstancia();
        Object personaMantenimiento = gestorPersonas.getPersonaPorDNI(DNIMantenimiento);
        Object personaMecanico = gestorPersonas.getPersonaPorDNI(DNIMecanico);

        if (!(personaMantenimiento instanceof Mantenimiento)) {
            System.out.println("Error: El DNI no corresponde a un trabajador de mantenimiento.");
            return false;
        }
        if (!(personaMecanico instanceof Mecanico)) {
            System.out.println("Error: El DNI no corresponde a un mecánico.");
            return false;
        }
        Mantenimiento mantenimiento = (Mantenimiento) personaMantenimiento;
        Mecanico mecanico = (Mecanico) personaMecanico;

        Vehiculo vehiculo = getVehiculoPorID(idVehiculo);
        if (vehiculo == null) {
            System.out.println("Error: Vehículo no encontrado.");
            return false;
        }

        if (vehiculo.getAverias()) {
            vehiculo.setEnUso(false);
            vehiculo.setReservado(true);
            if (!mantenimiento.getVehiculosAveriados().contains(vehiculo)) {
                mantenimiento.getVehiculosAveriados().add(vehiculo);
            }
            if (!mecanico.getVehiculosAveriados().contains(vehiculo)) {
                mecanico.getVehiculosAveriados().add(vehiculo);
            }
            System.out.println("Vehículo ID " + vehiculo.getID() + " asignado a mantenimiento y mecánico por avería.");
            return true;
        } else {
            System.out.println("El vehículo no tiene avería.");
            return false;
        }
    }
    
    // Asignar mecánico a avería en base
    public boolean asignarMecanicoAveriaBase(String DNIMecanico, String nombreBase) {
        if (DNIMecanico == null || DNIMecanico.isEmpty() || nombreBase == null || nombreBase.isEmpty()) {
            System.out.println("Error: DNI o nombre de base inválido");
            return false;
        }
        GestorPersonas gestorPersonas = GestorPersonas.getInstancia();
        Object personaMecanico = gestorPersonas.getPersonaPorDNI(DNIMecanico);
        if (!(personaMecanico instanceof Mecanico)) {
            System.out.println("Error: El DNI no corresponde a un mecánico.");
            return false;
        }
        Mecanico mecanico = (Mecanico) personaMecanico;

        Base base = mapa.getBasePorNombre(nombreBase);
        if (base == null) {
            System.out.println("Error: No se encontró la base '" + nombreBase + "'");
            return false;
        }

        if (base.getAverias()) {
            if (!mecanico.getBasesAveriadas().contains(base)) {
                mecanico.addBaseAveriada(base);
                System.out.println("Base '" + nombreBase + "' averiada asignada al mecánico " + DNIMecanico);
                return true;
            } else {
                System.out.println("La base '" + nombreBase + "' ya está asignada al mecánico.");
                return false;
            }
        } else {
            System.out.println("La base '" + nombreBase + "' no está averiada.");
            return false;
        }
    }

}

package GestorViajes;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

public class Beneficios {

    //==========================
    // CONFIGURACIÓN Y ESTADO
    //==========================
    private static boolean reservasPermitidas = true;
    private static boolean bateriaPremiumPermitida = true;
    private static double bateriaMaxima = 100.0;
    private static double bateriaMinimaStandard = 20.0;
    private static double bateriaMinimaPremium = 10.0;

    //==========================
    // ESTRUCTURAS DE DATOS
    //==========================
    private Map<Integer, LocalDateTime> reservas = new HashMap<>();

    //==========================
    // CONSTRUCTOR
    //==========================
    public Beneficios() {
        // Constructor por defecto
    }

    //==========================
    // ACCESO A DATOS
    //==========================

    // Devuelve el nivel máximo de batería permitido
    public static double getBateriaMaxima() {
        // Retorna el valor máximo de batería permitido
        return bateriaMaxima;
    }

    // Devuelve el nivel mínimo de batería para usuarios estándar
    public static double getBateriaMinimaStandard() {
        // Retorna el valor mínimo de batería estándar
        return bateriaMinimaStandard;
    }

    // Devuelve el nivel mínimo de batería para usuarios premium si está permitido
    public static double getBateriaMinimaPremium() {
        // Si la batería premium está permitida, retorna ese valor; si no, retorna el estándar
        if (bateriaPremiumPermitida) {
            return bateriaMinimaPremium;
        } else {
            return bateriaMinimaStandard;
        }
    }

    // Indica si las reservas están habilitadas en el sistema
    public boolean getReservasPermitidas() {
        // Retorna el estado de las reservas permitidas
        return reservasPermitidas;
    }

    public boolean getBateriaPremiumPermitida() {
        // Retorna el estado de la batería premium permitida
        return bateriaPremiumPermitida;
    }

    //==========================
    // GESTIÓN DE BENEFICIOS
    //==========================

    // Configura si se permiten o no las reservas en todo el sistema
    public static void setReservasPermitidas(boolean permitido) {
        // Cambia el valor de reservasPermitidas y muestra un mensaje
        reservasPermitidas = permitido;
        String mensaje;
        if (permitido) {
            mensaje = "Las reservas han sido habilitadas en el sistema.";
        } else {
            mensaje = "Las reservas han sido deshabilitadas en el sistema.";
        }
        System.out.println(mensaje);
    }

    // Configura si se permite o no el uso de batería premium en el sistema
    public static void setBateriaPremiumPermitida(boolean permitido) {
        // Cambia el valor de bateriaPremiumPermitida y muestra un mensaje
        bateriaPremiumPermitida = permitido;
        String mensaje;
        if (permitido) {
            mensaje = "La batería premium ha sido habilitada en el sistema.";
        } else {
            mensaje = "La batería premium ha sido deshabilitada en el sistema.";
        }
        System.out.println(mensaje);
    }

    //==========================
    // GESTIÓN DE RESERVAS
    //==========================

    // Verifica si un vehículo está reservado y elimina la reserva si ya expiró
    public boolean estaReservado(int ID) {
        // Si no existe reserva para el ID, retorna false
        if (!reservas.containsKey(ID)) {
            return false;
        }
        // Obtiene la fecha y hora actual y la fecha de fin de la reserva
        LocalDateTime ahora = LocalDateTime.now();
        LocalDateTime finReserva = reservas.get(ID);
        // Si la reserva ya expiró, la elimina y retorna false
        if (ahora.isAfter(finReserva)) {
            reservas.remove(ID);
            return false;
        }
        // Si la reserva sigue activa, retorna true
        return true;
    }

    // Intenta reservar un vehículo por 20 minutos
    public boolean reservarVehiculo(int ID) {
        // Solo permite reservar si el vehículo no está reservado
        if (estaReservado(ID)) {
            return false;
        }
        // Asigna una nueva reserva por 20 minutos
        LocalDateTime finReserva = LocalDateTime.now().plusMinutes(20);
        reservas.put(ID, finReserva);
        return true;
    }

    // Intenta reservar un vehículo por un número específico de minutos
    public boolean reservarVehiculo(int ID, int minutos) {
        if (estaReservado(ID)) {
            return false;
        }
        LocalDateTime finReserva = LocalDateTime.now().plusMinutes(minutos);
        reservas.put(ID, finReserva);
        return true;
    }
}
package GestorViajes;

import Enum.VehiculoEnum;
import GestorPersonas.Personas.Usuario;
import GestorVehiculosBases.GestorVehiculos;
import GestorVehiculosBases.Localizaciones.Mapa;
import GestorVehiculosBases.Vehiculos.Vehiculo;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class GestorViajes {

    //==========================
    // SINGLETON Y DEPENDENCIAS
    //==========================
    private static GestorViajes instancia;
    private GestorVehiculos gestorVehiculos;
    private Mapa mapa;

    //==========================
    // ESTRUCTURAS DE DATOS
    //==========================
    private final List<Viaje> viajes;
    private final Map<Usuario, List<Viaje>> viajesPorUsuario;

    //==========================
    // CONSTRUCTOR
    //==========================
    private GestorViajes() {
        this.gestorVehiculos = GestorVehiculos.getInstancia();
        this.mapa = Mapa.getInstancia();
        this.viajesPorUsuario = new HashMap<>();
        this.viajes = new ArrayList<>();
    }

    // Devuelve la instancia singleton
    public static GestorViajes getInstancia() {
        if (instancia == null) {
            instancia = new GestorViajes();
        }
        return instancia;
    }

    //==========================
    // ACCESO A DATOS
    //==========================

    // Devuelve la lista de todos los viajes
    public List<Viaje> getListaTodosViajes() {
        return viajes;
    }

    // Devuelve el mapa de viajes por usuario
    public Map<Usuario, List<Viaje>> getMapaViajesPorUsuario() {
        return viajesPorUsuario;
    }

    // Devuelve los vehículos actualmente en uso
    public List<Vehiculo> obtenerVehiculosEnUsoActual() {
        List<Vehiculo> vehiculosEnUso = new ArrayList<>();
        for (Viaje viaje : viajes) {
            if (viaje.estaActivo()) {
                vehiculosEnUso.add(viaje.getVehiculo());
            }
        }
        return vehiculosEnUso;
    }

    // Devuelve detalles del viaje activo de un vehículo por ID
    public String mostrarDetallesViajeActual(int idVehiculo) {
        for (Viaje viaje : viajes) {
            if (viaje.getVehiculo().getID() == idVehiculo && viaje.estaActivo()) {
                return String.format("%-5d %-15s %-20s %s", 
                    viaje.getVehiculo().getID(),
                    viaje.getVehiculo().getVehiculoEnum(),
                    viaje.getUsuario().getNombre() + " " + viaje.getUsuario().getApellidos(),
                    new java.util.Date(viaje.getTiempoInicio())
                );
            }
        }
        return "No hay datos del viaje para el vehículo ID: " + idVehiculo;
    }

    //==========================
    // GESTIÓN DE VIAJES
    //==========================

    // Registra un nuevo viaje
    public boolean registrarViaje(Viaje viaje) {
        if (viaje == null) {
            System.out.println("Error: No se puede registrar un viaje nulo.");
            return false;
        }
        viajes.add(viaje);
        Usuario usuario = viaje.getUsuario();
        viajesPorUsuario.computeIfAbsent(usuario, k -> new ArrayList<>()).add(viaje);
        return true;
    }

    //==========================
    // VISUALIZACIÓN DE VIAJES
    //==========================

    // Muestra todos los viajes registrados
    public void mostrarViajes() {
        if (viajes.isEmpty()) {
            System.out.println("No hay viajes registrados.");
            return;
        }
        System.out.println("\n=== LISTADO DE VIAJES ===");
        System.out.println("Vehículo - Usuario - Inicio - Fin - Costo - Activo");
        for (Viaje viaje : viajes) {
            System.out.println(viaje.getVehiculo().getNombreVehiculo() + " - " + 
                              viaje.getUsuario() + " - " + 
                              new java.util.Date(viaje.getTiempoInicio()) + " - " + 
                              (viaje.getTiempoFin() > 0 ? new java.util.Date(viaje.getTiempoFin()) : "En curso") + " - " + 
                              String.format("%.2f", viaje.getCosto()) + "€ - " +
                              (viaje.estaActivo() ? "Activo" : "Finalizado"));
        }
    }

    //==========================
    // VISUALIZACIÓN DE TARIFAS Y DESCUENTOS
    //==========================

    // Muestra las tarifas actuales por tipo de vehículo
    public void mostrarTarifasActuales() {
        System.out.println("\n=== TARIFAS ACTUALES ===");
        for (VehiculoEnum tipo : VehiculoEnum.values()) {
            double tarifa = tipo.getTarifa();
            System.out.printf("%s: %.2f€ por hora\n", tipo, tarifa);
        }
    }

    // Muestra los descuentos actuales por tipo de vehículo
    public void mostrarDescuentosActuales() {
        System.out.println("\n=== DESCUENTOS ACTUALES ===");
        for (VehiculoEnum tipo : VehiculoEnum.values()) {
            double descuento = tipo.getDescuento();
            System.out.printf("%s: %.1f%%\n", tipo, descuento);
        }
    }

    //==========================
    // VISUALIZACIÓN DE RESERVAS
    //==========================

    // Muestra el estado actual de las reservas
    public void mostrarEstadoReservas() {
        System.out.println("\n=== ESTADO DE RESERVAS ===");
        Beneficios beneficios = new Beneficios();
        String estado;
        if (beneficios.getReservasPermitidas()) {
            estado = "HABILITADAS";
        } else {
            estado = "DESHABILITADAS";
        }
        System.out.println("Las reservas están actualmente: " + estado);
    }
}

package GestorViajes;

/**
 * Clase que gestiona las diferentes penalizaciones aplicables a los viajes.
 */
public class Penalizaciones {

    //==========================
    // VALORES DE PENALIZACIONES
    //==========================
    private static double penalizacionBateriaAgotada = 1.0; // Valor inicial en euros

    //==========================
    // OBTENER PENALIZACIÓN POR BATERÍA AGOTADA
    //==========================
    public static double obtenerPenalizacionPorBateriaAgotada() {
        // Devuelve el valor actual de la penalización por batería agotada
        return penalizacionBateriaAgotada;
    }

    //==========================
    // DEFINIR PENALIZACIÓN POR BATERÍA AGOTADA
    //==========================
    public static boolean definirPenalizacionPorBateríaAgotada(double valor) {
        // Verifica que el valor no sea negativo
        if (valor < 0) {
            System.out.println("Error: La penalización no puede ser negativa.");
            return false;
        }
        // Actualiza el valor de la penalización
        penalizacionBateriaAgotada = valor;
        System.out.println("Penalización por batería agotada actualizada: " + valor + "€");
        return true;
    }
}
package GestorViajes;

import Enum.RolEnum;
import Enum.VehiculoEnum;
import GestorPersonas.Personas.Usuario;
import GestorVehiculosBases.GestorVehiculos;
import GestorVehiculosBases.Localizaciones.Base;
import GestorVehiculosBases.Localizaciones.Mapa;
import GestorVehiculosBases.Vehiculos.Vehiculo;
import GestorVehiculosBases.Vehiculos.VehiculoDeBase;
import GestorVehiculosBases.Vehiculos.VehiculoDeCoordenadas;
import java.util.Date;

public class ServicioViajes {

    //==========================
    // SINGLETON Y DEPENDENCIAS
    //==========================
    private static ServicioViajes instancia;
    private GestorViajes gestorViajes;
    private GestorVehiculos gestorVehiculos;

    //==========================
    // CONSTRUCTOR
    //==========================
    private ServicioViajes() {
        this.gestorViajes = GestorViajes.getInstancia();
        this.gestorVehiculos = GestorVehiculos.getInstancia();
    }

    // Devuelve la instancia singleton
    public static ServicioViajes getInstancia() {
        if (instancia == null) {
            instancia = new ServicioViajes();
        }
        return instancia;
    }

    //==========================
    // INICIO DE VIAJES
    //==========================

    // Inicia viaje con bicicleta o patinete desde una base
    public Viaje iniciarViaje(Usuario usuario, VehiculoEnum vehiculoEnum, String nombreBase) {
        // Verificación de argumentos nulos
        if (usuario == null) {
            System.out.println("Error: El usuario no puede ser nulo.");
            return null;
        }
        if (vehiculoEnum == null) {
            System.out.println("Error: El tipo de vehículo no puede ser nulo.");
            return null;
        }
        if (nombreBase == null || nombreBase.trim().isEmpty()) {
            System.out.println("Error: El nombre de la base no puede ser nulo o vacío.");
            return null;
        }

        // Verificación de saldo
        if (usuario.getSaldo() <= 0) {
            System.out.println("Error: El usuario no tiene saldo positivo.");
            return null;
        }

        // Verificación de tipo de vehículo permitido
        if (vehiculoEnum != VehiculoEnum.BICICLETA && vehiculoEnum != VehiculoEnum.PATINETE) {
            System.out.println("Error: Solo se pueden iniciar viajes de bicicleta o patinete desde una base.");
            return null;
        }

        // Verificación de existencia de la base
        Mapa mapa = Mapa.getInstancia();
        Base base = mapa.getBasePorNombre(nombreBase);
        if (base == null) {
            System.out.println("Error: La base especificada no existe.");
            return null;
        }

        // Verificación de disponibilidad de vehículo
        boolean disponible = false;
        if (vehiculoEnum == VehiculoEnum.BICICLETA) {
            disponible = base.getBicicletasDisponibles(usuario) > 0;
        } else if (vehiculoEnum == VehiculoEnum.PATINETE) {
            disponible = base.getPatinetesDisponibles(usuario) > 0;
        }
        if (!disponible) {
            System.out.println("Error: No hay vehículos disponibles de tipo " + vehiculoEnum + " en la base.");
            return null;
        }

        // Obtener vehículo activo
        Vehiculo vehiculo = base.getVehiculoActivoPorTipo(vehiculoEnum, usuario);
        if (vehiculo == null) {
            System.out.println("Error: No se pudo obtener un vehículo disponible.");
            return null;
        }

        // Registrar viaje
        Viaje nuevoViaje = new Viaje(vehiculo, usuario, base);
        vehiculo.setEnUso(true);
        usuario.registrarViaje(nuevoViaje);
        gestorViajes.registrarViaje(nuevoViaje);
        gestorVehiculos.removeVehiculoBasePorID(vehiculo.getID());
        base.incrementarViajesIniciadosBase();
        ((VehiculoDeBase) vehiculo).setBase(null);

        System.out.println("Vehículo alquilado con éxito. ¡Buen viaje!");
        return nuevoViaje;
    }

    // Inicia viaje con moto en coordenadas específicas
    public Viaje iniciarViajeMoto(Usuario usuario, VehiculoEnum vehiculoEnum, int coordenadaX, int coordenadaY) {
        // Verificación de argumentos nulos
        if (usuario == null) {
            System.out.println("Error: El usuario no puede ser nulo.");
            return null;
        }
        if (vehiculoEnum == null) {
            System.out.println("Error: El tipo de vehículo no puede ser nulo.");
            return null;
        }

        // Verificación de saldo
        if (usuario.getSaldo() <= 0) {
            System.out.println("Error: El usuario no tiene saldo positivo.");
            return null;
        }

        // Verificación de tipo de vehículo permitido
        if (vehiculoEnum != VehiculoEnum.MOTOPEQUENA && vehiculoEnum != VehiculoEnum.MOTOGRANDE) {
            System.out.println("Error: Solo se pueden iniciar viajes de motos con este método.");
            return null;
        }

        // Verificación de coordenadas válidas
        Mapa mapa = Mapa.getInstancia();
        if (!mapa.sonCoordenadasValidas(coordenadaX, coordenadaY)) {
            System.out.println("Error: Las coordenadas están fuera de los límites del mapa.");
            return null;
        }

        // Verificación de existencia de vehículo en la celda
        Object contenidoCelda = mapa.getContenidoCelda(coordenadaX, coordenadaY);
        if (!(contenidoCelda instanceof Vehiculo)) {
            System.out.println("Error: No hay un vehículo en esa posición.");
            return null;
        }
        Vehiculo vehiculo = (Vehiculo) contenidoCelda;

        // Verificación de tipo de vehículo en la celda
        if (vehiculo.getVehiculoEnum() != vehiculoEnum) {
            System.out.println("Error: El vehículo en esa posición no es del tipo solicitado.");
            return null;
        }

        // Verificación de estado del vehículo
        if (!vehiculo.getDisponible(usuario)) {
            System.out.println("Error: El vehículo no está disponible (en uso o averiado).");
            return null;
        }

        // Registrar viaje
        Viaje nuevoViaje = new Viaje(vehiculo, usuario, coordenadaX, coordenadaY);
        vehiculo.setEnUso(true);
        usuario.registrarViaje(nuevoViaje);
        gestorViajes.registrarViaje(nuevoViaje);
        gestorVehiculos.removeVehiculoMapaPorCoordenadas(coordenadaX, coordenadaY);
        ((VehiculoDeCoordenadas) vehiculo).setCoordenadaX(-1);
        ((VehiculoDeCoordenadas) vehiculo).setCoordenadaY(-1);

        System.out.println("Moto alquilada con éxito. ¡Buen viaje!");
        return nuevoViaje;
    }

    //==========================
    // FINALIZACIÓN DE VIAJES
    //==========================

    // Finaliza viaje de bicicleta o patinete en una base
    public boolean finalizarViajeBase(Usuario usuario, Viaje viaje, String nombreBase) {
        // Validaciones de argumentos
        if (!validarFinalizacionViaje(usuario, viaje)) {
            return false;
        }
        if (nombreBase == null || nombreBase.trim().isEmpty()) {
            System.out.println("Error: El nombre de la base no puede ser nulo o vacío.");
            return false;
        }

        Mapa mapa = Mapa.getInstancia();
        Base base = mapa.getBasePorNombre(nombreBase);
        if (base == null) {
            System.out.println("Error: La base especificada no existe.");
            return false;
        }

        Vehiculo vehiculo = viaje.getVehiculo();
        VehiculoEnum tipoVehiculo = vehiculo.getVehiculoEnum();
        if (tipoVehiculo != VehiculoEnum.PATINETE && tipoVehiculo != VehiculoEnum.BICICLETA) {
            System.out.println("Error: Este método solo es válido para finalizar viajes de patinete o bicicleta.");
            return false;
        }
        if (base.getEspaciosLibres() <= 0) {
            System.out.println("Error: La base " + nombreBase + " está llena. Seleccione otra base.");
            return false;
        }

        // Lógica específica de base
        viaje.setBaseFin(base);

        // Lógica común
        finalizarViajeComun(viaje, usuario);

        // Actualizar base del vehículo
        ((VehiculoDeBase) vehiculo).setBase(base);
        gestorVehiculos.moverVehiculoABase(vehiculo.getID(), nombreBase);
        base.incrementarViajesFinalizadosBase();

        // Mostrar resumen
        System.out.println("\n=== VIAJE FINALIZADO ===");
        mostrarResumenViajeFinalizado(viaje);
        System.out.println("Saldo disponible: " + String.format("%.2f", usuario.getSaldo()) + "€");
        System.out.println("Vehículo estacionado correctamente en la base " + nombreBase);

        return true;
    }

    // Finaliza viaje de moto en coordenadas específicas
    public boolean finalizarViajeCoordenadas(Usuario usuario, Viaje viaje, int coordX, int coordY) {
        // Validaciones de argumentos
        if (!validarFinalizacionViaje(usuario, viaje)) {
            return false;
        }

        Mapa mapa = Mapa.getInstancia();
        if (!mapa.sonCoordenadasValidas(coordX, coordY)) {
            System.out.println("Error: Las coordenadas especificadas están fuera de los límites del mapa.");
            return false;
        }
        if (mapa.sonCoordenadasOcupadas(coordX, coordY)) {
            System.out.println("Error: La posición especificada ya está ocupada.");
            return false;
        }

        // Lógica específica de coordenadas
        viaje.setCoordenadaFin(coordX, coordY);

        // Lógica común
        finalizarViajeComun(viaje, usuario);

        // Actualizar coordenadas del vehículo
        VehiculoDeCoordenadas vehiculoDeCoordenadas = (VehiculoDeCoordenadas) viaje.getVehiculo();
        vehiculoDeCoordenadas.setCoordenadaX(coordX);
        vehiculoDeCoordenadas.setCoordenadaY(coordY);
        gestorVehiculos.moverVehiculoACoordenadas(vehiculoDeCoordenadas.getID(), coordX, coordY);

        // Mostrar resumen
        System.out.println("\n=== VIAJE FINALIZADO ===");
        mostrarResumenViajeFinalizado(viaje);
        System.out.println("Saldo disponible: " + String.format("%.2f", usuario.getSaldo()) + "€");
        System.out.println("La " + vehiculoDeCoordenadas.getNombreVehiculo() + " ha sido estacionada correctamente en las coordenadas (" + coordX + ", " + coordY + ")");

        return true;
    }

    // Método privado para validaciones comunes de finalización de viaje
    private boolean validarFinalizacionViaje(Usuario usuario, Viaje viaje) {
        if (viaje == null) {
            System.out.println("Error: El viaje no existe.");
            return false;
        }
        if (usuario == null) {
            System.out.println("Error: El usuario no puede ser nulo.");
            return false;
        }
        if (!viaje.estaActivo()) {
            System.out.println("Error: El viaje ya ha sido finalizado.");
            return false;
        }
        Vehiculo vehiculo = viaje.getVehiculo();
        if (vehiculo == null) {
            System.out.println("Error: El vehículo del viaje no existe.");
            return false;
        }
        return true;
    }

    // Finaliza viaje y actualiza datos comunes (tiempo, costo, estado)
    private void finalizarViajeComun(Viaje viaje, Usuario usuario) {
        // Actualizar tiempo y estado
        viaje.setTiempoFin(System.currentTimeMillis());
        viaje.setActivo(false);

        // Actualizar batería del vehículo
        viaje.actualizarBateriaVehiculo();

        // Calcular y descontar costo
        double costo = calcularCosto(viaje);

        // Aplicar penalización si la batería está agotada
        if (viaje.getVehiculo().getBateria() <= 0) {
            double penalizacion = Penalizaciones.obtenerPenalizacionPorBateriaAgotada();
            costo += penalizacion;
            System.out.println("Penalización aplicada por batería agotada: " + penalizacion + "€");
        }

        usuario.descontarCosto(costo);
        viaje.setCosto(costo);

        // Marcar vehículo como no en uso
        viaje.getVehiculo().setEnUso(false);
    }
    
    //==========================
    // CÁLCULOS Y UTILIDADES
    //==========================

    // Calcula el costo de un viaje finalizado
    private double calcularCosto(Viaje viaje) {
        // Obtención de datos relevantes
        Vehiculo vehiculo = viaje.getVehiculo();
        Usuario usuario = viaje.getUsuario();
        double duracionHoras = (double)(viaje.getTiempoFin() - viaje.getTiempoInicio()) / 3600000.0;
        double tarifaBase = vehiculo.getVehiculoEnum().getTarifa();
        double costoBase = duracionHoras * tarifaBase;

        // Aplicar descuento si es usuario premium
        if (usuario.getRol() == RolEnum.USUARIO_PREMIUM) {
            double descuento = vehiculo.getVehiculoEnum().getDescuento();
            return costoBase * (1 - descuento / 100.0);
        }
        return costoBase;
    }

    //==========================
    // CONSULTAS Y RESÚMENES
    //==========================
    // Muestra información de un viaje activo
    public boolean mostrarViajeActivo(Viaje viaje) {
        // Validación de existencia y estado del viaje
        if (viaje == null) {
            System.out.println("Error: El viaje no existe.");
            return false;
        }
        if (!viaje.estaActivo()) {
            System.out.println("Error: El viaje ya ha sido finalizado. Use obtenerResumenViaje() para viajes completados.");
            return false;
        }

        // Cálculo de tiempo transcurrido
        long tiempoActual = System.currentTimeMillis();
        double duracionHoras = (double)(tiempoActual - viaje.getTiempoInicio()) / 3600000.0;
        double duracionMinutos = duracionHoras * 60;

        // Obtención de datos relevantes
        Vehiculo vehiculo = viaje.getVehiculo();
        Usuario usuario = viaje.getUsuario();
        double tarifaBase = vehiculo.getVehiculoEnum().getTarifa();

        // Cálculo del costo estimado (con descuento si es premium)
        double costoEstimado = (duracionMinutos / 60.0) * tarifaBase;
        if (usuario instanceof GestorPersonas.Personas.Premium) {
            double descuento = vehiculo.getVehiculoEnum().getDescuento();
            costoEstimado *= (1 - descuento / 100.0);
        }

        // Impresión de información del viaje activo
        System.out.println("=== VIAJE ACTIVO ===");
        System.out.println("Vehículo: " + vehiculo.getNombreVehiculo());
        System.out.println("Usuario: " + usuario.getNombre());
        System.out.println("Inicio: " + new java.util.Date(viaje.getTiempoInicio()));
        System.out.println("Tiempo transcurrido: " + String.format("%.2f", duracionHoras) +
                " horas (" + String.format("%.1f", duracionMinutos) + " minutos)");
        System.out.println("Costo actual estimado: " + String.format("%.2f", costoEstimado) + "€");
        System.out.println("Saldo disponible: " + String.format("%.2f", usuario.getSaldo()) + "€");
        return true;
    }

    // Muestra resumen detallado de un viaje finalizado
    public static void mostrarResumenViajeFinalizado(Viaje viaje) {
        // Validación de existencia del viaje
        if (viaje == null) {
            System.out.println("Error: El viaje no existe.");
            return;
        }

        // Obtención de datos relevantes
        Vehiculo vehiculo = viaje.getVehiculo();
        Usuario usuario = viaje.getUsuario();
        VehiculoEnum tipoVehiculo = vehiculo.getVehiculoEnum();
        double duracionHoras = (double)(viaje.getTiempoFin() - viaje.getTiempoInicio()) / 3600000.0;
        double duracionMinutos = duracionHoras * 60;

        // Calcular batería consumida
        double consumoPorMinuto = vehiculo.getVehiculoEnum().getRitmoConsumo();
        double bateriaConsumida = duracionMinutos * consumoPorMinuto;
        double bateriaFinal = vehiculo.getBateria();

        // Impresión de datos generales
        System.out.println("Vehículo ID: " + vehiculo.getID());
        System.out.println("Vehículo: " + vehiculo.getNombreVehiculo());
        System.out.println("Usuario: " + usuario.getNombre() + " " + usuario.getApellidos());
        System.out.println("Inicio: " + new Date(viaje.getTiempoInicio()));
        System.out.println("Fin: " + new Date(viaje.getTiempoFin()));
        System.out.println("Duración: " + String.format("%.1f", duracionHoras) + " horas (" +
                String.format("%.1f", duracionMinutos) + " minutos)");

        // Información específica según tipo de vehículo
        if (tipoVehiculo == VehiculoEnum.MOTOPEQUENA || tipoVehiculo == VehiculoEnum.MOTOGRANDE) {
            int xInicio = viaje.getCoordenadaXInicio();
            int yInicio = viaje.getCoordenadaYInicio();
            int xFin = viaje.getCoordenadaXFin();
            int yFin = viaje.getCoordenadaYFin();
            System.out.println("Coordenada Inicio: (" + xInicio + ", " + yInicio + ")");
            if (viaje.estaActivo()) {
                System.out.println("El viaje está en curso.");
            } else {
                System.out.println("Coordenada Fin: (" + xFin + ", " + yFin + ")");
            }
        } else if (tipoVehiculo == VehiculoEnum.BICICLETA || tipoVehiculo == VehiculoEnum.PATINETE) {
            Base baseInicio = viaje.getBaseInicio();
            Base baseFin = viaje.getBaseFin();
            if (baseInicio != null) {
                System.out.println("Base Inicio: " + baseInicio.getNombre() +
                        " (Coordenadas: " + baseInicio.getCoordenadaX() + ", " +
                        baseInicio.getCoordenadaY() + ")");
            }
            if (viaje.estaActivo()) {
                System.out.println("El viaje está en curso.");
            } else if (baseFin != null) {
                System.out.println("Base Fin: " + baseFin.getNombre() +
                        " (Coordenadas: " + baseFin.getCoordenadaX() + ", " +
                        baseFin.getCoordenadaY() + ")");
            }
        }

        // Impresión del costo final y descuento si aplica
        System.out.print("Costo final: " + String.format("%.2f", viaje.getCosto()) + "€");
        if (usuario.getRol() == RolEnum.USUARIO_PREMIUM) {
            double descuento = vehiculo.getVehiculoEnum().getDescuento();
            System.out.print(" (Incluye descuento premium del " + String.format("%.0f", descuento) + "%)");
        }
        System.out.println();

        // Mostrar batería consumida y batería final
        System.out.println("Batería consumida en el viaje: " + String.format("%.2f", bateriaConsumida) + "%");
        System.out.println("Batería restante del vehículo: " + String.format("%.2f", bateriaFinal) + "%");
    }
}
package GestorViajes;

import Enum.VehiculoEnum;

public class TarifasYDescuentos {

    //==========================
    // GESTIÓN DE TARIFAS Y DESCUENTOS
    //==========================

    // Modifica la tarifa de un tipo de vehículo
    public boolean modificarTarifa(VehiculoEnum tipoVehiculo, double nuevaTarifa) {
        // Validación de tipo de vehículo
        if (tipoVehiculo == null) {
            System.out.println("Error: Tipo de vehículo no válido.");
            return false;
        }
        // Validación de tarifa
        if (nuevaTarifa < 0) {
            System.out.println("Error: La tarifa no puede ser negativa.");
            return false;
        }
        try {
            // Actualiza la tarifa en el enum
            tipoVehiculo.setTarifa(nuevaTarifa);
            System.out.println("Tarifa para " + tipoVehiculo + " actualizada correctamente a " + nuevaTarifa + "€ por hora.");
            // Muestra las tarifas actualizadas
            mostrarTarifasActuales();
            return true;
        } catch (Exception e) {
            System.out.println("Error al actualizar la tarifa: " + e.getMessage());
            return false;
        }
    }

    // Modifica el descuento de un tipo de vehículo
    public boolean modificarDescuento(VehiculoEnum tipoVehiculo, double nuevoDescuento) {
        // Validación de tipo de vehículo
        if (tipoVehiculo == null) {
            System.out.println("Error: Tipo de vehículo no válido.");
            return false;
        }
        // Validación de descuento
        if (nuevoDescuento < 0 || nuevoDescuento > 100) {
            System.out.println("Error: El descuento debe estar entre 0 y 100 por ciento.");
            return false;
        }
        try {
            // Actualiza el descuento en el enum
            tipoVehiculo.setDescuento(nuevoDescuento);
            System.out.println("Descuento para " + tipoVehiculo + " actualizado correctamente al " + nuevoDescuento + "%.");
            // Muestra los descuentos actualizados
            mostrarDescuentosActuales();
            return true;
        } catch (Exception e) {
            System.out.println("Error al actualizar el descuento: " + e.getMessage());
            return false;
        }
    }

    //==========================
    // VISUALIZACIÓN
    //==========================

    // Muestra las tarifas actuales de todos los tipos de vehículos
    public void mostrarTarifasActuales() {
        System.out.println("\n=== TARIFAS ACTUALES ===");
        for (VehiculoEnum tipo : VehiculoEnum.values()) {
            double tarifa = tipo.getTarifa();
            System.out.printf("%s: %.2f€ por hora\n", tipo, tarifa);
        }
    }

    // Muestra los descuentos actuales de todos los tipos de vehículos
    public void mostrarDescuentosActuales() {
        System.out.println("\n=== DESCUENTOS ACTUALES ===");
        for (VehiculoEnum tipo : VehiculoEnum.values()) {
            double descuento = tipo.getDescuento();
            System.out.printf("%s: %.1f%%\n", tipo, descuento);
        }
    }
}
package GestorViajes;

import Enum.VehiculoEnum;
import GestorPersonas.Personas.Usuario;
import GestorVehiculosBases.Localizaciones.Base;
import GestorVehiculosBases.Vehiculos.Vehiculo;
import java.time.LocalDateTime;
import java.time.ZoneId;

public class Viaje {

    //==========================
    // ATRIBUTOS PRINCIPALES
    //==========================
    private Vehiculo vehiculo;
    private Usuario usuario;
    private long tiempoInicio;
    private long tiempoFin;
    private double costo;
    private boolean activo;

    //==========================
    // ATRIBUTOS DE LOCALIZACIÓN
    //==========================
    private int coordenadaXInicio;
    private int coordenadaYInicio;
    private int coordenadaXFin;
    private int coordenadaYFin;
    private Base baseInicio;
    private Base baseFin;

    //==========================
    // DEPENDENCIAS INTERNAS
    //==========================
    private GestorViajes gestorViajes;

     //==========================
    // CONSTRUCTORES
    //==========================
    // Viaje en tiempo real con coordenadas (motos)
    public Viaje(Vehiculo vehiculo, Usuario usuario, int coordX, int coordY) {
        this.vehiculo = vehiculo;
        this.usuario = usuario;
        this.costo = 0;
        this.activo = true;
        this.tiempoInicio = System.currentTimeMillis();
        if (vehiculo.getVehiculoEnum() == VehiculoEnum.MOTOPEQUENA ||
            vehiculo.getVehiculoEnum() == VehiculoEnum.MOTOGRANDE) {
            this.coordenadaXInicio = coordX;
            this.coordenadaYInicio = coordY;
        }
    }
    // Viaje en tiempo real con base (bicicletas/patinetes)
    public Viaje(Vehiculo vehiculo, Usuario usuario, Base base) {
        this.vehiculo = vehiculo;
        this.usuario = usuario;
        this.costo = 0;
        this.activo = true;
        this.tiempoInicio = System.currentTimeMillis();
        if (vehiculo.getVehiculoEnum() == VehiculoEnum.BICICLETA ||
            vehiculo.getVehiculoEnum() == VehiculoEnum.PATINETE) {
            this.baseInicio = base;
        }
    }

    //==========================
    // MÉTODOS DE CÁLCULO
    //==========================
    // Calcula la duración en horas
    public double calcularDuracion() {
        if (tiempoFin == 0) {
            System.out.println("Error: El viaje aún está activo. No se puede calcular la duración.");
            return -1;
        }
        return (double) (tiempoFin - tiempoInicio) / 3600000.0;
    }
    
    // Calcula el costo del viaje
    public double calcularCosto(Usuario usuario) {
        // Si el viaje está activo, no se puede calcular el costo
        if (activo) {
            System.out.println("Error: El viaje aún está activo. No se puede calcular el costo.");
            return -1;
        }

        // Calcula la duración en horas
        double duracionHoras = calcularDuracion();
        if (duracionHoras < 0) return -1;

        // Calcula el costo base según la tarifa del vehículo
        VehiculoEnum tipoVehiculo = vehiculo.getVehiculoEnum();
        double tarifaBase = tipoVehiculo.getTarifa();
        double costoBase = duracionHoras * tarifaBase;

        // Aplica descuento si el usuario es Premium
        if (usuario instanceof GestorPersonas.Personas.Premium) {
            double porcentajeDescuento = tipoVehiculo.getDescuento();
            double descuento = costoBase * (porcentajeDescuento / 100.0);
            double costoConDescuento = costoBase - descuento;
            System.out.println("Se aplicó un descuento del " + porcentajeDescuento +
                               "% por ser usuario Premium. Ahorro: " + String.format("%.2f", descuento) + "€");
            return costoConDescuento;
        }

        // Retorna el costo base si no hay descuento
        return costoBase;
    }

    // Calcula y descuenta el consumo de batería al vehículo según la duración del viaje
    public void actualizarBateriaVehiculo() {
        double duracionMinutos = ((double) (tiempoFin - tiempoInicio)) / 60000.0;
        double consumoPorMinuto = vehiculo.getVehiculoEnum().getRitmoConsumo();
        double consumoTotal = duracionMinutos * consumoPorMinuto;
        double bateriaActual = vehiculo.getBateria();
        double nuevaBateria = bateriaActual - consumoTotal;
        if (nuevaBateria < 0) nuevaBateria = 0;
        vehiculo.setBateria(nuevaBateria);
    }

    //==========================
    // GETTERS
    //==========================
    // Devuelve el vehículo asociado
    public Vehiculo getVehiculo() {
        return vehiculo;
    }
    // Devuelve el usuario asociado
    public Usuario getUsuario() {
        return usuario;
    }
    // Devuelve el tiempo de inicio
    public long getTiempoInicio() {
        return tiempoInicio;
    }
    // Devuelve el tiempo de fin
    public long getTiempoFin() {
        return tiempoFin;
    }
    // Devuelve el costo
    public double getCosto() {
        return costo;
    }
    // Devuelve la coordenada X de inicio
    public int getCoordenadaXInicio() {
        return coordenadaXInicio;
    }
    // Devuelve la coordenada Y de inicio
    public int getCoordenadaYInicio() {
        return coordenadaYInicio;
    }
    // Devuelve la coordenada X de fin
    public int getCoordenadaXFin() {
        return coordenadaXFin;
    }
    // Devuelve la coordenada Y de fin
    public int getCoordenadaYFin() {
        return coordenadaYFin;
    }
    // Devuelve la base de inicio
    public Base getBaseInicio() {
        return baseInicio;
    }
    // Devuelve la base de fin
    public Base getBaseFin() {
        return baseFin;
    }
    // Indica si el viaje está activo
    public boolean estaActivo() {
        return activo;
    }

    //==========================
    // SETTERS
    //==========================
    // Cambia el estado del viaje
    public void setActivo(boolean activo) {
        this.activo = activo;
    }
    // Establece el tiempo de fin
    public void setTiempoFin(long tiempoFin) {
        this.tiempoFin = tiempoFin;
    }
    // Establece el costo
    public void setCosto(double costo) {
        this.costo = costo;
    }
    // Establece coordenadas finales (motos)
    public void setCoordenadaFin(int x, int y) {
        this.coordenadaXFin = x;
        this.coordenadaYFin = y;
    }
    // Establece base final (bicicletas/patinetes)
    public void setBaseFin(Base base) {
        this.baseFin = base;
    }
  
    //============================
    // CONSTRUCTORES PARA PRUEBAS
    //============================
     // Constructor para pruebas: crea un viaje de moto con fechas y coordenadas.
     // Si fechaFin es null, el viaje queda activo.
    public Viaje(Vehiculo vehiculo, Usuario usuario,
                 LocalDateTime fechaInicio, LocalDateTime fechaFin,
                 int xInicio, int yInicio, int xFin, int yFin) {
        this.vehiculo = vehiculo;
        this.usuario = usuario;
        // Convierte la fecha de inicio a milisegundos
        this.tiempoInicio = fechaInicio.atZone(ZoneId.systemDefault()).toInstant().toEpochMilli();

        VehiculoEnum tipoVehiculo = vehiculo.getVehiculoEnum();
        // Solo asigna coordenadas si es moto
        if (tipoVehiculo == VehiculoEnum.MOTOPEQUENA || tipoVehiculo == VehiculoEnum.MOTOGRANDE) {
            this.coordenadaXInicio = xInicio;
            this.coordenadaYInicio = yInicio;
            if (fechaFin != null) {
                this.coordenadaXFin = xFin;
                this.coordenadaYFin = yFin;
            }
        }

        if (fechaFin != null) {
            // Si hay fecha de fin, el viaje está terminado
            this.tiempoFin = fechaFin.atZone(ZoneId.systemDefault()).toInstant().toEpochMilli();
            this.activo = false;
            this.costo = this.calcularCosto(usuario);
        } else {
            // Si no hay fecha de fin, el viaje está activo
            this.tiempoFin = 0;
            this.activo = true;
            this.costo = 0;
        }
        // Registra el viaje en el usuario
        usuario.registrarViaje(this);
    }

    // Constructor para pruebas: crea un viaje de bicicleta o patinete con fechas y bases.
    // Si fechaFin es null, el viaje queda activo.
    public Viaje(Vehiculo vehiculo, Usuario usuario,
                 LocalDateTime fechaInicio, LocalDateTime fechaFin,
                 Base baseInicio, Base baseFin) {
        this.vehiculo = vehiculo;
        this.usuario = usuario;
        // Convierte la fecha de inicio a milisegundos
        this.tiempoInicio = fechaInicio.atZone(ZoneId.systemDefault()).toInstant().toEpochMilli();

        VehiculoEnum tipoVehiculo = vehiculo.getVehiculoEnum();
        // Solo asigna bases si es bicicleta o patinete
        if (tipoVehiculo == VehiculoEnum.BICICLETA || tipoVehiculo == VehiculoEnum.PATINETE) {
            this.baseInicio = baseInicio;
            if (fechaFin != null) {
                this.baseFin = baseFin;
            }
        }

        if (fechaFin != null) {
            // Si hay fecha de fin, el viaje está terminado
            this.tiempoFin = fechaFin.atZone(ZoneId.systemDefault()).toInstant().toEpochMilli();
            this.activo = false;
            this.costo = this.calcularCosto(usuario);
        } else {
            // Si no hay fecha de fin, el viaje está activo
            this.tiempoFin = 0;
            this.activo = true;
            this.costo = 0;
        }
        // Registra el viaje en el usuario
        usuario.registrarViaje(this);
    }
}

package Menus.MenuAdmin;

import GestorPersonas.GestorPersonas;
import GestorPersonas.Personas.Administrador;
import GestorVehiculosBases.GestorVehiculos;
import GestorVehiculosBases.Localizaciones.Mapa;
import GestorViajes.GestorViajes;
import Utilidades.UtilidadesEntradaDatos;

public class MenuAdministrador {

    //=================================================
    // ATRIBUTOS
    //=================================================
    private GestorPersonas gestorPersonas;
    private GestorVehiculos gestorVehiculos ;
    private GestorViajes gestorViajes;
    private Mapa mapa;
    private Administrador administrador;

    //=================================================
    // CONSTRUCTOR
    //=================================================
    public MenuAdministrador() {
        this.gestorPersonas = GestorPersonas.getInstancia();
        this.gestorVehiculos = GestorVehiculos.getInstancia();
        this.gestorViajes = GestorViajes.getInstancia();
        this.mapa = Mapa.getInstancia();
    }

    //=================================================
    // MENÚ PRINCIPAL
    //=================================================
    /**
     * Muestra el menú principal del administrador y gestiona la navegación entre opciones.
     */
    public void mostrarMenu(Administrador administrador) {
        this.administrador = administrador;
        while (true) {
            System.out.println("\n========== MENÚ ADMINISTRADOR ==========");
            System.out.println("Bienvenido al sistema de movilidad. Selecciona una opción:");            
            System.out.println("\n1. Gestión de Personas");
            System.out.println("2. Gestión de Vehículos");
            System.out.println("3. Gestión de Bases");
            System.out.println("4. Gestión de Viajes y Tarifas");
            System.out.println("5. Gestión de Empleados");
            System.out.println("6. Consultas y Visualización");
            System.out.println("7. Cerrar Sesión");

            System.out.print("\nSeleccione opción: ");
            int opcion = UtilidadesEntradaDatos.getEnteroPositivo("Opción: ", 1, 7);
            
            switch (opcion) {
                case 1 -> menuGestionPersonas();
                case 2 -> menuGestionVehiculos();
                case 3 -> menuGestionBases();
                case 4 -> menuGestionViajesYTarifas();
                case 5 -> menuGestionEmpleados();
                case 6 -> menuConsultas();
                case 7 -> {
                    System.out.println("Cerrando sesión...");
                    return;
                }
                default -> System.out.println("Opción no válida. Por favor, selecciona una opción del menú.");
            }
        }
    }

    //=================================================
    // SUBMENÚS PRINCIPALES
    //=================================================
    
    // Muestra el submenú de gestión de personas
    private void menuGestionPersonas() {
        MenuGestionPersonas menuGestionPersonas = new MenuGestionPersonas();
        menuGestionPersonas.mostrarMenu();
    }

    // Muestra el submenú de gestión de vehículos
    private void menuGestionVehiculos() {
        MenuGestionVehiculos menuGestionVehiculos = new MenuGestionVehiculos();
        menuGestionVehiculos.mostrarMenu();
    }

    // Muestra el submenú de gestión de bases
    private void menuGestionBases() {
        MenuGestionBases menuGestionBases = new MenuGestionBases();
        menuGestionBases.mostrarMenu();
    }

    // Muestra el submenú de gestión de viajes y tarifas
    private void menuGestionViajesYTarifas() {
        MenuGestionViajesYTarifas menuGestionViajesYTarifas = new MenuGestionViajesYTarifas();
        menuGestionViajesYTarifas.mostrarMenu();
    }

    // Muestra el submenú de gestión de empleados
    private void menuGestionEmpleados() {
        MenuGestionEmpleados menuGestionEmpleados = new MenuGestionEmpleados();
        menuGestionEmpleados.mostrarMenu();
    }

    // Muestra el submenú de consultas y visualización
    private void menuConsultas() {
        MenuConsultas menuConsultas = new MenuConsultas();
        menuConsultas.mostrarMenu();
    }
}


package Menus.MenuAdmin;

import Enum.VehiculoEnum;
import GestorPersonas.GestorPersonas;
import GestorPersonas.Personas.Mantenimiento;
import GestorPersonas.Personas.Mecanico;
import GestorPersonas.Personas.Usuario;
import GestorVehiculosBases.Facturas.FacturaReparacionVehiculo;
import GestorVehiculosBases.Localizaciones.Base;
import GestorVehiculosBases.Vehiculos.Vehiculo;
import GestorViajes.Viaje;
import Utilidades.UtilidadesEntradaDatos;
import java.time.Instant;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class MenuConsultas {

    // ===========================
    // ATRIBUTOS Y CONSTRUCTOR
    // ===========================

    // Servicio para realizar las consultas
    private final ServicioConsultas servicioConsultas;

    // Constructor de la clase MenuConsultas
    public MenuConsultas() {
        this.servicioConsultas = new ServicioConsultas();
    }

    // ===========================
    // MENÚ PRINCIPAL
    // ===========================

    // Muestra el menú principal de consultas y gestiona la selección del usuario
    public void mostrarMenu() {
        while (true) {
            // Imprime las opciones del menú
            System.out.println("\n========== MENÚ CONSULTAS ==========");
            System.out.println("1. Estado de batería de vehículos");
            System.out.println("2. Vehículos con averías mecánicas");
            System.out.println("3. Estado de las bases");
            System.out.println("4. Personas registradas en el sistema");
            System.out.println("5. Utilización de vehículos por usuarios");
            System.out.println("6. Vehículos en uso actualmente");
            System.out.println("7. Vehículos en uso en un periodo de tiempo");
            System.out.println("8. Bases por demanda");
            System.out.println("9. Listado de reparaciones de vehículos por periodo");
            System.out.println("10. Ranking de intervenciones de trabajadores"); 
            System.out.println("11. Listado de vehículos por tipo y tiempo de uso"); 
            System.out.println("12. Listado de usuarios por gasto en alquileres en un periodo");
            System.out.println("13. Volver al menú anterior");
            System.out.print("\nSeleccione opción: ");
            int opcion = UtilidadesEntradaDatos.getEnteroPositivo("Opción: ", 1, 13);

            // Ejecuta la opción seleccionada
            switch (opcion) {
                case 1 -> mostrarEstadoBateriaVehiculos();
                case 2 -> mostrarVehiculosConAverias();
                case 3 -> mostrarEstadoBases();
                case 4 -> mostrarPersonasRegistradas();
                case 5 -> mostrarUtilizacionVehiculosPorUsuarios();
                case 6 -> mostrarVehiculosEnUsoActual();
                case 7 -> mostrarVehiculosEnUsoPorPeriodo();
                case 8 -> mostrarBasesPorDemanda();
                case 9 -> mostrarReparacionesVehiculosPorPeriodo();
                case 10 -> mostrarRankingIntervencionesTrabajadores();
                case 11 -> mostrarVehiculosPorTiempoUso();
                case 12 -> mostrarUsuariosPorGastoEnPeriodo();
                case 13 -> {
                    System.out.println("Volviendo al menú anterior...");
                    return;
                }
                default -> System.out.println("Opción no válida. Intente de nuevo.");
            }
        }
    }

    // ===========================
    // MÉTODOS DE CONSULTA
    // ===========================

    // Muestra el estado de batería de todos los vehículos
    public void mostrarEstadoBateriaVehiculos() {
        System.out.println("=== Estado de batería de todos los vehículos ===");
        List<Vehiculo> listaVehiculos = servicioConsultas.obtenerVehiculos();
        // Recorre todos los vehículos y muestra su batería
        for (Vehiculo vehiculo : listaVehiculos) {
            int id = vehiculo.getID();
            VehiculoEnum tipo = vehiculo.getVehiculoEnum();
            double nivelBateria = vehiculo.getBateria();
            System.out.println("ID: " + id + " | Tipo: " + tipo + " | Batería: " + String.format("%.2f", nivelBateria) + "%");
        }
    }

    // Muestra los vehículos que tienen averías mecánicas
    public void mostrarVehiculosConAverias() {
        System.out.println("=== Vehículos con averías mecánicas ===");
        List<Vehiculo> listaVehiculos = servicioConsultas.obtenerVehiculosConAverias();
        if (listaVehiculos.isEmpty()) {
            System.out.println("No hay vehículos con averías.");
            return;
        }
        // Imprime cabecera de la tabla
        System.out.printf("%-6s | %-10s%n", "ID", "Tipo");
        System.out.println("------------------------");
        // Muestra cada vehículo con avería
        for (Vehiculo vehiculo : listaVehiculos) {
            int id = vehiculo.getID();
            VehiculoEnum tipo = vehiculo.getVehiculoEnum();
            System.out.printf("%-6d | %-10s%n", id, tipo);
        }
    }

    // Muestra el estado de todas las bases
    public void mostrarEstadoBases() {
        System.out.println("=== Estado de las bases de bicicletas y patinetes ===");
        System.out.printf("%-15s | %-10s | %-10s | %-10s | %-12s | %-10s%n",
            "Base", "Capacidad", "Libres", "Bicis", "Patinetes", "Avería");
        System.out.println("--------------------------------------------------------------------------------");
        List<Base> bases = servicioConsultas.obtenerBases();
        // Recorre todas las bases y muestra su información
        for (Base base : bases) {
            int totalBicis = base.getTotalBicicletas();
            int totalPat = base.getTotalPatinetes();
            int libres = base.getEspaciosLibres();
            String averia = base.getAverias() ? "SÍ" : "NO";
            System.out.printf("%-15s | %-10d | %-10d | %-10d | %-12d | %-10s%n",
                base.getNombre(), base.getCapacidad(), libres, totalBicis, totalPat, averia);
        }
    }

    // Muestra las personas registradas en el sistema
    public void mostrarPersonasRegistradas() {
        System.out.println("=== Personas registradas en el sistema ===");
        var listaPersonas = servicioConsultas.obtenerPersonasOrdenadasPorDNI();
        if (listaPersonas.isEmpty()) {
            System.out.println("No hay personas registradas.");
            return;
        }
        // Imprime cabecera de la tabla
        System.out.printf("%-10s | %-20s | %-20s | %-15s%n",
            "DNI", "Nombre", "Apellidos", "Rol");
        System.out.println("---------------------------------------------------------------------");
        // Muestra cada persona
        for (var persona : listaPersonas) {
            System.out.printf("%-10s | %-20s | %-20s | %-15s%n",
                persona.getDNI(),
                persona.getNombre(),
                persona.getApellidos(),
                persona.getRol()
            );
        }
    }

    // Muestra la utilización de vehículos por cada usuario
    public void mostrarUtilizacionVehiculosPorUsuarios() {
        System.out.println("=== Utilización de vehículos por usuarios ===");
        List<Usuario> usuarios = servicioConsultas.obtenerUsuarios();
        if (usuarios.isEmpty()) {
            System.out.println("No hay usuarios registrados en el sistema.");
            return;
        }
        // Recorre cada usuario y muestra sus viajes
        for (Usuario usuario : usuarios) {
            System.out.println("\nUsuario: " + usuario.getNombre() + " " + usuario.getApellidos() + " | DNI: " + usuario.getDNI());
            List<Viaje> viajes = servicioConsultas.obtenerViajesUsuario(usuario);
            if (viajes.isEmpty()) {
                System.out.println("  No ha realizado viajes.");
                continue;
            }
            System.out.printf("  %-20s | %-15s | %-10s%n", "Fecha", "Tipo Vehículo", "Importe (€)");
            System.out.println("  ----------------------------------------------------------");
            double totalImporte = 0.0;
            for (Viaje viaje : viajes) {
                if (viaje.getTiempoFin() == 0) continue; // Solo mostrar viajes finalizados
                String fecha = Instant.ofEpochMilli(viaje.getTiempoInicio())
                        .atZone(ZoneId.systemDefault())
                        .toLocalDate()
                        .toString();
                String tipoVehiculo = viaje.getVehiculo().getVehiculoEnum().toString();
                double importe = viaje.getCosto();
                totalImporte += importe;
                System.out.printf("  %-20s | %-15s | %-10.2f%n", fecha, tipoVehiculo, importe);
            }
            System.out.printf("  Total importe asociado: %.2f €%n", totalImporte);
        }
    }

    // Muestra los vehículos que están en uso actualmente
    public void mostrarVehiculosEnUsoActual() {
        System.out.println("=== Vehículos en uso actualmente ===");
        List<Vehiculo> vehiculosEnUso = servicioConsultas.obtenerVehiculosEnUsoActual();
        if (vehiculosEnUso.isEmpty()) {
            System.out.println("No hay vehículos en uso en este momento.");
            return;
        }
        // Imprime cabecera de la tabla
        System.out.printf("%-5s | %-15s | %-20s%n", "ID", "Tipo", "Usuario");
        System.out.println("-----------------------------------------------");
        List<Viaje> todosViajes = servicioConsultas.obtenerTodosViajes();
        // Busca el viaje activo para cada vehículo en uso
        for (Vehiculo vehiculo : vehiculosEnUso) {
            Viaje viajeActivo = null;
            for (Viaje v : todosViajes) {
                if (v.getVehiculo().getID() == vehiculo.getID() && v.estaActivo()) {
                    viajeActivo = v;
                    break;
                }
            }
            String usuario;
            if (viajeActivo != null) {
                usuario = viajeActivo.getUsuario().getNombre() + " " + viajeActivo.getUsuario().getApellidos();
            } else {
                usuario = "Desconocido";
            }
            System.out.printf("%-5d | %-15s | %-20s%n", vehiculo.getID(), vehiculo.getVehiculoEnum(), usuario);
        }
    }

    // Muestra los vehículos en uso en un periodo de tiempo dado
    public void mostrarVehiculosEnUsoPorPeriodo() {
        System.out.println("=== Vehículos en uso en un periodo de tiempo ===");
        // Solicita fechas al usuario
        System.out.println("Introduce la fecha de inicio:");
        long inicio = pedirFechaComoMillis();
        System.out.println("Introduce la fecha de fin:");
        long fin = pedirFechaComoMillis();
        if (fin < inicio) {
            System.out.println("El tiempo de fin debe ser posterior al de inicio.");
            return;
        }
        List<Viaje> viajesEnPeriodo = servicioConsultas.obtenerViajesEnPeriodo(inicio, fin);
        if (viajesEnPeriodo.isEmpty()) {
            System.out.println("No hubo vehículos en uso en ese periodo.");
            return;
        }
        // Imprime cabecera de la tabla
        System.out.printf("%-5s | %-15s | %-20s | %-20s | %-20s%n", "ID", "Tipo", "Usuario", "Inicio", "Fin");
        System.out.println("-----------------------------------------------------------------------------------------------");
        // Muestra cada viaje en el periodo
        for (Viaje v : viajesEnPeriodo) {
            String usuario = v.getUsuario().getNombre() + " " + v.getUsuario().getApellidos();
            String fechaInicio = new java.text.SimpleDateFormat("dd/MM/yyyy HH:mm").format(new Date(v.getTiempoInicio()));
            String fechaFin = (v.getTiempoFin() == 0)
                    ? "En curso"
                    : new java.text.SimpleDateFormat("dd/MM/yyyy HH:mm").format(new Date(v.getTiempoFin()));
            System.out.printf("%-5d | %-15s | %-20s | %-20s | %-20s%n",
                    v.getVehiculo().getID(), v.getVehiculo().getVehiculoEnum(), usuario, fechaInicio, fechaFin);
        }
    }

    // Muestra las bases ordenadas por demanda (viajes iniciados y finalizados)
    public void mostrarBasesPorDemanda() {
        // Tabla por viajes iniciados
        List<Base> basesIniciados = servicioConsultas.obtenerBasesOrdenadasPorViajesIniciados();
        System.out.println("\n=== Bases ordenadas por VIAJES INICIADOS ===");
        System.out.printf("%-15s | %-10s | %-10s | %-10s | %-10s%n", "Base", "Capacidad", "Iniciados", "Finalizados", "Avería");
        System.out.println("--------------------------------------------------------------------------");
        // Muestra cada base por viajes iniciados
        for (Base base : basesIniciados) {
            System.out.printf("%-15s | %-10d | %-10d | %-10d | %-10s%n",
                base.getNombre(),
                base.getCapacidad(),
                base.getViajesIniciadosEnBase(),
                base.getViajesFinalizadosEnBase(),
                base.getAverias() ? "SÍ" : "NO"
            );
        }

        // Tabla por viajes finalizados
        List<Base> basesFinalizados = servicioConsultas.obtenerBasesOrdenadasPorViajesFinalizados();
        System.out.println("\n=== Bases ordenadas por VIAJES FINALIZADOS ===");
        System.out.printf("%-15s | %-10s | %-10s | %-10s | %-10s%n", "Base", "Capacidad", "Iniciados", "Finalizados", "Avería");
        System.out.println("--------------------------------------------------------------------------");
        // Muestra cada base por viajes finalizados
        for (Base base : basesFinalizados) {
            System.out.printf("%-15s | %-10d | %-10d | %-10d | %-10s%n",
                base.getNombre(),
                base.getCapacidad(),
                base.getViajesIniciadosEnBase(),
                base.getViajesFinalizadosEnBase(),
                base.getAverias() ? "SÍ" : "NO"
            );
        }
    }

    // Muestra el listado de reparaciones de vehículos en un periodo dado
    public void mostrarReparacionesVehiculosPorPeriodo() {
        // Pedir al usuario la fecha de inicio y fin
        System.out.println("=== Listado de reparaciones de vehículos por periodo ===");
        System.out.println("Introduce la fecha de inicio:");
        int diaInicio = UtilidadesEntradaDatos.getEnteroPositivo("Día (1-31): ", 1, 31);
        int mesInicio = UtilidadesEntradaDatos.getEnteroPositivo("Mes (1-12): ", 1, 12);
        int anioInicio = UtilidadesEntradaDatos.getEnteroPositivo("Año (ejemplo: 2025): ", 2000, 2100);
        LocalDate fechaInicio = LocalDate.of(anioInicio, mesInicio, diaInicio);

        System.out.println("Introduce la fecha de fin:");
        int diaFin = UtilidadesEntradaDatos.getEnteroPositivo("Día (1-31): ", 1, 31);
        int mesFin = UtilidadesEntradaDatos.getEnteroPositivo("Mes (1-12): ", 1, 12);
        int anioFin = UtilidadesEntradaDatos.getEnteroPositivo("Año (ejemplo: 2025): ", 2000, 2100);
        LocalDate fechaFin = LocalDate.of(anioFin, mesFin, diaFin);

        // Comprobar que la fecha de fin no es antes que la de inicio
        if (fechaFin.isBefore(fechaInicio)) {
            System.out.println("La fecha de fin debe ser posterior o igual a la de inicio.");
            return;
        }

        // Conseguir todos los mecánicos del sistema
        var personas = GestorPersonas.getInstancia().getPersonas();
        List<Mecanico> mecanicos = new ArrayList<>();
        for (var p : personas) {
            if (p instanceof Mecanico m) {
                mecanicos.add(m);
            }
        }

        // Crear un mapa para agrupar las reparaciones por vehículo
        Map<Integer, List<FacturaReparacionVehiculo>> reparacionesPorVehiculo = new HashMap<>();

        // Recorrer todos los mecánicos y sus reparaciones
        for (Mecanico mecanico : mecanicos) {
            for (FacturaReparacionVehiculo factura : mecanico.getReparacionesVehiculosRealizadas()) {
                LocalDate fecha = factura.getFecha();
                // Si la fecha está en el rango pedido, la añadimos al mapa
                if ((fecha.isEqual(fechaInicio) || fecha.isAfter(fechaInicio)) &&
                    (fecha.isEqual(fechaFin) || fecha.isBefore(fechaFin))) {
                    int idVehiculo = factura.getVehiculo().getID();
                    if (!reparacionesPorVehiculo.containsKey(idVehiculo)) {
                        reparacionesPorVehiculo.put(idVehiculo, new ArrayList<>());
                    }
                    reparacionesPorVehiculo.get(idVehiculo).add(factura);
                }
            }
        }

        // Si no hay reparaciones, avisar al usuario
        if (reparacionesPorVehiculo.isEmpty()) {
            System.out.println("No hay reparaciones registradas en ese periodo.");
            return;
        }

        // Mostrar los resultados
        System.out.println("Listado de vehículos con reparaciones entre " + fechaInicio + " y " + fechaFin + ":");
        for (var entry : reparacionesPorVehiculo.entrySet()) {
            int idVehiculo = entry.getKey();
            List<FacturaReparacionVehiculo> facturas = entry.getValue();
            Vehiculo vehiculo = facturas.get(0).getVehiculo();
            double total = 0;
            System.out.println("Vehículo ID: " + idVehiculo + " (" + vehiculo.getNombreVehiculo() + ")");
            System.out.println("  Número de reparaciones: " + facturas.size());
            for (FacturaReparacionVehiculo factura : facturas) {
                System.out.println("    Fecha: " + factura.getFecha() + " | Importe: " + factura.getCoste() + "€");
                total += factura.getCoste();
            }
            System.out.println("  Importe total: " + String.format("%.2f", total) + "€");
            System.out.println("-----------------------------------");
        }
    }

    // Muestra el ranking de intervenciones de mecánicos y personal de mantenimiento
    public void mostrarRankingIntervencionesTrabajadores() {
        System.out.println("=== Ranking de intervenciones de Mecánicos y Mantenimiento ===");
        var personas = GestorPersonas.getInstancia().getPersonas();
        List<Object[]> ranking = new ArrayList<>();

        // Recorre todas las personas y añade mecánicos y mantenimiento al ranking
        for (var p : personas) {
            if (p instanceof Mecanico m) {
                ranking.add(new Object[]{
                    m.getNombre() + " " + m.getApellidos(),
                    "Mecánico",
                    m.getIntervencionesRealizadas()
                });
            } else if (p instanceof Mantenimiento mt) {
                ranking.add(new Object[]{
                    mt.getNombre() + " " + mt.getApellidos(),
                    "Mantenimiento",
                    mt.getIntervencionesRealizadas()
                });
            }
        }

        // Ordenar de mayor a menor por intervenciones
        ranking.sort((a, b) -> Integer.compare((int) b[2], (int) a[2]));

        if (ranking.isEmpty()) {
            System.out.println("No hay mecánicos ni personal de mantenimiento registrados.");
            return;
        }

        // Imprime cabecera de la tabla
        System.out.printf("%-25s | %-13s | %-15s%n", "Nombre", "Rol", "Intervenciones");
        System.out.println("---------------------------------------------------------------");
        // Muestra cada fila del ranking
        for (Object[] fila : ranking) {
            System.out.printf("%-25s | %-13s | %-15d%n", fila[0], fila[1], fila[2]);
        }
    }

    // Muestra el listado de vehículos por tipo y tiempo de uso
    public void mostrarVehiculosPorTiempoUso() {
        System.out.println("=== Listado de vehículos por tipo y tiempo de uso (mayor a menor) ===");
        List<Vehiculo> vehiculos = servicioConsultas.obtenerVehiculos();
        List<Viaje> viajes = servicioConsultas.obtenerTodosViajes();

        // Map: VehiculoID -> Tiempo total de uso en milisegundos
        Map<Integer, Long> tiempoUsoPorVehiculo = new HashMap<>();
        for (Vehiculo v : vehiculos) {
            tiempoUsoPorVehiculo.put(v.getID(), 0L);
        }
        // Suma el tiempo de uso de cada viaje finalizado
        for (Viaje viaje : viajes) {
            if (viaje.getTiempoFin() > 0) {
                int id = viaje.getVehiculo().getID();
                long duracion = viaje.getTiempoFin() - viaje.getTiempoInicio();
                tiempoUsoPorVehiculo.put(id, tiempoUsoPorVehiculo.getOrDefault(id, 0L) + duracion);
            }
        }

        // Agrupar por tipo de vehículo
        Map<VehiculoEnum, List<Vehiculo>> vehiculosPorTipo = new HashMap<>();
        for (Vehiculo v : vehiculos) {
            vehiculosPorTipo.computeIfAbsent(v.getVehiculoEnum(), k -> new ArrayList<>()).add(v);
        }

        // Para cada tipo de vehículo, muestra la lista ordenada por tiempo de uso
        for (VehiculoEnum tipo : VehiculoEnum.values()) {
            List<Vehiculo> lista = vehiculosPorTipo.get(tipo);
            if (lista == null || lista.isEmpty()) continue;
            // Ordenar por tiempo de uso descendente
            lista.sort((v1, v2) -> Long.compare(
                tiempoUsoPorVehiculo.getOrDefault(v2.getID(), 0L),
                tiempoUsoPorVehiculo.getOrDefault(v1.getID(), 0L)
            ));
            System.out.println("\nTipo: " + tipo);
            System.out.printf("%-5s | %-20s | %-15s%n", "ID", "Nombre", "Tiempo de uso (h)");
            System.out.println("-----------------------------------------------");
            // Muestra cada vehículo del tipo
            for (Vehiculo v : lista) {
                long tiempoMs = tiempoUsoPorVehiculo.getOrDefault(v.getID(), 0L);
                double horas = tiempoMs / 3600000.0;
                System.out.printf("%-5d | %-20s | %-15.2f%n", v.getID(), v.getNombreVehiculo(), horas);
            }
        }
    }

    // Muestra el listado de usuarios por gasto en alquileres en un periodo
    public void mostrarUsuariosPorGastoEnPeriodo() {
        System.out.println("=== Listado de usuarios por gasto en alquileres en un periodo ===");
        // Solicita fechas al usuario
        System.out.println("Introduce la fecha de inicio:");
        long inicio = pedirFechaComoMillis();
        System.out.println("Introduce la fecha de fin:");
        long fin = pedirFechaComoMillis();
        if (fin < inicio) {
            System.out.println("El tiempo de fin debe ser posterior al de inicio.");
            return;
        }

        List<Usuario> usuarios = servicioConsultas.obtenerUsuarios();
        Map<Usuario, Double> gastoPorUsuario = new HashMap<>();

        // Calcula el gasto de cada usuario en el periodo
        for (Usuario usuario : usuarios) {
            double gasto = 0.0;
            for (Viaje viaje : usuario.getHistorialViajes()) {
                if (viaje.getTiempoFin() > 0 && viaje.getTiempoFin() >= inicio && viaje.getTiempoInicio() <= fin) {
                    gasto += viaje.getCosto();
                }
            }
            gastoPorUsuario.put(usuario, gasto);
        }

        // Ordenar usuarios por gasto descendente
        List<Map.Entry<Usuario, Double>> listaOrdenada = new ArrayList<>(gastoPorUsuario.entrySet());
        listaOrdenada.sort((a, b) -> Double.compare(b.getValue(), a.getValue()));

        // Imprime cabecera de la tabla
        System.out.printf("%-10s | %-20s | %-20s | %-10s%n", "DNI", "Nombre", "Apellidos", "Gasto (€)");
        System.out.println("---------------------------------------------------------------------");
        // Muestra cada usuario y su gasto
        for (Map.Entry<Usuario, Double> entry : listaOrdenada) {
            Usuario usuario = entry.getKey();
            double gasto = entry.getValue();
            System.out.printf("%-10s | %-20s | %-20s | %-10.2f%n",
                usuario.getDNI(),
                usuario.getNombre(),
                usuario.getApellidos(),
                gasto
            );
        }
    }

    // ===========================
    // MÉTODOS AUXILIARES
    // ===========================

    // Solicita al usuario una fecha y hora y la devuelve en milisegundos desde epoch
    private long pedirFechaComoMillis() {
        int dia = UtilidadesEntradaDatos.getEnteroPositivo("Día (1-31): ", 1, 31);
        int mes = UtilidadesEntradaDatos.getEnteroPositivo("Mes (1-12): ", 1, 12);
        int anio = UtilidadesEntradaDatos.getEnteroPositivo("Año (ejemplo: 2025): ", 2000, 2100);
        int hora = UtilidadesEntradaDatos.getEnteroPositivo("Hora (0-23): ", 0, 23);
        int minuto = UtilidadesEntradaDatos.getEnteroPositivo("Minuto (0-59): ", 0, 59);
        LocalDateTime ldt = LocalDateTime.of(anio, mes, dia, hora, minuto);
        return ldt.atZone(ZoneId.systemDefault()).toInstant().toEpochMilli();
    }
}

package Menus.MenuAdmin;

import Utilidades.UtilidadesEntradaDatos;

public class MenuGestionBases {

    // ===========================
    // ATRIBUTOS Y CONSTRUCTOR
    // ===========================
    private final ServicioGestionBases servicioGestionBases;

    public MenuGestionBases() {
        this.servicioGestionBases = new ServicioGestionBases();
    }

    // ===========================
    // MENÚ PRINCIPAL
    // ===========================
    public void mostrarMenu() {
        boolean volver = false;

        while (!volver) {
            System.out.println("\n========== GESTIÓN DE BASES ==========");
            System.out.println("1. Alta Base por Coordenadas");
            System.out.println("2. Baja Base por Coordenadas");
            System.out.println("3. Baja Base por Nombre");
            System.out.println("4. Volver al menú principal");

            System.out.print("\nSeleccione opción: ");
            int opcion = UtilidadesEntradaDatos.getEnteroPositivo("Selecciona una opción", 1, 4);

            try {
                switch (opcion) {
                    case 1 -> altaBasePorCoordenadas();
                    case 2 -> bajaBasePorCoordenadas();
                    case 3 -> bajaBasePorNombre();
                    case 4 -> volver = true;
                    default -> System.out.println("Opción no válida. Por favor, selecciona una opción del menú.");
                }
            } catch (Exception e) {
                System.out.println("Error: " + e.getMessage());
            }
        }
    }

    // ===========================
    // ALTA DE BASE POR COORDENADAS
    // ===========================
    private void altaBasePorCoordenadas() {
        System.out.println("\n--- Alta de Base Manual ---");

        System.out.print("Introduce el nombre de la base: ");
        String nombreBase = UtilidadesEntradaDatos.getStringLongitud("Introduce el nombre de la base", 1, 20);

        if (servicioGestionBases.existeBasePorNombre(nombreBase)) {
            System.out.println("Error: Ya existe una base con el nombre '" + nombreBase + "'.");
            return;
        }

        System.out.print("Introduce la coordenada X: ");
        int coordX = UtilidadesEntradaDatos.getEnteroPositivo("Introduce la coordenada X", 0, servicioGestionBases.getMaxCoordenadaX());

        System.out.print("Introduce la coordenada Y: ");
        int coordY = UtilidadesEntradaDatos.getEnteroPositivo("Introduce la coordenada Y", 0, servicioGestionBases.getMaxCoordenadaY());

        if (!servicioGestionBases.coordenadasValidasYLibres(coordX, coordY)) {
            System.out.println("Error: Las coordenadas (" + coordX + ", " + coordY +
                    ") no son válidas o ya están ocupadas.");
            return;
        }

        System.out.print("Introduce la capacidad de la base: ");
        int capacidad = UtilidadesEntradaDatos.getEnteroPositivo("Introduce la capacidad de la base", 1, Integer.MAX_VALUE);

        if (capacidad <= 0) {
            System.out.println("Error: La capacidad debe ser un número positivo.");
            return;
        }

        boolean resultado = servicioGestionBases.altaBasePorCoordenadas(nombreBase, coordX, coordY, capacidad);

        if (resultado) {
            System.out.println("Base '" + nombreBase + "' creada correctamente en coordenadas ("
                    + coordX + ", " + coordY + ") con capacidad para " + capacidad + " vehículos.");
            servicioGestionBases.dibujarMapa();
        } else {
            System.out.println("Error al crear la base. Verifica que todos los datos sean correctos.");
        }
    }

    // ===========================
    // BAJA DE BASE POR COORDENADAS
    // ===========================
    private void bajaBasePorCoordenadas() {
        System.out.println("\n--- Baja de Base por Coordenadas ---");

        System.out.print("Introduce la coordenada X de la base a eliminar: ");
        int coordX = UtilidadesEntradaDatos.getEnteroPositivo("Introduce la coordenada X", 0, servicioGestionBases.getMaxCoordenadaX());

        System.out.print("Introduce la coordenada Y de la base a eliminar: ");
        int coordY = UtilidadesEntradaDatos.getEnteroPositivo("Introduce la coordenada Y", 0, servicioGestionBases.getMaxCoordenadaY());

        if (!servicioGestionBases.existeBaseEnCoordenadas(coordX, coordY)) {
            System.out.println("Error: No existe una base en las coordenadas (" + coordX + ", " + coordY + ").");
            return;
        }

        boolean resultado = servicioGestionBases.bajaBasePorCoordenadas(coordX, coordY);

        if (resultado) {
            System.out.println("Base en coordenadas (" + coordX + ", " + coordY + ") eliminada correctamente.");
            servicioGestionBases.dibujarMapa();
        } else {
            System.out.println("Error al eliminar la base. Verifica que los datos sean correctos.");
        }
    }

    // ===========================
    // BAJA DE BASE POR NOMBRE
    // ===========================
    private void bajaBasePorNombre() {
        System.out.println("\n--- Baja de Base ---");

        System.out.print("Introduce el nombre de la base a eliminar: ");
        String nombreBase = UtilidadesEntradaDatos.getStringLongitud("Introduce el nombre de la base", 1, 20);

        if (!servicioGestionBases.existeBasePorNombre(nombreBase)) {
            System.out.println("Error: No existe una base con el nombre '" + nombreBase + "'.");
            return;
        }

        boolean resultado = servicioGestionBases.bajaBasePorNombre(nombreBase);

        if (resultado) {
            System.out.println("Base '" + nombreBase + "' eliminada correctamente.");
            servicioGestionBases.dibujarMapa();
        } else {
            System.out.println("Error al eliminar la base. Verifica que los datos sean correctos.");
        }
    }
}

package Menus.MenuAdmin;

import Utilidades.UtilidadesEntradaDatos;

public class MenuGestionEmpleados {

    private final ServicioGestionEmpleados servicioGestionEmpleados;

    public MenuGestionEmpleados() {
        this.servicioGestionEmpleados = new ServicioGestionEmpleados();
    }

    // Muestra el menú principal de gestión de empleados y gestiona la navegación de opciones
    public void mostrarMenu() {
        boolean volver = false;
        while (!volver) {
            System.out.println("\n========== GESTIÓN DE EMPLEADOS ==========");
            System.out.println("1. Asignar vehículo por recarga de batería");
            System.out.println("2. Asignar vehículo por avería");
            System.out.println("3. Asignar base por avería");
            System.out.println("4. Volver al menú principal");
            System.out.print("\nSeleccione opción: ");
            int opcion = UtilidadesEntradaDatos.getEnteroPositivo("Opción: ", 1, 4);

            try {
                switch (opcion) {
                    case 1 -> asignarVehiculoSinBateria();
                    case 2 -> asignarVehiculoPorAveria();
                    case 3 -> asignarBasePorAveria();
                    case 4 -> volver = true;
                    default -> System.out.println("Opción no válida.");
                }
            } catch (Exception e) {
                System.out.println("Error: " + e.getMessage());
            }
        }
    }

    // Asigna un vehículo a mantenimiento por batería baja
    private void asignarVehiculoSinBateria() {
        System.out.println("\n=== ASIGNAR VEHÍCULO POR RECARGA DE BATERÍA ===");
        int idVehiculo = UtilidadesEntradaDatos.getEnteroPositivo("Introduce el ID del vehículo: ", 1, Integer.MAX_VALUE);
        String dni = UtilidadesEntradaDatos.getDNI("Introduce el DNI del trabajador de mantenimiento: ");
        boolean resultado = servicioGestionEmpleados.asignarVehiculoSinBateria(dni, idVehiculo);
        if (resultado) {
            System.out.println("Vehículo asignado correctamente a mantenimiento por batería baja.");
        } else {
            System.out.println("No se pudo asignar el vehículo a mantenimiento por batería baja.");
        }
    }

    // Asigna un vehículo a mantenimiento y mecánico por avería
    private void asignarVehiculoPorAveria() {
        System.out.println("\n=== ASIGNAR VEHÍCULO POR AVERÍA ===");
        int idVehiculo = UtilidadesEntradaDatos.getEnteroPositivo("Introduce el ID del vehículo: ", 1, Integer.MAX_VALUE);
        String dniMantenimiento = UtilidadesEntradaDatos.getDNI("Introduce el DNI del trabajador de mantenimiento: ");
        String dniMecanico = UtilidadesEntradaDatos.getDNI("Introduce el DNI del mecánico: ");
        boolean resultado = servicioGestionEmpleados.asignarVehiculoPorAveria(dniMantenimiento, dniMecanico, idVehiculo);
        if (resultado) {
            System.out.println("Vehículo asignado correctamente a mantenimiento y mecánico por avería.");
        } else {
            System.out.println("No se pudo asignar el vehículo a mantenimiento y mecánico por avería.");
        }
    }

    // Asigna una base averiada a un mecánico
    private void asignarBasePorAveria() {
        System.out.println("\n=== ASIGNAR BASE POR AVERÍA ===");
        String nombreBase = UtilidadesEntradaDatos.getStringLongitud("Introduce el nombre de la base: ", 1, 50);
        String dniMecanico = UtilidadesEntradaDatos.getDNI("Introduce el DNI del mecánico: ");
        boolean resultado = servicioGestionEmpleados.asignarBasePorAveria(dniMecanico, nombreBase);
        if (resultado) {
            System.out.println("Base asignada correctamente al mecánico por avería.");
        } else {
            System.out.println("No se pudo asignar la base al mecánico por avería.");
        }
    }
}

package Menus.MenuAdmin;

import Enum.RolEnum;
import GestorPersonas.Personas.Persona;
import GestorPersonas.Personas.Usuario;
import Utilidades.UtilidadesEntradaDatos;
import java.util.Map;

public class MenuGestionPersonas {

    // ==========================
    // ATRIBUTOS PRINCIPALES
    // ==========================
    private final ServicioGestionPersonas servicioGestionPersonas;

    // ==========================
    // CONSTRUCTOR
    // ==========================
    public MenuGestionPersonas() {
        this.servicioGestionPersonas = new ServicioGestionPersonas();
    }

    // ==========================
    // MENÚ PRINCIPAL DE GESTIÓN DE PERSONAS
    // ==========================
    public void mostrarMenu() {
        boolean volver = false;

        while (!volver) {
            System.out.println("\n========== GESTIÓN DE PERSONAS ==========");
            System.out.println("1. Alta Usuario");
            System.out.println("2. Baja Usuario");
            System.out.println("3. Modificar Usuario");
            System.out.println("4. Mostrar Usuarios para Promoción");
            System.out.println("5. Cambiar Estado Usuario (Standard/Premium)");
            System.out.println("6. Submenu - Buscar Personas");
            System.out.println("7. Volver al menú principal");

            System.out.print("\nSeleccione opción: ");
            int opcion = UtilidadesEntradaDatos.getEnteroPositivo("Selecciona una opción", 1, 7);

            try {
                switch (opcion) {
                    case 1 -> altaUsuario();
                    case 2 -> bajaUsuario();
                    case 3 -> modificarUsuario();
                    case 4 -> mostrarUsuariosPromocion();
                    case 5 -> cambiarRolUsuario();
                    case 6 -> menuBuscarPersonas();
                    case 7 -> volver = true;
                    default -> System.out.println("Opción no válida. Por favor, selecciona una opción del menú.");
                }
            } catch (Exception e) {
                System.out.println("Error: " + e.getMessage());
            }
        }
    }

    // ==========================
    // ALTA DE USUARIO
    // ==========================
    private void altaUsuario() {
        String nombre = UtilidadesEntradaDatos.getStringLongitud("Introduce el nombre del nuevo registro: ", 1, 20);
        String apellidos = UtilidadesEntradaDatos.getStringLongitud("Introduce los apellidos del nuevo registro: ", 1, 20);
        System.out.print("Introduce el DNI del nuevo registro (8 números seguidos de una letra mayúscula): ");
        String DNI = UtilidadesEntradaDatos.getDNI("Introduce el DNI del nuevo registro: ");
        RolEnum rolEnum = servicioGestionPersonas.seleccionarRol();
        servicioGestionPersonas.altaUsuario(nombre, apellidos, DNI, rolEnum);
    }

    // ==========================
    // BAJA DE USUARIO
    // ==========================
    private void bajaUsuario() {
        System.out.print("Introduce el DNI del usuario a eliminar (8 números seguidos de una letra mayúscula): ");
        String DNI = UtilidadesEntradaDatos.getDNI("Introduce el DNI del usuario a eliminar: ");
        servicioGestionPersonas.bajaUsuario(DNI);
    }

    // ==========================
    // MODIFICACIÓN DE USUARIO
    // ==========================
    private void modificarUsuario() {
        System.out.print("Introduce el DNI del usuario a modificar (8 números seguidos de una letra mayúscula): ");
        String DNI = UtilidadesEntradaDatos.getDNI("Introduce el DNI del usuario a modificar: ");

        if (!servicioGestionPersonas.existeDNI(DNI)) {
            System.out.println("Error: El DNI no existe. Operación cancelada.");
            return;
        }

        Persona persona = servicioGestionPersonas.getPersonaPorDNI(DNI);
        System.out.println("\nDatos actuales del usuario:");
        System.out.println("Nombre: " + persona.getNombre());
        System.out.println("Apellidos: " + persona.getApellidos());
        System.out.println("Rol actual: " + persona.getRol());

        boolean eraPremium = persona.getRol() == RolEnum.USUARIO_PREMIUM;

        String nuevoNombre = UtilidadesEntradaDatos.getStringLongitud("Introduce el nuevo nombre", 1, 20);
        String nuevosApellidos = UtilidadesEntradaDatos.getStringLongitud("Introduce los nuevos apellidos", 1, 20);
        RolEnum rolEnum = servicioGestionPersonas.seleccionarRol();

        if (eraPremium && rolEnum == RolEnum.USUARIO_STANDARD) {
            System.out.println("El usuario era Premium. Se mantendrá como USUARIO_PREMIUM.");
            rolEnum = RolEnum.USUARIO_PREMIUM;
        }

        servicioGestionPersonas.modificarPersona(DNI, nuevoNombre, nuevosApellidos, rolEnum);
    }

    // ==========================
    // MOSTRAR USUARIOS PARA PROMOCIÓN
    // ==========================
    private void mostrarUsuariosPromocion() {
        System.out.println("\n===== USUARIOS QUE CUMPLEN CONDICIONES PARA PROMOCIÓN =====");
        servicioGestionPersonas.mostrarUsuariosPromocion();
    }

    // ==========================
    // CAMBIAR ROL DE USUARIO (STANDARD/PREMIUM)
    // ==========================
    private void cambiarRolUsuario() {
        System.out.println("\n--- Modificar Estado de Usuario (Standard/Premium) ---");

        System.out.print("Introduce el DNI del usuario (8 números seguidos de una letra mayúscula): ");
        String DNI = UtilidadesEntradaDatos.getDNI("Introduce el DNI del usuario: ");

        if (!servicioGestionPersonas.existeDNI(DNI)) {
            System.out.println("Error: No existe ningún usuario con el DNI proporcionado.");
            return;
        }
        Persona persona = servicioGestionPersonas.getPersonaPorDNI(DNI);
        if (!(persona instanceof Usuario)) {
            System.out.println("Error: El DNI proporcionado no corresponde a un usuario.");
            return;
        }
        Usuario usuario = (Usuario) persona;
        boolean esPremiumActualmente = usuario.getRol() == RolEnum.USUARIO_PREMIUM;

        System.out.println("\nUsuario: " + usuario.getNombre() + " " + usuario.getApellidos());
        System.out.println("Rol actual: " + usuario.getRol());

        if (esPremiumActualmente) {
            System.out.println("¿Deseas convertir este usuario a STANDARD?");
            System.out.println("1. Sí");
            System.out.println("2. No");
            int opcion = UtilidadesEntradaDatos.getEnteroPositivo("Selecciona una opción (1-2): ", 1, 2);

            if (opcion == 1) {
                if (servicioGestionPersonas.cambiarRolUsuario(DNI, false)) {
                    System.out.println("Usuario convertido a STANDARD exitosamente.");
                } else {
                    System.out.println("No se pudo modificar el estado del usuario.");
                }
            } else {
                System.out.println("Operación cancelada. El usuario sigue siendo PREMIUM.");
            }
        } else {
            Map<String, Object> infoUsuario = servicioGestionPersonas.obtenerDetallesPromocionUsuario(usuario);

            if (infoUsuario == null) {
                System.out.println("\nEl usuario NO cumple las condiciones necesarias para ser promovido a PREMIUM.");
                System.out.println("Para ser promovido, debe cumplir al menos una de estas condiciones:");
                System.out.println("- Al menos 15 viajes en el último mes");
                System.out.println("- Al menos 10 viajes mensuales durante 3 meses consecutivos");
                System.out.println("- Uso de todos los tipos de vehículos durante 6 meses consecutivos");
                return;
            }

            System.out.println("\nEl usuario CUMPLE las siguientes condiciones para promoción:");
            if ((boolean) infoUsuario.get("condicion1")) {
                System.out.println("- Al menos 15 viajes en el último mes (" + infoUsuario.get("viajesUltimoMes") + " viajes)");
            }
            if ((boolean) infoUsuario.get("condicion2")) {
                System.out.println("- Al menos 10 viajes mensuales durante 3 meses consecutivos");
            }
            if ((boolean) infoUsuario.get("condicion3")) {
                System.out.println("- Uso de todos los tipos de vehículos durante 6 meses consecutivos");
            }

            System.out.println("\n¿Deseas promover este usuario a PREMIUM?");
            System.out.println("1. Sí");
            System.out.println("2. No");
            int opcionPromocion = UtilidadesEntradaDatos.getEnteroPositivo("Selecciona una opción (1-2): ", 1, 2);

            if (opcionPromocion == 1) {
                if (servicioGestionPersonas.cambiarRolUsuario(DNI, true)) {
                    System.out.println("Usuario promovido a PREMIUM exitosamente.");
                } else {
                    System.out.println("No se pudo modificar el estado del usuario.");
                }
            } else {
                System.out.println("Operación cancelada. El usuario sigue siendo STANDARD.");
            }
        }
    }

    // ==========================
    // MENÚ DE BÚSQUEDA DE PERSONAS
    // ==========================
    private void menuBuscarPersonas() {
        System.out.println("\n=== BÚSQUEDA DE PERSONAS ===");
        System.out.println("1. Buscar por DNI");
        System.out.println("2. Buscar por nombre");
        System.out.println("3. Buscar por apellido");
        System.out.println("4. Filtrar por rol");
        System.out.println("5. Volver al menú anterior");

        System.out.print("\nSeleccione una opción: ");
        int opcion = UtilidadesEntradaDatos.getEnteroPositivo("Introduce una opción (1-5): ", 1, 5);

        switch (opcion) {
            case 1 -> servicioGestionPersonas.buscarPersonaPorDNI();
            case 2 -> servicioGestionPersonas.buscarPersonaPorNombre();
            case 3 -> servicioGestionPersonas.buscarPersonaPorApellido();
            case 4 -> servicioGestionPersonas.filtrarPersonasPorRol();
            case 5 -> { return; }
            default -> System.out.println("Opción no válida.");
        }
    }
}

package Menus.MenuAdmin;

import Enum.VehiculoEnum;
import GestorVehiculosBases.Localizaciones.Base;
import GestorVehiculosBases.Vehiculos.MotoGrande;
import GestorVehiculosBases.Vehiculos.MotoPequena;
import GestorVehiculosBases.Vehiculos.Vehiculo;
import GestorVehiculosBases.Vehiculos.VehiculoDeBase;
import Utilidades.UtilidadesEntradaDatos;
import java.util.List;

public class MenuGestionVehiculos {

    private final ServicioGestionVehiculos servicioGestionVehiculos;

    public MenuGestionVehiculos() {
        this.servicioGestionVehiculos = new ServicioGestionVehiculos();
    }

    public void mostrarMenu() {
        boolean volver = false;

        while (!volver) {
            System.out.println("\n========== GESTIÓN DE VEHÍCULOS ==========");
            System.out.println("1. Alta Vehículo en Mapa por Coordenadas (Motos)");
            System.out.println("2. Alta Vehículo en Base por Nombre de Base (Bicicletas/Patinetes)");
            System.out.println("3. Alta Vehículo en Almacén");
            System.out.println("4. Baja Vehículo por ID");
            System.out.println("5. Submenu - Reubicar Vehículos");
            System.out.println("6. Volver al menú principal");

            System.out.print("\nSeleccione opción: ");
            int opcion = UtilidadesEntradaDatos.getEnteroPositivo("Selecciona una opción", 1, 6);

            try {
                switch (opcion) {
                    case 1 -> altaVehiculoMapa();
                    case 2 -> altaVehiculoBase();
                    case 3 -> altaVehiculoAlmacen();
                    case 4 -> bajaVehiculo();
                    case 5 -> menuReubicarVehiculos();
                    case 6 -> volver = true;
                    default -> System.out.println("Opción no válida. Por favor, selecciona una opción del menú.");
                }
            } catch (Exception e) {
                System.out.println("Error: " + e.getMessage());
            }
        }
    }

    // Alta de moto en el mapa por coordenadas
    private void altaVehiculoMapa() {
        System.out.println("\n--- Alta de Moto en Posición del Mapa ---");
        System.out.println("Selecciona el tipo de moto:");
        System.out.println("1. " + VehiculoEnum.MOTOPEQUENA);
        System.out.println("2. " + VehiculoEnum.MOTOGRANDE);

        int opcion = UtilidadesEntradaDatos.getEnteroPositivo("Selecciona una opción", 1, 2);
        VehiculoEnum tipoMoto;
        switch (opcion) {
            case 1 -> tipoMoto = VehiculoEnum.MOTOPEQUENA;
            case 2 -> tipoMoto = VehiculoEnum.MOTOGRANDE;
            default -> {
                System.out.println("Opción no válida. Operación cancelada.");
                return;
            }
        }

        System.out.println("\nIntroduce las coordenadas donde posicionar la moto:");
        int x = UtilidadesEntradaDatos.getEnteroPositivo("Introduce la coordenada X", 0, servicioGestionVehiculos.getMaxCoordenadaX());
        int y = UtilidadesEntradaDatos.getEnteroPositivo("Introduce la coordenada Y", 0, servicioGestionVehiculos.getMaxCoordenadaY());

        Vehiculo nuevoVehiculo = servicioGestionVehiculos.altaVehiculoMapa(tipoMoto, x, y);

        if (nuevoVehiculo != null) {
            System.out.println("Moto añadida exitosamente. ID asignado: " + nuevoVehiculo.getID());
            servicioGestionVehiculos.dibujarMapa();
        } else {
            System.out.println("No se pudo añadir la moto en la posición especificada.");
        }
    }

    // Alta de bicicleta o patinete en una base
    private void altaVehiculoBase() {
        System.out.println("\n--- Alta de Vehículo en Base ---");
        System.out.println("Selecciona el tipo de vehículo:");
        System.out.println("1. " + VehiculoEnum.BICICLETA);
        System.out.println("2. " + VehiculoEnum.PATINETE);

        int opcion = UtilidadesEntradaDatos.getEnteroPositivo("Selecciona una opción", 1, 2);
        VehiculoEnum tipoVehiculo;
        switch (opcion) {
            case 1 -> tipoVehiculo = VehiculoEnum.BICICLETA;
            case 2 -> tipoVehiculo = VehiculoEnum.PATINETE;
            default -> {
                System.out.println("Opción no válida. Operación cancelada.");
                return;
            }
        }

        List<Base> bases = servicioGestionVehiculos.getBases();
        if (bases.isEmpty()) {
            System.out.println("No hay bases disponibles en el sistema. Primero debe crear una base.");
            return;
        }

        System.out.println("\nBases disponibles:");
        for (Base base : bases) {
            System.out.println("- " + base.getNombre() +
                    " (Coordenadas: " + base.getCoordenadaX() + ", " + base.getCoordenadaY() +
                    ", Espacios libres: " + base.getEspaciosLibres() + ")");
        }

        System.out.print("\nIntroduce el nombre de la base donde añadir el vehículo: ");
        String nombreBase = UtilidadesEntradaDatos.getStringLongitud("Introduce el nombre de la base", 1, 50);

        Vehiculo nuevoVehiculo = servicioGestionVehiculos.altaVehiculoBase(tipoVehiculo, nombreBase);

        if (nuevoVehiculo != null) {
            System.out.println("Vehículo añadido exitosamente a la base. ID asignado: " + nuevoVehiculo.getID());
        } else {
            System.out.println("No se pudo añadir el vehículo a la base especificada.");
        }
    }

    // Alta de vehículo en el almacén
    private void altaVehiculoAlmacen() {
        System.out.println("\n--- Alta de Vehículo en Almacén ---");
        System.out.println("Selecciona el tipo de vehículo:");
        System.out.println("1. " + VehiculoEnum.BICICLETA);
        System.out.println("2. " + VehiculoEnum.PATINETE);
        System.out.println("3. " + VehiculoEnum.MOTOPEQUENA);
        System.out.println("4. " + VehiculoEnum.MOTOGRANDE);
        int opcion = UtilidadesEntradaDatos.getEnteroPositivo("Selecciona una opción", 1, 4);

        VehiculoEnum tipoVehiculo;
        switch (opcion) {
            case 1 -> tipoVehiculo = VehiculoEnum.BICICLETA;
            case 2 -> tipoVehiculo = VehiculoEnum.PATINETE;
            case 3 -> tipoVehiculo = VehiculoEnum.MOTOPEQUENA;
            case 4 -> tipoVehiculo = VehiculoEnum.MOTOGRANDE;
            default -> {
                System.out.println("Opción no válida. Operación cancelada.");
                return;
            }
        }

        Vehiculo nuevoVehiculo = servicioGestionVehiculos.altaVehiculoAlmacen(tipoVehiculo);
        if (nuevoVehiculo != null) {
            System.out.println("Vehículo añadido exitosamente al almacén. ID asignado: " + nuevoVehiculo.getID());
        } else {
            System.out.println("No se pudo añadir el vehículo al almacén.");
        }
    }

    // Baja de un vehículo por ID
    private void bajaVehiculo() {
        System.out.println("\n--- Baja de Vehículo ---");
        int ID = UtilidadesEntradaDatos.getEnteroPositivo("Introduce el ID del vehículo", 1, Integer.MAX_VALUE);
        boolean resultado = servicioGestionVehiculos.bajaVehiculo(ID);
        if (resultado) {
            System.out.println("Vehículo eliminado correctamente.");
        } else {
            System.out.println("No se pudo eliminar el vehículo. Verifica el ID.");
        }
    }

    // Submenú para reubicar vehículos
    private void menuReubicarVehiculos() {
        System.out.println("\n=== REUBICAR VEHÍCULOS ===");
        System.out.println("1. Mover moto a nuevas coordenadas");
        System.out.println("2. Mover bicicleta/patinete a nueva base");
        System.out.println("3. Volver al menú anterior");

        int opcion = UtilidadesEntradaDatos.getEnteroPositivo("Selecciona una opción", 1, 3);

        switch (opcion) {
            case 1 -> moverMotoACoordenadas();
            case 2 -> moverVehiculoANuevaBase();
            case 3 -> { return; }
            default -> System.out.println("Opción no válida.");
        }
    }

    // Mover una moto a nuevas coordenadas en el mapa
    private void moverMotoACoordenadas() {
        System.out.println("\n--- Mover Moto a Nuevas Coordenadas ---");

        List<Vehiculo> motosEnMapa = servicioGestionVehiculos.getMotosEnMapa();
        if (motosEnMapa.isEmpty()) {
            System.out.println("No hay motos disponibles en el mapa para mover.");
            return;
        }

        System.out.println("\nMotos disponibles en el mapa:");
        for (Vehiculo vehiculo : motosEnMapa) {
            if (vehiculo instanceof MotoPequena moto) {
                System.out.print("ID: " + moto.getID() +
                        ", Tipo: " + moto.getVehiculoEnum() +
                        ", Coordenadas: (" + moto.getCoordenadaX() + ", " + moto.getCoordenadaY() + ")" +
                        ", Batería: " + moto.getBateria() + "%" +
                        ", Averías: " + (moto.getAverias() ? "Sí" : "No") + "\n");
            } else if (vehiculo instanceof MotoGrande moto) {
                System.out.print("ID: " + moto.getID() +
                        ", Tipo: " + moto.getVehiculoEnum() +
                        ", Coordenadas: (" + moto.getCoordenadaX() + ", " + moto.getCoordenadaY() + ")" +
                        ", Batería: " + moto.getBateria() + "%" +
                        ", Averías: " + (moto.getAverias() ? "Sí" : "No") + "\n");
            }
        }

        int idMoto = UtilidadesEntradaDatos.getEnteroPositivo("Introduce el ID de la moto", 1, Integer.MAX_VALUE);
        int nuevaX = UtilidadesEntradaDatos.getEnteroPositivo("Introduce la coordenada X", 0, servicioGestionVehiculos.getMaxCoordenadaX());
        int nuevaY = UtilidadesEntradaDatos.getEnteroPositivo("Introduce la coordenada Y", 0, servicioGestionVehiculos.getMaxCoordenadaY());

        boolean resultado = servicioGestionVehiculos.moverVehiculoACoordenadas(idMoto, nuevaX, nuevaY);

        if (resultado) {
            System.out.println("Moto movida exitosamente. Mostrando mapa actualizado:");
            servicioGestionVehiculos.dibujarMapa();
        } else {
            System.out.println("No se pudo mover la moto a las nuevas coordenadas.");
        }
    }

    // Mover bicicleta o patinete a una nueva base
    private void moverVehiculoANuevaBase() {
        System.out.println("\n--- Mover Vehículo a Nueva Base ---");

        List<Vehiculo> vehiculosEnBases = servicioGestionVehiculos.getVehiculosEnBases();
        List<Vehiculo> vehiculosAlmacenados = servicioGestionVehiculos.getVehiculosAlmacenados();

        boolean hayVehiculosParaMover = false;

        System.out.println("\nVehículos en bases disponibles para mover:");
        for (Vehiculo vehiculo : vehiculosEnBases) {
            if (vehiculo instanceof VehiculoDeBase vehiculoDeBase) {
                Base baseActual = vehiculoDeBase.getBase();
                System.out.print("ID: " + vehiculo.getID() +
                        ", Tipo: " + vehiculo.getVehiculoEnum() +
                        ", Base actual: " + (baseActual != null ? baseActual.getNombre() : "Sin base") +
                        ", Batería: " + vehiculo.getBateria() + "%" +
                        ", Averías: " + (vehiculo.getAverias() ? "Sí" : "No") + "\n");
                hayVehiculosParaMover = true;
            }
        }

        System.out.println("\nVehículos en almacén disponibles para mover:");
        for (Vehiculo vehiculo : vehiculosAlmacenados) {
            if (vehiculo instanceof VehiculoDeBase) {
                System.out.print("ID: " + vehiculo.getID() +
                        ", Tipo: " + vehiculo.getVehiculoEnum() +
                        ", Ubicación: Almacén" +
                        ", Batería: " + vehiculo.getBateria() + "%" +
                        ", Averías: " + (vehiculo.getAverias() ? "Sí" : "No") + "\n");
                hayVehiculosParaMover = true;
            }
        }

        if (!hayVehiculosParaMover) {
            System.out.println("No hay bicicletas ni patinetes disponibles para mover.");
            return;
        }

        int idVehiculo = UtilidadesEntradaDatos.getEnteroPositivo("Introduce el ID del vehículo", 1, Integer.MAX_VALUE);

        List<Base> bases = servicioGestionVehiculos.getBases();
        if (bases.isEmpty()) {
            System.out.println("No hay bases disponibles en el sistema.");
            return;
        }

        System.out.println("\nBases disponibles:");
        for (Base base : bases) {
            System.out.println("- " + base.getNombre() +
                    " (Coordenadas: " + base.getCoordenadaX() + ", " + base.getCoordenadaY() +
                    ", Espacios libres: " + base.getEspaciosLibres() + ")");
        }

        String nombreBase = UtilidadesEntradaDatos.getStringLongitud("Introduce el nombre de la base", 1, 50);

        boolean resultado = servicioGestionVehiculos.moverVehiculoABase(idVehiculo, nombreBase);

        if (resultado) {
            System.out.println("Vehículo movido exitosamente a la nueva base.");
        } else {
            System.out.println("No se pudo mover el vehículo a la nueva base.");
        }
    }
}

package Menus.MenuAdmin;

import Enum.VehiculoEnum;
import Utilidades.UtilidadesEntradaDatos;
import Utilidades.UtilidadesMenus;

public class MenuGestionViajesYTarifas {

    private final ServicioGestionViajesYTarifas servicioGestionViajesYTarifas;

    public MenuGestionViajesYTarifas() {
        this.servicioGestionViajesYTarifas = new ServicioGestionViajesYTarifas();
    }

    public void mostrarMenu() {
        boolean volver = false;

        while (!volver) {
            System.out.println("\n========== GESTIÓN DE VIAJES Y TARIFAS ==========");
            System.out.println("1. Configuración de Reservas");
            System.out.println("2. Configuración de Baterías");
            System.out.println("3. Modificar Tarifa");
            System.out.println("4. Modificar Descuento");
            System.out.println("5. Volver al menú principal");

            System.out.print("\nSeleccione opción: ");
            int opcion = UtilidadesEntradaDatos.getEnteroPositivo("Selecciona una opción", 1, 5);

            try {
                switch (opcion) {
                    case 1 -> modificarReservas();
                    case 2 -> modificarBaterias();
                    case 3 -> modificarTarifa();
                    case 4 -> modificarDescuento();
                    case 5 -> volver = true;
                    default -> System.out.println("Opción no válida. Por favor, selecciona una opción del menú.");
                }
            } catch (Exception e) {
                System.out.println("Error: " + e.getMessage());
            }
        }
    }

    private void modificarTarifa() {
        System.out.println("\n--- Modificación de tarifa ---");

        System.out.println("\nTarifas actuales:");
        for (VehiculoEnum tipo : VehiculoEnum.values()) {
            double tarifa = servicioGestionViajesYTarifas.getTarifa(tipo);
            System.out.printf("%s: %.2f€ por hora\n", tipo, tarifa);
        }

        System.out.print("\nSelecciona el vehículo cuya tarifa se va a modificar: ");
        VehiculoEnum tipoVehiculo = UtilidadesMenus.seleccionarTipoVehiculo();

        double tarifa = servicioGestionViajesYTarifas.getTarifa(tipoVehiculo);
        System.out.printf("La tarifa actual para %s es: %.2f€ por hora\n", tipoVehiculo, tarifa);

        System.out.print("Introduce la nueva tarifa en euros por hora: ");
        double nuevaTarifa = UtilidadesEntradaDatos.getDecimalPositivo("Introduce la nueva tarifa", 0.01, Double.MAX_VALUE);

        boolean resultado = servicioGestionViajesYTarifas.modificarTarifa(tipoVehiculo, nuevaTarifa);

        if (!resultado) {
            System.out.println("No se pudo modificar la tarifa. Asegúrate de que el valor sea válido.");
        }
    }

    private void modificarDescuento() {
        System.out.println("\n--- Modificación de descuento ---");

        System.out.println("\nDescuentos actuales:");
        for (VehiculoEnum tipo : VehiculoEnum.values()) {
            double descuento = servicioGestionViajesYTarifas.getDescuento(tipo);
            System.out.printf("%s: %.0f%%\n", tipo, descuento);
        }

        System.out.print("\nSelecciona el vehículo cuyo descuento se va a modificar: ");
        VehiculoEnum tipoVehiculo = UtilidadesMenus.seleccionarTipoVehiculo();

        double descuentoActual = servicioGestionViajesYTarifas.getDescuento(tipoVehiculo);
        System.out.printf("El descuento actual para %s es: %.0f%%\n", tipoVehiculo, descuentoActual);

        System.out.print("Introduce el nuevo descuento en %: ");
        double nuevoDescuento = UtilidadesEntradaDatos.getDecimalPositivo("Introduce el nuevo descuento", 0, 100);

        if (nuevoDescuento < 0 || nuevoDescuento > 100) {
            System.out.println("Error: El descuento debe estar entre 0 y 100 por ciento.");
            return;
        }

        boolean resultado = servicioGestionViajesYTarifas.modificarDescuento(tipoVehiculo, nuevoDescuento);

        if (!resultado) {
            System.out.println("No se pudo modificar el descuento. Asegúrate de que el valor sea válido.");
        }
    }

    private void modificarReservas() {
        System.out.println("\n--- Modificación de reservas ---");

        boolean estadoActual = servicioGestionViajesYTarifas.getReservasPermitidas();
        System.out.println("Estado actual: Las reservas están " +
                (estadoActual ? "HABILITADAS" : "DESHABILITADAS") + ".");

        System.out.println("Qué deseas hacer");
        if (estadoActual) {
            System.out.print("Deseas deshabilitar las reservas (1 Sí, 2 No) ");
            int opcion = UtilidadesEntradaDatos.getEnteroPositivo("Selecciona una opción", 1, 2);
            if (opcion == 1) {
                servicioGestionViajesYTarifas.setReservasPermitidas(false);
                System.out.println("Las reservas han sido deshabilitadas correctamente.");
            } else {
                System.out.println("No se han realizado cambios. Las reservas siguen habilitadas.");
            }
        } else {
            System.out.print("Deseas habilitar las reservas (1 Sí, 2 No) ");
            int opcion = UtilidadesEntradaDatos.getEnteroPositivo("Selecciona una opción", 1, 2);
            if (opcion == 1) {
                servicioGestionViajesYTarifas.setReservasPermitidas(true);
                System.out.println("Las reservas han sido habilitadas correctamente.");
            } else {
                System.out.println("No se han realizado cambios. Las reservas siguen deshabilitadas.");
            }
        }
    }

    private void modificarBaterias() {
        System.out.println("\n--- Modificación de batería ---");
        System.out.print("Deseas habilitar o deshabilitar la batería premium (1 Habilitar, 2 Deshabilitar) ");
        int opcion = UtilidadesEntradaDatos.getEnteroPositivo("Selecciona una opción", 1, 2);
        if (opcion == 1) {
            servicioGestionViajesYTarifas.setBateriaPremiumPermitida(true);
            System.out.println("La batería premium ha sido habilitada correctamente.");
        } else if (opcion == 2) {
            servicioGestionViajesYTarifas.setBateriaPremiumPermitida(false);
            System.out.println("La batería premium ha sido deshabilitada correctamente.");
        } else {
            System.out.println("Opción no válida. Por favor, selecciona 1 o 2.");
        }
    }
}

package Menus.MenuAdmin;

import Enum.VehiculoEnum;
import GestorPersonas.GestorPersonas;
import GestorPersonas.Personas.Mantenimiento;
import GestorPersonas.Personas.Mecanico;
import GestorPersonas.Personas.Persona;
import GestorPersonas.Personas.Usuario;
import GestorVehiculosBases.Facturas.FacturaReparacionVehiculo;
import GestorVehiculosBases.GestorBases;
import GestorVehiculosBases.GestorVehiculos;
import GestorVehiculosBases.Localizaciones.Base;
import GestorVehiculosBases.Localizaciones.Mapa;
import GestorVehiculosBases.Vehiculos.Vehiculo;
import GestorViajes.GestorViajes;
import GestorViajes.Viaje;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ServicioConsultas {

    // ===========================
    // ATRIBUTOS Y CONSTRUCTOR
    // ===========================

    // Instancias de gestores principales
    private final GestorPersonas gestorPersonas;
    private final GestorVehiculos gestorVehiculos;
    private final GestorViajes gestorViajes;
    private final GestorBases gestorBases;
    private final Mapa mapa;

    // Constructor: inicializa los gestores
    public ServicioConsultas() {
        this.gestorPersonas = GestorPersonas.getInstancia();
        this.gestorVehiculos = GestorVehiculos.getInstancia();
        this.gestorViajes = GestorViajes.getInstancia();
        this.gestorBases = GestorBases.getInstancia();
        this.mapa = Mapa.getInstancia();
    }

    // ===========================
    // CONSULTAS BÁSICAS SOBRE VEHÍCULOS
    // ===========================

    // Devuelve la lista de todos los vehículos
    public List<Vehiculo> obtenerVehiculos() {
        // Llama al gestor de vehículos para obtener la lista
        return gestorVehiculos.getListaVehiculos();
    }

    // Devuelve los vehículos que tienen averías
    public List<Vehiculo> obtenerVehiculosConAverias() {
        List<Vehiculo> resultado = new ArrayList<>();
        // Recorre todos los vehículos y añade los que tienen avería
        for (Vehiculo v : gestorVehiculos.getListaVehiculos()) {
            if (v.getAverias()) resultado.add(v); // Si tiene avería, añadir a la lista
        }
        return resultado;
    }

    // ===========================
    // CONSULTAS SOBRE BASES
    // ===========================

    // Devuelve la lista de todas las bases
    public List<Base> obtenerBases() {
        // Llama al mapa para obtener la lista de bases
        return mapa.getListaBases();
    }

    // Devuelve las bases ordenadas por viajes iniciados
    public List<Base> obtenerBasesOrdenadasPorViajesIniciados() {
        List<Base> bases = new ArrayList<>(mapa.getListaBases());
        // Ordena las bases por viajes iniciados (descendente)
        bases.sort((b1, b2) -> Integer.compare(b2.getViajesIniciadosEnBase(), b1.getViajesIniciadosEnBase()));
        return bases;
    }

    // Devuelve las bases ordenadas por viajes finalizados
    public List<Base> obtenerBasesOrdenadasPorViajesFinalizados() {
        List<Base> bases = new ArrayList<>(mapa.getListaBases());
        // Ordena las bases por viajes finalizados (descendente)
        bases.sort((b1, b2) -> Integer.compare(b2.getViajesFinalizadosEnBase(), b1.getViajesFinalizadosEnBase()));
        return bases;
    }

    // ===========================
    // CONSULTAS SOBRE PERSONAS Y USUARIOS
    // ===========================

    // Devuelve la lista de personas ordenadas por DNI
    public List<Persona> obtenerPersonasOrdenadasPorDNI() {
        List<Persona> lista = new ArrayList<>(gestorPersonas.getPersonas());
        // Ordena la lista por DNI
        lista.sort(Comparator.comparing(Persona::getDNI));
        return lista;
    }

    // Devuelve la lista de usuarios
    public List<Usuario> obtenerUsuarios() {
        List<Usuario> usuarios = new ArrayList<>();
        // Añade solo las personas que son usuarios
        for (var p : gestorPersonas.getPersonas()) {
            if (p instanceof Usuario u) usuarios.add(u); // Solo añade si es Usuario
        }
        return usuarios;
    }

    // Devuelve el historial de viajes de un usuario
    public List<Viaje> obtenerViajesUsuario(Usuario usuario) {
        // Devuelve la lista de viajes del usuario
        return usuario.getHistorialViajes();
    }

    // ===========================
    // CONSULTAS SOBRE VIAJES
    // ===========================

    // Devuelve los vehículos que están en uso actualmente
    public List<Vehiculo> obtenerVehiculosEnUsoActual() {
        // Llama al gestor de viajes para obtener los vehículos en uso
        return gestorViajes.obtenerVehiculosEnUsoActual();
    }

    // Devuelve los viajes realizados en un periodo de tiempo
    public List<Viaje> obtenerViajesEnPeriodo(long inicio, long fin) {
        List<Viaje> resultado = new ArrayList<>();
        // Recorre todos los viajes y añade los que están en el periodo
        for (Viaje v : gestorViajes.getListaTodosViajes()) {
            long tInicio = v.getTiempoInicio();
            long tFin = (v.getTiempoFin() == 0) ? System.currentTimeMillis() : v.getTiempoFin();
            if (tFin >= inicio && tInicio <= fin) resultado.add(v); // Si el viaje está en el periodo, añadir
        }
        return resultado;
    }

    // Devuelve la lista de todos los viajes
    public List<Viaje> obtenerTodosViajes() {
        // Llama al gestor de viajes para obtener la lista completa
        return gestorViajes.getListaTodosViajes();
    }

    // ===========================
    // CONSULTAS AVANZADAS Y RANKINGS
    // ===========================

    // Devuelve un mapa con las reparaciones por vehículo en un periodo
    public Map<Integer, List<FacturaReparacionVehiculo>> obtenerReparacionesPorVehiculoEnPeriodo(LocalDate fechaInicio, LocalDate fechaFin) {
        var personas = gestorPersonas.getPersonas();
        List<Mecanico> mecanicos = new ArrayList<>();
        // Filtra solo los mecánicos
        for (var p : personas) {
            if (p instanceof Mecanico m) {
                mecanicos.add(m); // Añade solo mecánicos
            }
        }
        Map<Integer, List<FacturaReparacionVehiculo>> reparacionesPorVehiculo = new HashMap<>();
        // Recorre las reparaciones de cada mecánico
        for (Mecanico mecanico : mecanicos) {
            for (FacturaReparacionVehiculo factura : mecanico.getReparacionesVehiculosRealizadas()) {
                LocalDate fecha = factura.getFecha();
                // Comprueba si la fecha está en el rango
                if ((fecha.isEqual(fechaInicio) || fecha.isAfter(fechaInicio)) &&
                    (fecha.isEqual(fechaFin) || fecha.isBefore(fechaFin))) {
                    int idVehiculo = factura.getVehiculo().getID();
                    reparacionesPorVehiculo.computeIfAbsent(idVehiculo, k -> new ArrayList<>()).add(factura);
                }
            }
        }
        return reparacionesPorVehiculo;
    }

    // Devuelve el ranking de intervenciones de mecánicos y mantenimiento
    public List<Object[]> obtenerRankingIntervenciones() {
        var personas = gestorPersonas.getPersonas();
        List<Object[]> ranking = new ArrayList<>();
        // Añade mecánicos y mantenimiento al ranking
        for (var p : personas) {
            if (p instanceof Mecanico m) {
                // Añade mecánico al ranking
                ranking.add(new Object[]{
                    m.getNombre() + " " + m.getApellidos(),
                    "Mecánico",
                    m.getIntervencionesRealizadas()
                });
            } else if (p instanceof Mantenimiento mt) {
                // Añade mantenimiento al ranking
                ranking.add(new Object[]{
                    mt.getNombre() + " " + mt.getApellidos(),
                    "Mantenimiento",
                    mt.getIntervencionesRealizadas()
                });
            }
        }
        // Ordena por intervenciones realizadas (descendente)
        ranking.sort((a, b) -> Integer.compare((int) b[2], (int) a[2]));
        return ranking;
    }

    // Devuelve un mapa de vehículos agrupados por tipo y ordenados por tiempo de uso
    public Map<VehiculoEnum, List<Object[]>> obtenerVehiculosPorTiempoUso() {
        List<Vehiculo> vehiculos = obtenerVehiculos();
        List<Viaje> viajes = obtenerTodosViajes();
        Map<Integer, Long> tiempoUsoPorVehiculo = new HashMap<>();
        // Inicializa el tiempo de uso en 0 para cada vehículo
        for (Vehiculo v : vehiculos) {
            tiempoUsoPorVehiculo.put(v.getID(), 0L);
        }
        // Suma el tiempo de uso de cada viaje finalizado
        for (Viaje viaje : viajes) {
            if (viaje.getTiempoFin() > 0) {
                int id = viaje.getVehiculo().getID();
                long duracion = viaje.getTiempoFin() - viaje.getTiempoInicio();
                tiempoUsoPorVehiculo.put(id, tiempoUsoPorVehiculo.getOrDefault(id, 0L) + duracion);
            }
        }
        Map<VehiculoEnum, List<Object[]>> resultado = new HashMap<>();
        // Agrupa vehículos por tipo y añade el tiempo de uso
        for (Vehiculo v : vehiculos) {
            VehiculoEnum tipo = v.getVehiculoEnum();
            resultado.computeIfAbsent(tipo, k -> new ArrayList<>())
                .add(new Object[]{v, tiempoUsoPorVehiculo.getOrDefault(v.getID(), 0L)});
        }
        // Ordena cada lista por tiempo de uso descendente
        for (List<Object[]> lista : resultado.values()) {
            lista.sort((a, b) -> Long.compare((Long) b[1], (Long) a[1]));
        }
        return resultado;
    }

    // Devuelve los usuarios ordenados por gasto en un periodo
    public List<Object[]> obtenerUsuariosPorGastoEnPeriodo(long inicio, long fin) {
        List<Usuario> usuarios = obtenerUsuarios();
        List<Object[]> resultado = new ArrayList<>();
        // Calcula el gasto de cada usuario en el periodo
        for (Usuario usuario : usuarios) {
            double gasto = 0.0;
            // Suma el costo de los viajes del usuario en el periodo
            for (Viaje viaje : usuario.getHistorialViajes()) {
                if (viaje.getTiempoFin() > 0 && viaje.getTiempoFin() >= inicio && viaje.getTiempoInicio() <= fin) {
                    gasto += viaje.getCosto();
                }
            }
            resultado.add(new Object[]{usuario, gasto});
        }
        // Ordena por gasto descendente
        resultado.sort((a, b) -> Double.compare((double) b[1], (double) a[1]));
        return resultado;
    }
}
package Menus.MenuAdmin;

import GestorVehiculosBases.GestorBases;
import GestorVehiculosBases.Localizaciones.Mapa;

public class ServicioGestionBases {
    private final GestorBases gestorBases;
    private final Mapa mapa;

    public ServicioGestionBases() {
        this.gestorBases = GestorBases.getInstancia();
        this.mapa = Mapa.getInstancia();
    }

    public boolean existeBasePorNombre(String nombreBase) {
        return mapa.getBasePorNombre(nombreBase) != null;
    }

    public boolean coordenadasValidasYLibres(int coordX, int coordY) {
        return mapa.sonCoordenadasValidas(coordX, coordY) && !mapa.sonCoordenadasOcupadas(coordX, coordY);
    }

    public boolean altaBasePorCoordenadas(String nombreBase, int coordX, int coordY, int capacidad) {
        return gestorBases.addBasePorCoordenadas(nombreBase, coordX, coordY, capacidad);
    }

    public boolean existeBaseEnCoordenadas(int coordX, int coordY) {
        return mapa.getContenidoCelda(coordX, coordY) != null;
    }

    public boolean bajaBasePorCoordenadas(int coordX, int coordY) {
        return gestorBases.removeBasePorCoordenadas(coordX, coordY);
    }

    public boolean bajaBasePorNombre(String nombreBase) {
        return gestorBases.removeBasePorNombre(nombreBase);
    }

    public void dibujarMapa() {
        mapa.dibujarMapa();
    }

    public int getMaxCoordenadaX() {
        return mapa.getMaxCoordenadaX();
    }

    public int getMaxCoordenadaY() {
        return mapa.getMaxCoordenadaY();
    }
}
package Menus.MenuAdmin;

import GestorPersonas.GestorPersonas;
import GestorVehiculosBases.GestorVehiculos;
import GestorVehiculosBases.GestorBases;

public class ServicioGestionEmpleados {

    private final GestorPersonas gestorPersonas;
    private final GestorVehiculos gestorVehiculos;
    private final GestorBases gestorBases;

    public ServicioGestionEmpleados() {
        this.gestorPersonas = GestorPersonas.getInstancia();
        this.gestorVehiculos = GestorVehiculos.getInstancia();
        this.gestorBases = GestorBases.getInstancia();
    }

    public boolean asignarVehiculoSinBateria(String dni, int idVehiculo) {
        return gestorVehiculos.asignarMantenimientoBateriaBaja(dni, idVehiculo);
    }

    public boolean asignarVehiculoPorAveria(String dniMantenimiento, String dniMecanico, int idVehiculo) {
        return gestorVehiculos.asignarMantenimientoYMecanicoAveria(dniMantenimiento, dniMecanico, idVehiculo);
    }

    public boolean asignarBasePorAveria(String dniMecanico, String nombreBase) {
        return gestorBases.asignarMecanicoAveriaBase(dniMecanico, nombreBase);
    }
}
package Menus.MenuAdmin;

import Enum.RolEnum;
import GestorPersonas.GestorPersonas;
import GestorPersonas.GestorPromocion;
import GestorPersonas.Personas.Persona;
import GestorPersonas.Personas.Usuario;
import GestorViajes.GestorViajes;
import Utilidades.UtilidadesMenus;
import java.util.Map;

public class ServicioGestionPersonas {

    private final GestorPersonas gestorPersonas;
    private final GestorViajes gestorViajes;
    private final UtilidadesMenus utilsMenu;

    public ServicioGestionPersonas() {
        this.gestorPersonas = GestorPersonas.getInstancia();
        this.gestorViajes = GestorViajes.getInstancia();
        this.utilsMenu = new UtilidadesMenus();
    }

    public void altaUsuario(String nombre, String apellidos, String dni, RolEnum rolEnum) {
        gestorPersonas.addPersona(nombre, apellidos, dni, rolEnum);
    }

    public boolean bajaUsuario(String dni) {
        return gestorPersonas.removePersona(dni);
    }

    public boolean existeDNI(String dni) {
        return gestorPersonas.existeDNI(dni);
    }

    public Persona getPersonaPorDNI(String dni) {
        return gestorPersonas.getPersonaPorDNI(dni);
    }

    public void modificarPersona(String dni, String nuevoNombre, String nuevosApellidos, RolEnum rolEnum) {
        gestorPersonas.modificarPersona(dni, nuevoNombre, nuevosApellidos, rolEnum);
    }

    public void mostrarUsuariosPromocion() {
        GestorPromocion.getInstancia().mostrarUsuariosPromocion();
    }

    public boolean cambiarRolUsuario(String dni, boolean aPremium) {
        return gestorPersonas.cambiarRolUsuario(dni, aPremium);
    }

    public Map<String, Object> obtenerDetallesPromocionUsuario(Usuario usuario) {
        return GestorPromocion.getInstancia().obtenerDetallesPromocionUsuario(usuario);
    }

    public void buscarPersonaPorDNI() {
        gestorPersonas.buscarPersonaPorDNI();
    }

    public void buscarPersonaPorNombre() {
        gestorPersonas.buscarPersonaPorNombre();
    }

    public void buscarPersonaPorApellido() {
        gestorPersonas.buscarPersonaPorApellido();
    }

    public void filtrarPersonasPorRol() {
        gestorPersonas.filtrarPersonasPorRol();
    }

    public RolEnum seleccionarRol() {
        return utilsMenu.seleccionarRol();
    }
}
package Menus.MenuAdmin;

import Enum.VehiculoEnum;
import GestorVehiculosBases.GestorBases;
import GestorVehiculosBases.GestorVehiculos;
import GestorVehiculosBases.Localizaciones.Base;
import GestorVehiculosBases.Localizaciones.Mapa;
import GestorVehiculosBases.Vehiculos.MotoGrande;
import GestorVehiculosBases.Vehiculos.MotoPequena;
import GestorVehiculosBases.Vehiculos.Vehiculo;
import GestorVehiculosBases.Vehiculos.VehiculoDeBase;
import java.util.List;

public class ServicioGestionVehiculos {

    private final GestorVehiculos gestorVehiculos;
    private final GestorBases gestorBases;
    private final Mapa mapa;

    public ServicioGestionVehiculos() {
        this.gestorVehiculos = GestorVehiculos.getInstancia();
        this.gestorBases = GestorBases.getInstancia();
        this.mapa = Mapa.getInstancia();
    }

    public Vehiculo altaVehiculoMapa(VehiculoEnum tipoMoto, int x, int y) {
        return gestorVehiculos.addVehiculoMapa(tipoMoto, x, y);
    }

    public Vehiculo altaVehiculoBase(VehiculoEnum tipoVehiculo, String nombreBase) {
        Base base = mapa.getBasePorNombre(nombreBase);
        if (base == null) return null;
        return gestorVehiculos.addVehiculoBase(tipoVehiculo, base);
    }

    public Vehiculo altaVehiculoAlmacen(VehiculoEnum tipoVehiculo) {
        return gestorVehiculos.addVehiculoAlmacen(tipoVehiculo);
    }

    public boolean bajaVehiculo(int idVehiculo) {
        return gestorVehiculos.desecharVehiculoPorID(idVehiculo);
    }

    public List<Base> getBases() {
        return mapa.getListaBases();
    }

    public List<Vehiculo> getMotosEnMapa() {
        return gestorVehiculos.getVehiculosEnMapa();
    }

    public List<Vehiculo> getVehiculosEnBases() {
        return gestorVehiculos.getVehiculosEnBases();
    }

    public List<Vehiculo> getVehiculosAlmacenados() {
        return gestorVehiculos.getListaVehiculosAlmacenados();
    }

    public Vehiculo getVehiculoPorID(int idVehiculo) {
        return gestorVehiculos.getVehiculoPorID(idVehiculo);
    }

    public boolean moverVehiculoACoordenadas(int idVehiculo, int x, int y) {
        return gestorVehiculos.moverVehiculoACoordenadas(idVehiculo, x, y);
    }

    public boolean moverVehiculoABase(int idVehiculo, String nombreBase) {
        return gestorVehiculos.moverVehiculoABase(idVehiculo, nombreBase);
    }

    public int getMaxCoordenadaX() {
        return mapa.getMaxCoordenadaX();
    }

    public int getMaxCoordenadaY() {
        return mapa.getMaxCoordenadaY();
    }

    public void dibujarMapa() {
        mapa.dibujarMapa();
    }
}
package Menus.MenuAdmin;

import Enum.VehiculoEnum;
import GestorViajes.Beneficios;
import GestorViajes.GestorViajes;
import GestorViajes.TarifasYDescuentos;

public class ServicioGestionViajesYTarifas {

    private final GestorViajes gestorViajes;
    private final TarifasYDescuentos tarifasYDescuentos;
    private final Beneficios beneficios;

    public ServicioGestionViajesYTarifas() {
        this.gestorViajes = GestorViajes.getInstancia();
        this.tarifasYDescuentos = new TarifasYDescuentos();
        this.beneficios = new Beneficios();
    }

    public double getTarifa(VehiculoEnum tipo) {
        return tipo.getTarifa();
    }

    public boolean modificarTarifa(VehiculoEnum tipo, double nuevaTarifa) {
        return tarifasYDescuentos.modificarTarifa(tipo, nuevaTarifa);
    }

    public double getDescuento(VehiculoEnum tipo) {
        return tipo.getDescuento();
    }

    public boolean modificarDescuento(VehiculoEnum tipo, double nuevoDescuento) {
        return tarifasYDescuentos.modificarDescuento(tipo, nuevoDescuento);
    }

    public boolean getReservasPermitidas() {
        return beneficios.getReservasPermitidas();
    }

    public void setReservasPermitidas(boolean permitido) {
        Beneficios.setReservasPermitidas(permitido);
    }

    public void setBateriaPremiumPermitida(boolean permitido) {
        Beneficios.setBateriaPremiumPermitida(permitido);
    }
}
package Menus;

import GestorPersonas.GestorPersonas;
import GestorPersonas.Personas.Administrador;
import GestorPersonas.Personas.Mantenimiento;
import GestorPersonas.Personas.Mecanico;
import GestorPersonas.Personas.Persona;
import GestorPersonas.Personas.Usuario;
import Menus.MenuAdmin.MenuAdministrador;
import Utilidades.UtilidadesEntradaDatos;

public class Menu {

    //=================================================
    // ATRIBUTOS
    //=================================================
    // Gestores del sistema
    private GestorPersonas gestorPersonas;

    // Submenús específicos por rol
    private MenuAdministrador menuAdministrador;
    private MenuMecanico menuMecanico;
    private MenuMantenimiento menuMantenimiento;
    private MenuUsuario menuUsuario;

    //=================================================
    // CONSTRUCTOR
    //=================================================
    // Constructor
    public Menu() {
        this.menuAdministrador = new MenuAdministrador();
        this.menuMecanico = new MenuMecanico();
        this.menuMantenimiento = new MenuMantenimiento();
        this.menuUsuario = new MenuUsuario();
        this.gestorPersonas = GestorPersonas.getInstancia();
    }

    //=================================================
    // MENÚ PRINCIPAL
    //=================================================
    // Método para iniciar el menú principal
    public void iniciar() {
        while (true) {

            System.out.println("\n--------------------------------------------------");
            System.out.println("NOTA IMPORTANTE:");
            System.out.println("- En todas las inicializaciones, puedes acceder al sistema con el Super User:");
            System.out.println("    DNI: 00000000A");
            System.out.println("    Rol: ADMINISTRADOR");
            System.out.println("- Si el sistema se ha inicializado por semilla o manualmente, también estarán disponibles estos registros:");
            System.out.println("    Administradores: 8 dígitos seguidos de 'A' (ejemplo: 00000001A, 00000002A, etc.)");
            System.out.println("    Mantenimiento:   8 dígitos seguidos de 'T' (ejemplo: 00000001T, 00000002T, etc.)");
            System.out.println("    Mecánicos:       8 dígitos seguidos de 'M' (ejemplo: 00000001M, 00000002M, etc.)");
            System.out.println("    Usuarios estándar: 8 dígitos seguidos de 'S' (ejemplo: 00000001S, 00000002S, etc.)");
            System.out.println("- No hay usuarios premium por defecto, pero los usuarios estándar pueden ascender a premium si alcanzan el número de viajes requerido.");
            System.out.println("--------------------------------------------------");

            System.out.println("\n========== SISTEMA DE MOVILIDAD ==========");
            System.out.println("Por favor, identifícate para acceder al sistema");
            String DNI = UtilidadesEntradaDatos.getDNI("Introduce tu DNI (sin espacios ni caracteres especiales): ");
            
            if (!gestorPersonas.existeDNI(DNI)) {
                System.out.println("Error: No existe ningún usuario con el DNI proporcionado.");
                continue;
            }
            if (!gestorPersonas.esDNIValido(DNI)) {
                System.out.println("Error: El DNI introducido no es válido.");
                continue;
            }
            
            Persona persona = gestorPersonas.getPersonaPorDNI(DNI);
            if (persona == null) {
                System.out.println("Error: No se encontró ningún usuario con los datos proporcionados.");
                continue;
            }

            System.out.println("¡Bienvenido/a, " + persona.getNombre() + " " + persona.getApellidos() + "!");
            System.out.println("Accediendo al sistema como: " + persona.getRol());

            switch (persona.getRol()) {
                case ADMINISTRADOR:
                    menuAdministrador.mostrarMenu((Administrador) persona);
                    break;
                case MECANICO:
                    menuMecanico.mostrarMenu((Mecanico) persona);
                    break;
                case MANTENIMIENTO:
                    menuMantenimiento.mostrarMenu((Mantenimiento) persona);
                    break;
                case USUARIO_STANDARD:
                    menuUsuario.mostrarMenu((Usuario) persona);
                    break;
                case USUARIO_PREMIUM:
                    menuUsuario.mostrarMenu((Usuario) persona);
                    break;
                default:
                    System.out.println("Error: Rol no reconocido: " + persona.getRol());
            }
        }
    }
}


package Menus;

import GestorPersonas.Personas.Mantenimiento;
import Utilidades.UtilidadesEntradaDatos;

public class MenuMantenimiento {

    Mantenimiento mantenimiento;
    private final ServicioMantenimiento servicioMantenimiento;

    public MenuMantenimiento() {
        this.servicioMantenimiento = new ServicioMantenimiento();
    }

    public void mostrarMenu(Mantenimiento mantenimiento) {
        this.mantenimiento = mantenimiento;
        while (true) {
            System.out.println("\n========== MENÚ MANTENIMIENTO ==========");
            System.out.println("1. Ver vehículos asignados");
            System.out.println("2. Realizar mantenimiento");
            System.out.println("3. Reservar (desactivar) vehículo");
            System.out.println("4. Cerrar sesión");

            int opcion = UtilidadesEntradaDatos.getEnteroPositivo("Selecciona una opción", 1, 4);

            switch (opcion) {
                case 1:
                    servicioMantenimiento.verVehiculosAsignados(mantenimiento);
                    break;
                case 2:
                    servicioMantenimiento.realizarMantenimiento(mantenimiento);
                    break;
                case 3:
                    servicioMantenimiento.desactivarVehiculo();
                    break;
                case 4:
                    return;
                default:
                    System.out.println("Opción no válida. Por favor, seleccione una opción del menú.");
            }
        }
    }
}

package Menus;

import GestorPersonas.Personas.Mecanico;
import Utilidades.UtilidadesEntradaDatos;

public class MenuMecanico {

    private Mecanico mecanico;
    private final ServicioMecanico servicioMecanico;

    public MenuMecanico() {
        this.servicioMecanico = new ServicioMecanico();
    }

    public void mostrarMenu(Mecanico mecanico) {
        this.mecanico = mecanico;
        servicioMecanico.setMecanico(mecanico);
        while (true) {
            System.out.println("\n========== MENÚ MECÁNICO ==========");

            // GESTIÓN DE REPARACIONES
            System.out.println("\n--- GESTIÓN DE REPARACIONES ---");
            System.out.println("1. Ver vehículos asignados | 2. Reparar vehículo");

            // GESTIÓN DE BASES
            System.out.println("\n--- GESTIÓN DE BASES ---");
            System.out.println("3. Ver bases asignadas | 4. Reparar base");

            // SISTEMA
            System.out.println("\n5. Cerrar Sesión");

            System.out.print("\nSeleccione opción: ");

            int opcion = UtilidadesEntradaDatos.getEnteroPositivo("Selecciona una opción", 1, 6);

            switch (opcion) {
                case 1:
                    servicioMecanico.verVehiculosYBasesAsignados();
                    break;
                case 2:
                    servicioMecanico.realizarReparacionVehiculo();
                    break;
                case 3:
                    servicioMecanico.verVehiculosYBasesAsignados();
                    break;
                case 4:
                    servicioMecanico.realizarReparacionBase();
                    break;
                case 5:
                    return;
                default:
                    System.out.println("Opción no válida. Por favor, seleccione una opción del menú.");
            }
        }
    }
}

package Menus;

import Enum.VehiculoEnum;
import GestorPersonas.Personas.Usuario;
import GestorVehiculosBases.Localizaciones.Base;
import GestorVehiculosBases.Vehiculos.Vehiculo;
import GestorVehiculosBases.Vehiculos.VehiculoDeBase;
import GestorVehiculosBases.Vehiculos.VehiculoDeCoordenadas;
import GestorViajes.Beneficios;
import GestorViajes.Viaje;
import Utilidades.UtilidadesEntradaDatos;

public class MenuUsuario {

    private final ServicioUsuario servicioUsuario = new ServicioUsuario();

    public MenuUsuario() {}

    public void mostrarMenu(Usuario usuario) {
        while (true) {
            System.out.println("\n========== MENÚ USUARIO ==========");
            System.out.println("Usuario: " + usuario.getNombre() + " " + usuario.getApellidos() +
                              " | Tipo: " + usuario.getRol());

            System.out.println("1. Submenú - Iniciar Viaje (con Información Vehículos Disponibles)");
            System.out.println("2. Submenú - Finalizar viaje (con Información del Viaje Activo)");
            System.out.println("3. Submenú - Reportar fallo");
            System.out.println("4. Ver historial de viajes realizados");
            System.out.println("5. Submenú - Saldo");
            System.out.println("6. Buscar vehículo más cercano");
            boolean esPremium = usuario instanceof GestorPersonas.Personas.Premium;
            if (esPremium) {
                System.out.println("7. Reservar vehículo");
                System.out.println("8. Cerrar Sesión");
            } else {
                System.out.println("7. Cerrar Sesión");
            }
            System.out.print("\nSeleccione opción: ");

            int maxOpcion = esPremium ? 8 : 7;
            int opcion = UtilidadesEntradaDatos.getEnteroPositivo("Selecciona una opción", 1, maxOpcion);

            switch (opcion) {
                case 1 -> mostrarSubmenuViajes(usuario);
                case 2 -> mostrarSubmenuInformacionFinalizar(usuario);
                case 3 -> mostrarSubmenuReportarFallo(usuario);
                case 4 -> servicioUsuario.mostrarHistorialViajes(usuario);
                case 5 -> mostrarSubmenuSaldo(usuario);
                case 6 -> getVehiculoMasCercano(usuario);
                case 7 -> {
                    if (esPremium) {
                        reservarVehiculo(usuario);
                    } else {
                        return;
                    }
                }
                case 8 -> {
                    if (esPremium) return;
                }
                default -> System.out.println("Opción no válida. Por favor, seleccione una opción del menú.");
            }
        }
    }

    // Submenú 1: Viajes (consultar/iniciar)
    private void mostrarSubmenuViajes(Usuario usuario) {
        while (true) {
            System.out.println("\n--- Viajes (consultar/iniciar) ---");
            System.out.println("1. Consulta de vehículos disponibles");
            System.out.println("2. Iniciar viaje bicicleta/patinete");
            System.out.println("3. Iniciar viaje moto");
            System.out.println("4. Volver al menú principal");
            int opcion = UtilidadesEntradaDatos.getEnteroPositivo("Selecciona una opción", 1, 4);
            switch (opcion) {
                case 1 -> servicioUsuario.mostrarConsultaVehiculosDisponibles(usuario);
                case 2 -> iniciarViajeBase(usuario);
                case 3 -> iniciarViajeCoordenadas(usuario);
                case 4 -> { return; }
            }
        }
    }

    // Submenú 2: Información/Finalizar viaje (información primero)
    private void mostrarSubmenuInformacionFinalizar(Usuario usuario) {
        while (true) {
            System.out.println("\n--- Información/Finalizar viaje ---");
            System.out.println("1. Ver información del viaje activo");
            System.out.println("2. Finalizar viaje bicicleta/patinete");
            System.out.println("3. Finalizar viaje moto");
            System.out.println("4. Volver al menú principal");
            int opcion = UtilidadesEntradaDatos.getEnteroPositivo("Selecciona una opción", 1, 4);
            switch (opcion) {
                case 1 -> mostrarInformacionViajeActivo(usuario);
                case 2 -> finalizarViajeBase(usuario);
                case 3 -> finalizarViajeCoordenadas(usuario);
                case 4 -> { return; }
            }
        }
    }

    // Submenú 3: Reportar fallo
    private void mostrarSubmenuReportarFallo(Usuario usuario) {
        while (true) {
            System.out.println("\n--- Reportar fallo ---");
            System.out.println("1. Reportar fallo en vehículo");
            System.out.println("2. Reportar fallo en base");
            System.out.println("3. Volver al menú principal");
            int opcion = UtilidadesEntradaDatos.getEnteroPositivo("Selecciona una opción", 1, 3);
            switch (opcion) {
                case 1 -> reportarFalloVehiculo(usuario);
                case 2 -> reportarFalloBase(usuario);
                case 3 -> { return; }
            }
        }
    }

    private void mostrarSubmenuSaldo(Usuario usuario) {
        while (true) {
            System.out.println("\n--- Saldo ---");
            System.out.println("1. Ver saldo disponible");
            System.out.println("2. Recargar saldo");
            System.out.println("3. Volver al menú principal");
            int opcion = UtilidadesEntradaDatos.getEnteroPositivo("Selecciona una opción", 1, 3);
            switch (opcion) {
                case 1 -> servicioUsuario.mostrarSaldo(usuario);
                case 2 -> recargarSaldo(usuario);
                case 3 -> { return; }
            }
        }
    }

    private void iniciarViajeBase(Usuario usuario) {
        System.out.println("\n--- Iniciar viaje de bicicleta o patinete ---");
        System.out.println("1. Alquilar " + VehiculoEnum.BICICLETA);
        System.out.println("2. Alquilar " + VehiculoEnum.PATINETE);
        int opcionVehiculo = UtilidadesEntradaDatos.getEnteroPositivo("Selecciona el tipo de vehículo", 1, 2);

        VehiculoEnum tipoVehiculo = (opcionVehiculo == 1) ? VehiculoEnum.BICICLETA : VehiculoEnum.PATINETE;

        String nombreBase = UtilidadesEntradaDatos.getStringLongitud("Introduce el nombre de la base", 1, 20);

        servicioUsuario.iniciarViajeBase(usuario, tipoVehiculo, nombreBase);

        Viaje viaje = servicioUsuario.getViajeActivo(usuario);
        if (viaje != null) {
            System.out.println("Viaje iniciado correctamente.");
        } else {
            System.out.println("No se pudo iniciar el viaje.");
        }
    }

    private void iniciarViajeCoordenadas(Usuario usuario) {
        System.out.println("\n--- Iniciar viaje de moto ---");
        System.out.println("1. Alquilar " + VehiculoEnum.MOTOPEQUENA);
        System.out.println("2. Alquilar " + VehiculoEnum.MOTOGRANDE);
        int opcionVehiculo = UtilidadesEntradaDatos.getEnteroPositivo("Selecciona el tipo de moto", 1, 2);

        VehiculoEnum tipoVehiculo = (opcionVehiculo == 1) ? VehiculoEnum.MOTOPEQUENA : VehiculoEnum.MOTOGRANDE;

        int coordX = UtilidadesEntradaDatos.getEnteroPositivo("Introduce la coordenada X", 0, servicioUsuario.getMapa().getMaxCoordenadaX());
        int coordY = UtilidadesEntradaDatos.getEnteroPositivo("Introduce la coordenada Y", 0, servicioUsuario.getMapa().getMaxCoordenadaY());

        servicioUsuario.iniciarViajeCoordenadas(usuario, tipoVehiculo, coordX, coordY);

        Viaje viaje = servicioUsuario.getViajeActivo(usuario);
        if (viaje != null) {
            System.out.println("Viaje de moto iniciado correctamente.");
        } else {
            System.out.println("No se pudo iniciar el viaje de moto.");
        }
    }

    private void finalizarViajeBase(Usuario usuario) {
        String nombreBase = UtilidadesEntradaDatos.getStringLongitud("Introduce el nombre de la base", 1, 20);
        boolean terminado = servicioUsuario.finalizarViajeBase(usuario, nombreBase);
        if (terminado) {
            System.out.println("Viaje finalizado correctamente.");
        } else {
            System.out.println("No se pudo finalizar el viaje.");
        }
    }

    private void finalizarViajeCoordenadas(Usuario usuario) {
        int coordX = UtilidadesEntradaDatos.getEnteroPositivo("Introduce la coordenada X", 0, servicioUsuario.getMapa().getMaxCoordenadaX());
        int coordY = UtilidadesEntradaDatos.getEnteroPositivo("Introduce la coordenada Y", 0, servicioUsuario.getMapa().getMaxCoordenadaY());
        boolean terminado = servicioUsuario.finalizarViajeCoordenadas(usuario, coordX, coordY);
        if (terminado) {
            System.out.println("Viaje de moto finalizado correctamente.");
        } else {
            System.out.println("No se pudo finalizar el viaje de moto.");
        }
    }

    private void mostrarInformacionViajeActivo(Usuario usuario) {
        Viaje viajeActivo = servicioUsuario.getViajeActivo(usuario);
        if (viajeActivo == null) {
            System.out.println("No tienes ningún viaje activo.");
            return;
        }
        GestorViajes.ServicioViajes.getInstancia().mostrarViajeActivo(viajeActivo);
    }

    private void reportarFalloVehiculo(Usuario usuario) {
        int idVehiculo = UtilidadesEntradaDatos.getEnteroPositivo("Introduce el ID del vehículo", 1, Integer.MAX_VALUE);
        Vehiculo vehiculo = servicioUsuario.getGestorVehiculos().getVehiculoPorID(idVehiculo);
        vehiculo.setAverias(true);
        if (vehiculo.getAverias()) {
            System.out.println("Fallo reportado correctamente.");
        } else {
            System.out.println("No se pudo reportar el fallo del vehículo.");
        }
    }

    private void reportarFalloBase(Usuario usuario) {
        String nombreBase = UtilidadesEntradaDatos.getStringLongitud("Introduce el nombre de la base", 1, 20);
        Base base = servicioUsuario.getMapa().getBasePorNombre(nombreBase);
        if (base != null) {
            base.setAverias(true);
            System.out.println("Fallo reportado correctamente en la base " + nombreBase + ".");
        } else {
            System.out.println("No se pudo reportar el fallo de la base. Base no encontrada.");
        }
    }

    public void recargarSaldo(Usuario usuario) {
        double cantidad = UtilidadesEntradaDatos.getDecimalPositivo("Cantidad a recargar", 0.01, Double.MAX_VALUE);
        servicioUsuario.recargarSaldo(usuario, cantidad);
    }

    public void reservarVehiculo(Usuario usuario) {
        Beneficios beneficios = new Beneficios();
        if (!beneficios.getReservasPermitidas()) {
            System.out.println("Las reservas están deshabilitadas actualmente.");
            return;
        }
        servicioUsuario.mostrarConsultaVehiculosDisponibles(usuario);
        int idVehiculo = UtilidadesEntradaDatos.getEnteroPositivo("ID del vehículo", 1, Integer.MAX_VALUE);
        servicioUsuario.reservarVehiculo(usuario, idVehiculo);
    }

    public void getVehiculoMasCercano(Usuario usuario) {
        System.out.println("\n--- Buscar vehículo más cercano ---");
        System.out.println("Selecciona el tipo de vehículo:");
        System.out.println("1. Bicicleta");
        System.out.println("2. Patinete");
        System.out.println("3. Moto pequeña");
        System.out.println("4. Moto grande");
        int opcion = UtilidadesEntradaDatos.getEnteroPositivo("Tipo de vehículo", 1, 4);

        VehiculoEnum tipoVehiculo;
        switch (opcion) {
            case 1 -> tipoVehiculo = VehiculoEnum.BICICLETA;
            case 2 -> tipoVehiculo = VehiculoEnum.PATINETE;
            case 3 -> tipoVehiculo = VehiculoEnum.MOTOPEQUENA;
            case 4 -> tipoVehiculo = VehiculoEnum.MOTOGRANDE;
            default -> {
                System.out.println("Opción no válida.");
                return;
            }
        }

        int coordX = UtilidadesEntradaDatos.getEnteroPositivo("Introduce la coordenada X", 0, servicioUsuario.getMapa().getMaxCoordenadaX());
        int coordY = UtilidadesEntradaDatos.getEnteroPositivo("Introduce la coordenada Y", 0, servicioUsuario.getMapa().getMaxCoordenadaY());

        Vehiculo vehiculoCercano = servicioUsuario.getVehiculoMasCercano(usuario, tipoVehiculo, coordX, coordY);

        if (vehiculoCercano != null) {
            if (tipoVehiculo == VehiculoEnum.BICICLETA || tipoVehiculo == VehiculoEnum.PATINETE) {
                System.out.println("La base más cercana con " + tipoVehiculo + " disponible es: " +
                    ((VehiculoDeBase) vehiculoCercano).getBase().getNombre());
            } else {
                System.out.println("La moto más cercana está en las coordenadas: (" +
                    ((VehiculoDeCoordenadas) vehiculoCercano).getCoordenadaX() + ", " +
                    ((VehiculoDeCoordenadas) vehiculoCercano).getCoordenadaY() + ")");
            }
            System.out.println("ID del vehículo: " + vehiculoCercano.getID());
        } else {
            System.out.println("No se ha encontrado ningún vehículo disponible cercano.");
        }
    }
}

package Menus;

import GestorPersonas.Personas.Mantenimiento;
import GestorVehiculosBases.GestorVehiculos;
import GestorVehiculosBases.Localizaciones.Mapa;
import GestorVehiculosBases.Vehiculos.VehiculoDeBase;
import GestorVehiculosBases.Vehiculos.VehiculoDeCoordenadas;
import GestorViajes.Beneficios;
import Utilidades.UtilidadesEntradaDatos;

public class ServicioMantenimiento {

    public void verVehiculosAsignados(Mantenimiento mantenimiento) {
        if (mantenimiento == null) {
            System.out.println("No hay usuario de mantenimiento activo.");
            return;
        }

        // Tabla para Patinetes y Bicicletas
        System.out.println("\n--- PATINETES Y BICICLETAS ASIGNADOS ---");
        System.out.printf("%-10s %-12s %-20s %-15s\n", "ID", "Tipo", "Base", "Estado");
        mantenimiento.getVehiculosSinBateria().stream()
            .filter(v -> v instanceof GestorVehiculosBases.Vehiculos.Patinete || v instanceof GestorVehiculosBases.Vehiculos.Bicicleta)
            .forEach(v -> {
                VehiculoDeBase vb = (VehiculoDeBase) v;
                String baseNombre = vb.getBase() != null ? vb.getBase().toString() : "Sin base";
                System.out.printf("%-10d %-12s %-20s %-15s\n",
                    vb.getID(),
                    vb.getNombreVehiculo(),
                    baseNombre,
                    "Sin batería"
                );
            });
        mantenimiento.getVehiculosAveriados().stream()
            .filter(v -> v instanceof GestorVehiculosBases.Vehiculos.Patinete || v instanceof GestorVehiculosBases.Vehiculos.Bicicleta)
            .forEach(v -> {
                VehiculoDeBase vb = (VehiculoDeBase) v;
                String baseNombre = vb.getBase() != null ? vb.getBase().toString() : "Sin base";
                System.out.printf("%-10d %-12s %-20s %-15s\n",
                    vb.getID(),
                    vb.getNombreVehiculo(),
                    baseNombre,
                    "Averiado"
                );
            });

        // Tabla para Motos
        System.out.println("\n--- MOTOS ASIGNADAS ---");
        System.out.printf("%-10s %-15s %-15s %-15s %-15s\n", "ID", "Tipo", "Coord X", "Coord Y", "Estado");
        mantenimiento.getVehiculosSinBateria().stream()
            .filter(v -> v instanceof VehiculoDeCoordenadas)
            .forEach(v -> {
                VehiculoDeCoordenadas vm = (VehiculoDeCoordenadas) v;
                System.out.printf("%-10d %-15s %-15d %-15d %-15s\n",
                    vm.getID(),
                    vm.getNombreVehiculo(),
                    vm.getCoordenadaX(),
                    vm.getCoordenadaY(),
                    "Sin batería"
                );
            });
        mantenimiento.getVehiculosAveriados().stream()
            .filter(v -> v instanceof VehiculoDeCoordenadas)
            .forEach(v -> {
                VehiculoDeCoordenadas vm = (VehiculoDeCoordenadas) v;
                System.out.printf("%-10d %-15s %-15d %-15d %-15s\n",
                    vm.getID(),
                    vm.getNombreVehiculo(),
                    vm.getCoordenadaX(),
                    vm.getCoordenadaY(),
                    "Averiado"
                );
            });
    }

    public void realizarMantenimiento(Mantenimiento mantenimiento) {
        if (mantenimiento == null) {
            System.out.println("No hay usuario de mantenimiento activo.");
            return;
        }

        GestorVehiculos gestorVehiculos = GestorVehiculos.getInstancia();

        int recargados = 0;
        int retirados = mantenimiento.getVehiculosAveriados().size();

        // Reestablecer batería y solicitar traslado para cada vehículo sin batería
        for (var v : mantenimiento.getVehiculosSinBateria()) {
            v.setBateria(100);
            recargados++;
            mantenimiento.incrementarIntervenciones(); // Incrementa por recarga

            if (v instanceof VehiculoDeBase) {
                System.out.println("\nVehículo: " + v.getNombreVehiculo() + " (ID: " + v.getID() + ")");
                String nombreBase;
                boolean trasladoOK = false;
                do {
                    nombreBase = UtilidadesEntradaDatos.getStringLongitud("Introduce el nombre de la base destino", 1, 20);
                    if (gestorVehiculos.moverVehiculoABase(v.getID(), nombreBase)) {
                        trasladoOK = true;
                    } else {
                        System.out.println("No se pudo trasladar el vehículo a la base indicada. Intente de nuevo.");
                    }
                } while (!trasladoOK);
            } else if (v instanceof VehiculoDeCoordenadas) {
                System.out.println("\nVehículo: " + v.getNombreVehiculo() + " (ID: " + v.getID() + ")");
                boolean trasladoOK = false;
                do {
                    Mapa mapa = Mapa.getInstancia();
                    int x = UtilidadesEntradaDatos.getEnteroPositivo("Introduce la coordenada X destino", 0, mapa.getMaxCoordenadaX());
                    int y = UtilidadesEntradaDatos.getEnteroPositivo("Introduce la coordenada Y destino", 0, mapa.getMaxCoordenadaY());
                    if (gestorVehiculos.moverVehiculoACoordenadas(v.getID(), x, y)) {
                        trasladoOK = true;
                    } else {
                        System.out.println("No se pudo trasladar el vehículo a esas coordenadas. Intente de nuevo.");
                    }
                } while (!trasladoOK);
            }
        }

        // Retirar vehículos averiados usando GestorVehiculos
        mantenimiento.getVehiculosAveriados().forEach(v -> {
            if (v instanceof VehiculoDeBase) {
                gestorVehiculos.removeVehiculoBasePorID(v.getID());
            } else if (v instanceof VehiculoDeCoordenadas) {
                VehiculoDeCoordenadas vc = (VehiculoDeCoordenadas) v;
                gestorVehiculos.removeVehiculoMapaPorCoordenadas(vc.getCoordenadaX(), vc.getCoordenadaY());
            }
            mantenimiento.incrementarIntervenciones();; // Incrementa por retiro
        });

        // Limpiar listas
        mantenimiento.getVehiculosSinBateria().clear();
        mantenimiento.getVehiculosAveriados().clear();

        System.out.println("Mantenimiento realizado con éxito.");
        System.out.println("Vehículos recargados y trasladados: " + recargados);
        System.out.println("Vehículos retirados: " + retirados);
    }

    public void desactivarVehiculo() {
        System.out.println("Introduce el ID del vehículo a reservar:");
        int idVehiculo = UtilidadesEntradaDatos.getEnteroPositivo("ID vehículo", 1, Integer.MAX_VALUE);

        System.out.println("Introduce la duración del periodo de inactividad en minutos:");
        int minutos = UtilidadesEntradaDatos.getEnteroPositivo("Minutos", 1, 1440); // hasta 24h

        Beneficios beneficios = new Beneficios();
        if (beneficios.reservarVehiculo(idVehiculo, minutos)) {
            System.out.println("Vehículo reservado correctamente por " + minutos + " minutos.");
        } else {
            System.out.println("No se pudo reservar el vehículo.");
        }
    }
}
package Menus;

import GestorPersonas.Personas.Mecanico;
import GestorVehiculosBases.Facturas.FacturaReparacionBase;
import GestorVehiculosBases.Facturas.FacturaReparacionVehiculo;
import GestorVehiculosBases.GestorBases;
import GestorVehiculosBases.GestorVehiculos;
import GestorVehiculosBases.Localizaciones.Base;
import GestorVehiculosBases.Localizaciones.Mapa;
import GestorVehiculosBases.Vehiculos.Vehiculo;
import GestorVehiculosBases.Vehiculos.VehiculoDeBase;
import GestorVehiculosBases.Vehiculos.VehiculoDeCoordenadas;
import GestorViajes.Beneficios;
import Utilidades.UtilidadesEntradaDatos;
import java.time.LocalDate;
import java.util.List;

public class ServicioMecanico {

    private Mecanico mecanico;

    public void setMecanico(Mecanico mecanico) {
        this.mecanico = mecanico;
    }

    public void verVehiculosYBasesAsignados() {
        if (mecanico == null) {
            System.out.println("No hay usuario mecánico activo.");
            return;
        }

        GestorVehiculos gestorVehiculos = GestorVehiculos.getInstancia();
        List<Vehiculo> vehiculosEnAlmacen = gestorVehiculos.getListaVehiculosAlmacenados();

        // Vehículos averiados asignados al mecánico
        System.out.println("\n--- VEHÍCULOS AVERIADOS ASIGNADOS AL MECÁNICO ---");
        System.out.printf("%-10s %-15s %-20s %-10s\n", "ID", "Tipo", "Ubicación", "En almacén");
        for (Vehiculo v : mecanico.getVehiculosAveriados()) {
            String ubicacion;
            if (vehiculosEnAlmacen.contains(v)) {
                ubicacion = "Almacén";
            } else if (v instanceof VehiculoDeCoordenadas) {
                VehiculoDeCoordenadas vc = (VehiculoDeCoordenadas) v;
                ubicacion = "Mapa (" + vc.getCoordenadaX() + "," + vc.getCoordenadaY() + ")";
            } else if (v instanceof VehiculoDeBase) {
                VehiculoDeBase vb = (VehiculoDeBase) v;
                if (vb.getBase() != null) {
                    ubicacion = "Base: " + vb.getBase().getNombre();
                } else {
                    ubicacion = "Desconocida";
                }
            } else {
                ubicacion = "Desconocida";
            }

            String enAlmacen = vehiculosEnAlmacen.contains(v) ? "Sí" : "No";

            System.out.printf("%-10d %-15s %-20s %-10s\n",
                v.getID(),
                v.getNombreVehiculo(),
                ubicacion,
                enAlmacen
            );
        }

        // Bases averiadas asignadas al mecánico
        System.out.println("\n--- BASES AVERIADAS ASIGNADAS ---");
        System.out.printf("%-20s %-20s\n", "Nombre Base", "Ubicación");
        for (Base base : mecanico.getBasesAveriadas()) {
            String ubicacion = "X: " + base.getCoordenadaX() + ", Y: " + base.getCoordenadaY();
            System.out.printf("%-20s %-20s\n", base.getNombre(), ubicacion);
        }
    }

    public void realizarReparacionVehiculo() {
        if (mecanico == null) {
            System.out.println("No hay usuario mecánico activo.");
            return;
        }

        int IDVehiculo = UtilidadesEntradaDatos.getEnteroPositivo("Introduce el ID del vehículo a reparar", 1, Integer.MAX_VALUE);

        GestorVehiculos gestorVehiculos = GestorVehiculos.getInstancia();
        Vehiculo vehiculo = gestorVehiculos.getVehiculoPorID(IDVehiculo);

        if (vehiculo == null) {
            System.out.println("El vehículo no existe.");
            return;
        }
        if (!gestorVehiculos.getListaVehiculosAlmacenados().contains(vehiculo)) {
            System.out.println("El vehículo no está en el almacén.");
            return;
        }
        if (!mecanico.getVehiculosAveriados().contains(vehiculo)) {
            System.out.println("El vehículo no está asignado a este mecánico.");
            return;
        }

        vehiculo.setAverias(false);

        FacturaReparacionVehiculo reparacion = new FacturaReparacionVehiculo(vehiculo, LocalDate.now());
        double coste = reparacion.getCoste();

        mecanico.removeVehiculoAveriado(vehiculo);
        mecanico.incrementarIntervenciones();; // Incrementa por reparación de vehículo

        System.out.println("Vehículo reparado correctamente. Coste: " + coste + "€");
    }

    public void realizarReparacionBase() {
        if (mecanico == null) {
            System.out.println("No hay usuario mecánico activo.");
            return;
        }

        String nombreBase = UtilidadesEntradaDatos.getStringLongitud("Introduce el nombre de la base a reparar", 1, 50);
        Base base = Mapa.getInstancia().getBasePorNombre(nombreBase);

        if (base == null) {
            System.out.println("La base no existe.");
            return;
        }
        if (!base.getAverias()) {
            System.out.println("La base no está averiada.");
            return;
        }
        if (!mecanico.getBasesAveriadas().contains(base)) {
            System.out.println("La base no está asignada a este mecánico.");
            return;
        }

        base.setAverias(false);

        FacturaReparacionBase reparacion = new FacturaReparacionBase(base);
        double coste = reparacion.getCoste();

        mecanico.removeBaseAveriada(base);
        mecanico.incrementarIntervenciones(); // Incrementa por reparación de base

        System.out.println("Base reparada correctamente. Coste: " + coste + "€");
    }

    public void desactivarVehiculo() {
        System.out.println("Introduce el ID del vehículo a reservar:");
        int idVehiculo = UtilidadesEntradaDatos.getEnteroPositivo("ID vehículo", 1, Integer.MAX_VALUE);

        System.out.println("Introduce la duración del periodo de inactividad en minutos:");
        int minutos = UtilidadesEntradaDatos.getEnteroPositivo("Minutos", 1, 1440); // hasta 24h

        Beneficios beneficios = new Beneficios();
        if (beneficios.reservarVehiculo(idVehiculo, minutos)) {
            System.out.println("Vehículo reservado correctamente por " + minutos + " minutos.");
        } else {
            System.out.println("No se pudo reservar el vehículo.");
        }
    }

    public void desactivarBase() {
        System.out.println("Introduce el nombre de la base a desactivar:");
        String nombreBase = UtilidadesEntradaDatos.getStringLongitud("Nombre de la base", 1, 50);

        System.out.println("Introduce la duración del periodo de inactividad en minutos:");
        int minutos = UtilidadesEntradaDatos.getEnteroPositivo("Minutos", 1, 1440); // hasta 24h

        GestorBases gestorBases = GestorBases.getInstancia();
        boolean resultado = gestorBases.desactivarBase(nombreBase, minutos);

        if (resultado) {
            System.out.println("Base '" + nombreBase + "' desactivada correctamente por " + minutos + " minutos.");
        } else {
            System.out.println("No se pudo desactivar la base (puede que no exista o ya esté desactivada).");
        }
    }

    public void mostrarHistorialReparaciones() {
        if (mecanico == null) {
            System.out.println("No hay usuario mecánico activo.");
            return;
        }

        // Tabla de reparaciones de vehículos
        List<FacturaReparacionVehiculo> reparacionesVehiculos = mecanico.getReparacionesVehiculosRealizadas();
        System.out.println("\n--- HISTORIAL DE REPARACIONES DE VEHÍCULOS ---");
        if (reparacionesVehiculos.isEmpty()) {
            System.out.println("No hay reparaciones de vehículos registradas.");
        } else {
            System.out.printf("%-10s %-15s %-10s\n", "ID", "Tipo", "Coste (€)");
            for (FacturaReparacionVehiculo rv : reparacionesVehiculos) {
                Vehiculo v = rv.getVehiculo();
                System.out.printf("%-10d %-15s %-10.2f\n", v.getID(), v.getNombreVehiculo(), rv.getCoste());
            }
        }

        // Tabla de reparaciones de bases
        List<FacturaReparacionBase> reparacionesBases = mecanico.getReparacionesBasesRealizadas();
        System.out.println("\n--- HISTORIAL DE REPARACIONES DE BASES ---");
        if (reparacionesBases.isEmpty()) {
            System.out.println("No hay reparaciones de bases registradas.");
        } else {
            System.out.printf("%-20s %-10s\n", "Nombre Base", "Coste (€)");
            for (FacturaReparacionBase rb : reparacionesBases) {
                Base b = rb.getBase();
                System.out.printf("%-20s %-10.2f\n", b.getNombre(), rb.getCoste());
            }
        }
    }
}
package Menus;

import Enum.VehiculoEnum;
import GestorPersonas.Personas.Usuario;
import GestorVehiculosBases.GestorVehiculos;
import GestorVehiculosBases.Localizaciones.Base;
import GestorVehiculosBases.Localizaciones.Mapa;
import GestorVehiculosBases.Vehiculos.Vehiculo;
import GestorViajes.Beneficios;
import GestorViajes.ServicioViajes;
import GestorViajes.Viaje;
import java.util.HashMap;
import java.util.Map;

public class ServicioUsuario {

    private final Map<Usuario, Viaje> viajesActivos = new HashMap<>();
    private final GestorVehiculos gestorVehiculos = GestorVehiculos.getInstancia();
    private final Mapa mapa = Mapa.getInstancia();

    public void iniciarViajeBase(Usuario usuario, VehiculoEnum tipoVehiculo, String nombreBase) {
        ServicioViajes servicioViajes = ServicioViajes.getInstancia();
        Viaje nuevoViaje = servicioViajes.iniciarViaje(usuario, tipoVehiculo, nombreBase);
        if (nuevoViaje != null) {
            viajesActivos.put(usuario, nuevoViaje);
        }
    }

    public void iniciarViajeCoordenadas(Usuario usuario, VehiculoEnum tipoVehiculo, int coordX, int coordY) {
        ServicioViajes servicioViajes = ServicioViajes.getInstancia();
        Viaje nuevoViaje = servicioViajes.iniciarViajeMoto(usuario, tipoVehiculo, coordX, coordY);
        if (nuevoViaje != null) {
            viajesActivos.put(usuario, nuevoViaje);
        }
    }

    public boolean finalizarViajeBase(Usuario usuario, String nombreBase) {
        Viaje viajeActivo = viajesActivos.get(usuario);
        if (viajeActivo == null) return false;
        boolean terminado = ServicioViajes.getInstancia().finalizarViajeBase(usuario, viajeActivo, nombreBase);
        if (terminado) viajesActivos.remove(usuario);
        return terminado;
    }

    public boolean finalizarViajeCoordenadas(Usuario usuario, int coordX, int coordY) {
        Viaje viajeActivo = viajesActivos.get(usuario);
        if (viajeActivo == null) return false;
        boolean terminado = ServicioViajes.getInstancia().finalizarViajeCoordenadas(usuario, viajeActivo, coordX, coordY);
        if (terminado) viajesActivos.remove(usuario);
        return terminado;
    }

    public Viaje getViajeActivo(Usuario usuario) {
        return viajesActivos.get(usuario);
    }

    public void mostrarConsultaVehiculosDisponibles(Usuario usuario) {
        System.out.println("\n--- Consulta de vehículos disponibles ---");
        System.out.printf("%-12s %-10s %-15s %-15s %-10s\n", "Tipo", "ID", "Base/Coord", "Ocupación", "Batería");

        // Mostrar bicicletas y patinetes en bases
        for (Base base : mapa.getListaBases()) {
            int ocupacion = 0;
            for (Vehiculo v : base.getListaVehiculos()) {
                if (v.getReservado()) continue;
                double bateria = v.getBateria();
                boolean mostrar = false;
                if (bateria > 20) {
                    mostrar = true;
                } else if (bateria > 10 && bateria <= 20 && usuario instanceof GestorPersonas.Personas.Premium) {
                    mostrar = true;
                }
                if (bateria > 10 && mostrar) {
                    ocupacion++;
                    System.out.printf("%-12s %-10d %-15s %-15d %-10.1f%%\n",
                        v.getVehiculoEnum(), v.getID(), base.getNombre(), ocupacion, bateria);
                }
            }
        }

        // Mostrar motos por coordenadas
        for (Vehiculo v : gestorVehiculos.getVehiculosEnMapa()) {
            if (v.getReservado()) continue;
            double bateria = v.getBateria();
            boolean mostrar = false;
            if (bateria > 20) {
                mostrar = true;
            } else if (bateria > 10 && bateria <= 20 && usuario instanceof GestorPersonas.Personas.Premium) {
                mostrar = true;
            }
            if (bateria > 10 && mostrar) {
                int x = ((GestorVehiculosBases.Vehiculos.VehiculoDeCoordenadas) v).getCoordenadaX();
                int y = ((GestorVehiculosBases.Vehiculos.VehiculoDeCoordenadas) v).getCoordenadaY();
                System.out.printf("%-12s %-10d (%d,%d) %-15s %-10.1f%%\n",
                    v.getVehiculoEnum(), v.getID(), x, y, "-", bateria);
            }
        }
    }

    public void mostrarHistorialViajes(Usuario usuario) {
        System.out.println("\n--- Historial de viajes realizados ---");
        var historial = usuario.getHistorialViajes();
        if (historial.isEmpty()) {
            System.out.println("No tienes viajes realizados.");
            return;
        }
        System.out.printf("%-12s %-10s %-25s %-25s %-10s\n", "Tipo", "ID", "Inicio", "Fin", "Importe (€)");
        for (Viaje viaje : historial) {
            String inicio = new java.util.Date(viaje.getTiempoInicio()).toString();
            String fin = viaje.getTiempoFin() > 0 ? new java.util.Date(viaje.getTiempoFin()).toString() : "En curso";
            double importe = viaje.getCosto();
            System.out.printf("%-12s %-10d %-25s %-25s %-10.2f\n",
                viaje.getVehiculo().getVehiculoEnum(),
                viaje.getVehiculo().getID(),
                inicio,
                fin,
                importe
            );
        }
    }

    public void mostrarSaldo(Usuario usuario) {
        System.out.printf("\nSaldo disponible: %.2f €\n", usuario.getSaldo());
    }

    public void recargarSaldo(Usuario usuario, double cantidad) {
        usuario.agregarSaldo(cantidad);
        System.out.printf("Recarga exitosa. Nuevo saldo: %.2f €\n", usuario.getSaldo());
    }

    public boolean reservarVehiculo(Usuario usuario, int idVehiculo) {
        Beneficios beneficios = new Beneficios();
        if (!beneficios.getReservasPermitidas()) {
            System.out.println("Las reservas están deshabilitadas actualmente.");
            return false;
        }

        Vehiculo vehiculo = gestorVehiculos.getVehiculoPorID(idVehiculo);
        if (vehiculo == null) {
            System.out.println("No existe un vehículo con ese ID.");
            return false;
        }
        if (vehiculo.getReservado()) {
            System.out.println("Este vehículo ya está reservado.");
            return false;
        }
        if (vehiculo.getEnUso()) {
            System.out.println("Este vehículo está actualmente en uso.");
            return false;
        }
        if (vehiculo.getAverias()) {
            System.out.println("Este vehículo está averiado y no se puede reservar.");
            return false;
        }
        if (vehiculo.getBateria() <= vehiculo.getBateriaMinima(usuario)) {
            System.out.println("Este vehículo no cumple el nivel mínimo de batería para tu tipo de usuario.");
            return false;
        }

        boolean exito = beneficios.reservarVehiculo(idVehiculo);
        if (exito) {
            vehiculo.setReservado(true);
            System.out.println("Vehículo reservado correctamente. Tienes 20 minutos para iniciar el viaje.");
            return true;
        } else {
            System.out.println("No se pudo reservar el vehículo. Puede que ya esté reservado por otro usuario.");
            return false;
        }
    }

    public Vehiculo getVehiculoMasCercano(Usuario usuario, VehiculoEnum tipoVehiculo, int coordX, int coordY) {
        return gestorVehiculos.getVehiculoMasCercano(coordX, coordY, tipoVehiculo, usuario);
    }

    public Mapa getMapa() {
        return mapa;
    }

    public GestorVehiculos getGestorVehiculos() {
        return gestorVehiculos;
    }
}
package Utilidades;

import java.util.Scanner;

public class UtilidadesEntradaDatos {
    private static final Scanner scanner = new Scanner(System.in);

    // Solicita un número entero positivo dentro de un rango al usuario
    public static int getEnteroPositivo(String mensaje, int min, int max) {
        int valor;
        do {
            // Muestra el mensaje y el rango permitido
            System.out.print(mensaje + " (" + min + "-" + max + "): ");
            try {
                // Intenta leer el valor como entero
                valor = Integer.parseInt(scanner.nextLine());
                // Verifica que esté dentro del rango
                if (valor < min || valor > max) {
                    System.out.println("El valor debe estar entre " + min + " y " + max + ".");
                    valor = -1;
                }
            } catch (NumberFormatException e) {
                // Si no es un número válido, muestra mensaje de error
                System.out.println("Por favor, introduzca un número entero válido.");
                valor = -1;
            }
        } while (valor == -1); // Repite hasta que el valor sea válido

        return valor;
    }

    // Solicita un número decimal positivo dentro de un rango al usuario
    public static double getDecimalPositivo(String mensaje, double min, double max) {
        double valor;
        do {
            // Muestra el mensaje y el rango permitido
            System.out.print(mensaje + " (" + min + "-" + max + "): ");
            try {
                // Intenta leer el valor como decimal
                valor = Double.parseDouble(scanner.nextLine());
                // Verifica que esté dentro del rango
                if (valor < min || valor > max) {
                    System.out.println("El valor debe estar entre " + min + " y " + max + ".");
                    valor = -1;
                }
            } catch (NumberFormatException e) {
                // Si no es un número válido, muestra mensaje de error
                System.out.println("Por favor, introduzca un número decimal válido.");
                valor = -1;
            }
        } while (valor == -1); // Repite hasta que el valor sea válido

        return valor;
    }

    // Solicita un String con longitud mínima y máxima al usuario
    public static String getStringLongitud(String mensaje, int min, int max) {
        String valor;
        do {
            System.out.print(mensaje + " (entre " + min + " y " + max + " caracteres): ");
            valor = scanner.nextLine();
            if (valor.length() < min || valor.length() > max) {
                System.out.println("La entrada debe tener entre " + min + " y " + max + " caracteres.");
            }
        } while (valor.length() < min || valor.length() > max);
        return valor;
    }

    //Socilitar DNI con formato 8 dígitos y letra
    public static String getDNI(String mensaje) {
        String dni;
        do {
            System.out.print(mensaje + " (8 dígitos + letra): ");
            dni = scanner.nextLine();
            if (!dni.matches("\\d{8}[A-Z]")) {
                System.out.println("El DNI debe tener 8 dígitos seguidos de una letra mayúscula.");
            }
        } while (!dni.matches("\\d{8}[A-Z]"));
        return dni;
    }
}

package Utilidades;

import Enum.RolEnum;
import Enum.VehiculoEnum;
public class UtilidadesMenus {

    // Método para seleccionar el tipo de vehículo
    public static void mostrarMenuTipoVehiculo() {
        System.out.println("Selecciona el tipo de vehículo:");
        System.out.println("1. " + VehiculoEnum.MOTOPEQUENA);
        System.out.println("2. " + VehiculoEnum.MOTOGRANDE);
        System.out.println("3. " + VehiculoEnum.BICICLETA);
        System.out.println("4. " + VehiculoEnum.PATINETE);
    }
    

    // Método para seleccionar el rol
    public static void mostrarMenuRol() {
        System.out.println("Selecciona el rol del nuevo registro:");
        System.out.println("1. " + RolEnum.USUARIO_STANDARD);
        System.out.println("2. " + RolEnum.MECANICO);
        System.out.println("3. " + RolEnum.MANTENIMIENTO);
        System.out.println("4. " + RolEnum.ADMINISTRADOR);
    }

    public static VehiculoEnum seleccionarTipoVehiculo() {
        while (true) {
            System.out.println("Selecciona el tipo de vehículo:");
            System.out.println("1. " + VehiculoEnum.MOTOPEQUENA);
            System.out.println("2. " + VehiculoEnum.MOTOGRANDE);
            System.out.println("3. " + VehiculoEnum.BICICLETA);
            System.out.println("4. " + VehiculoEnum.PATINETE);
            System.out.print("Introduce una opción (1-4): ");
            int opcion = UtilidadesEntradaDatos.getEnteroPositivo("Introduce una opción (1-4): ", 1, 4);
            return switch (opcion) {
                case 1 -> VehiculoEnum.MOTOPEQUENA;
                case 2 -> VehiculoEnum.MOTOGRANDE;
                case 3 -> VehiculoEnum.BICICLETA;
                case 4 -> VehiculoEnum.PATINETE;
                default -> {
                    System.out.println("Opción no válida. Por favor, selecciona una opción del 1 al 4.");
                    yield null;
                }
            };
        }
    }

    public static RolEnum seleccionarRol() {
        while (true) {
            System.out.println("Introduce el rol del nuevo registro:");
            System.out.println("1. " + RolEnum.USUARIO_STANDARD); // toString() implícito
            System.out.println("2. " + RolEnum.MECANICO);
            System.out.println("3. " + RolEnum.MANTENIMIENTO);
            System.out.println("4. " + RolEnum.ADMINISTRADOR);
            System.out.print("Selecciona una opción (1-4): ");
            int opcion = UtilidadesEntradaDatos.getEnteroPositivo("Introduce una opción (1-4): ", 1, 4);
            return switch (opcion) {
                case 1 -> RolEnum.USUARIO_STANDARD;
                case 2 -> RolEnum.MECANICO;
                case 3 -> RolEnum.MANTENIMIENTO;
                case 4 -> RolEnum.ADMINISTRADOR;
                default -> {
                    System.out.println("Opción no válida. Por favor, selecciona una opción del 1 al 4.");
                    yield null;
                }
            };
        }
    }
}


import Enum.RolEnum;
import Enum.VehiculoEnum;
import GestorPersonas.GestorPersonas;
import GestorPersonas.Personas.Usuario;
import GestorVehiculosBases.GestorBases;
import GestorVehiculosBases.GestorVehiculos;
import GestorVehiculosBases.Localizaciones.Base;
import GestorVehiculosBases.Localizaciones.Mapa;
import GestorVehiculosBases.Vehiculos.Vehiculo;
import GestorViajes.GestorViajes;
import GestorViajes.Viaje;
import Utilidades.UtilidadesEntradaDatos;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Random;

public class InicializadorSistema {

    // ==========================
    // ATRIBUTOS PRINCIPALES
    // ==========================
    private final GestorPersonas gestorPersonas;
    private final GestorViajes gestorViajes;
    private final GestorVehiculos gestorVehiculos;
    private final GestorBases gestorBases;
    private final Mapa mapa;

    // ==========================
    // CONSTRUCTOR
    // ==========================
    public InicializadorSistema() {
        this.gestorVehiculos = GestorVehiculos.getInstancia();
        this.gestorPersonas = GestorPersonas.getInstancia();
        this.gestorViajes = GestorViajes.getInstancia();
        this.gestorBases = GestorBases.getInstancia();
        this.mapa = Mapa.getInstancia();
    }

    // =============================================================
    // ================== INICIALIZADORES PRINCIPALES ==============
    // =============================================================

    // === Inicialización Vacía ===
    public void inicializarVacio() {
        System.out.println("\n--- Inicialización vacía: configuración del mapa ---");
        String nombreMapa = UtilidadesEntradaDatos.getStringLongitud("Nombre de la ciudad", 5, 20);
        int maxX = UtilidadesEntradaDatos.getEnteroPositivo("Dimensión máxima del mapa en X", 25, 100);
        int maxY = UtilidadesEntradaDatos.getEnteroPositivo("Dimensión máxima del mapa en Y", 25, 100);

        inicializarMapa(nombreMapa, maxX, maxY);

        System.out.println("Inicialización vacía: solo superuser registrado. El sistema está listo para configurarse.");
    }

    // === Inicialización con Semilla ===
    public void inicializarConSemilla(int semilla) {
        System.out.println("\n==== INICIALIZACIÓN CON SEMILLA: " + semilla + " ====");

        Random random = new Random(semilla);

        String nombreMapa = "Ciudad Semilla " + semilla;
        int maxX = 25 + random.nextInt(75);
        int maxY = 25 + random.nextInt(75);

        int numMecanicos = 1 + random.nextInt(4);
        int numMantenimiento = 1 + random.nextInt(4);
        int numAdministradores = 1 + random.nextInt(4);
        int numUsuariosStandard = 50 + random.nextInt(50);
        double saldoInicial = 5000 + (random.nextInt(10) * 500);
        int numBases = 5 + random.nextInt(10);
        int capacidad = 25 + random.nextInt(25);
        int minViajesPorUsuario = 25 + random.nextInt(75);
        int maxViajesPorUsuario = 100 + random.nextInt(150);
        Map<VehiculoEnum, Integer> cantidades = new HashMap<>();
        cantidades.put(VehiculoEnum.BICICLETA, 25 + random.nextInt(25));
        cantidades.put(VehiculoEnum.PATINETE, 25 + random.nextInt(25));
        cantidades.put(VehiculoEnum.MOTOGRANDE, 25 + random.nextInt(25));
        cantidades.put(VehiculoEnum.MOTOPEQUENA, 25 + random.nextInt(25));

        maxViajesPorUsuario = Math.max(maxViajesPorUsuario, minViajesPorUsuario + 5);

        System.out.println("Valores generados con semilla " + semilla + ":");
        System.out.println("- Mapa: " + nombreMapa + " (" + maxX + "x" + maxY + ")");
        System.out.println("- Mecánicos: " + numMecanicos);
        System.out.println("- Personal de mantenimiento: " + numMantenimiento);
        System.out.println("- Administradores adicionales: " + numAdministradores);
        System.out.println("- Usuarios estándar: " + numUsuariosStandard);
        System.out.println("- Saldo inicial: " + saldoInicial + "€");
        System.out.println("- Bases: " + numBases);
        System.out.println("- Vehículos por tipo: " + cantidades);
        System.out.println("- Viajes por usuario: " + minViajesPorUsuario + "-" + maxViajesPorUsuario);

        inicializarMapa(nombreMapa, maxX, maxY);
        inicializarPersonas(numMecanicos, numMantenimiento, numAdministradores, numUsuariosStandard, saldoInicial);
        inicializarBases(numBases, capacidad);
        inicializarVehiculos(cantidades);
        inicializarViajes(minViajesPorUsuario, maxViajesPorUsuario, semilla);

        System.out.println("Sistema inicializado correctamente con semilla: " + semilla);
    }

    // === Inicialización Manual ===
    public void inicializarManualmente() {
        System.out.println("\n==== CONFIGURACIÓN MANUAL ====");

        System.out.println("\n--- Configuración del Mapa ---");
        String nombreMapa = UtilidadesEntradaDatos.getStringLongitud("Nombre de la ciudad", 5, 20);
        int maxX = UtilidadesEntradaDatos.getEnteroPositivo("Dimensión máxima del mapa en X", 25, 100);
        int maxY = UtilidadesEntradaDatos.getEnteroPositivo("Dimensión máxima del mapa en Y", 25, 100);

        inicializarMapa(nombreMapa, maxX, maxY);

        System.out.println("\n--- Configuración de Personal ---");
        int numMecanicos = UtilidadesEntradaDatos.getEnteroPositivo("Número de mecánicos", 1, 25);
        int numMantenimiento = UtilidadesEntradaDatos.getEnteroPositivo("Número de personal de mantenimiento", 1, 25);
        int numAdministradores = UtilidadesEntradaDatos.getEnteroPositivo("Número de administradores adicionales", 0, 5);
        int numUsuariosStandard = UtilidadesEntradaDatos.getEnteroPositivo("Número de usuarios estándar", 1, 250);
        double saldoInicial = UtilidadesEntradaDatos.getDecimalPositivo("Saldo inicial para usuarios", 0.0, 10000.0);

        System.out.println("\n--- Configuración de Infraestructura ---");
        int numBases = UtilidadesEntradaDatos.getEnteroPositivo("Número de bases", 1, 20);
        int capacidad = UtilidadesEntradaDatos.getEnteroPositivo("Capacidad de cada base", 25, 100);
        Map<VehiculoEnum, Integer> cantidades = new HashMap<>();
        cantidades.put(VehiculoEnum.BICICLETA, UtilidadesEntradaDatos.getEnteroPositivo("Cantidad de bicicletas", 0, 100));
        cantidades.put(VehiculoEnum.PATINETE, UtilidadesEntradaDatos.getEnteroPositivo("Cantidad de patinetes", 0, 100));
        cantidades.put(VehiculoEnum.MOTOGRANDE, UtilidadesEntradaDatos.getEnteroPositivo("Cantidad de motos grandes", 0, 100));
        cantidades.put(VehiculoEnum.MOTOPEQUENA, UtilidadesEntradaDatos.getEnteroPositivo("Cantidad de motos pequeñas", 0, 100));

        System.out.println("\n--- Configuración de Viajes ---");
        int minViajesPorUsuario = UtilidadesEntradaDatos.getEnteroPositivo("Mínimo de viajes por usuario", 0, 50);
        int maxViajesPorUsuario = UtilidadesEntradaDatos.getEnteroPositivo("Máximo de viajes por usuario", minViajesPorUsuario, 100);
        int semilla = UtilidadesEntradaDatos.getEnteroPositivo("Semilla para generación de viajes y bases", 10000, 99999);

        inicializarPersonas(numMecanicos, numMantenimiento, numAdministradores, numUsuariosStandard, saldoInicial);
        inicializarBases(numBases, capacidad);
        inicializarVehiculos(cantidades);
        inicializarViajes(minViajesPorUsuario, maxViajesPorUsuario, semilla);

        System.out.println("Sistema inicializado correctamente con configuración manual.");
    }

    // =============================================================
    // =============== MÉTODOS AUXILIARES DE INICIO ================
    // =============================================================

    // --- Inicializar Mapa ---
    private void inicializarMapa(String nombreMapa, int maxX, int maxY) {
        System.out.println("Inicializando mapa del sistema...");
        if (mapa.inicializarMapa(nombreMapa, maxX, maxY)) {
            System.out.println("Mapa inicializado: " + nombreMapa + " (Dimensiones: " + maxX + "x" + maxY + ")");
            System.out.printf("Nombre: %s | Dimensiones: %d x %d | Bases: %d\n",
                    mapa.getNombre(), mapa.getMaxCoordenadaX(), mapa.getMaxCoordenadaY(), mapa.getListaBases().size());
        } else {
            System.out.println("Error al inicializar el mapa. No se pudo crear el mapa con los valores proporcionados.");
        }
    }

    // --- Inicializar Personas ---
    private void inicializarPersonas(int numMecanicos, int numMantenimiento, int numAdministradores, int numUsuariosStandard, double saldoInicial) {
        System.out.println("Inicializando personas en el sistema...");
        inicializarPersonalTecnico(numMecanicos, numMantenimiento);
        inicializarAdministradores(numAdministradores);
        inicializarUsuariosStandard(numUsuariosStandard, saldoInicial);
        System.out.println("Personas inicializadas correctamente.");
    }

    // --- Inicializar Personal Técnico ---
    private void inicializarPersonalTecnico(int numMecanicos, int numMantenimiento) {
        System.out.println("Inicializando personal técnico...");
        for (int i = 1; i <= numMecanicos; i++) {
            String dni = String.format("%08d", i) + "M";
            String nombre = "Mecanico" + i;
            String apellido = "Apellido" + i;
            gestorPersonas.addPersona(nombre, apellido, dni, RolEnum.MECANICO);
            System.out.println("- Mecánico creado: " + nombre + " " + apellido + " (DNI: " + dni + ")");
        }
        for (int i = 1; i <= numMantenimiento; i++) {
            String dni = String.format("%08d", i) + "T";
            String nombre = "Mantenimiento" + i;
            String apellido = "Apellido" + i;
            gestorPersonas.addPersona(nombre, apellido, dni, RolEnum.MANTENIMIENTO);
            System.out.println("- Personal de mantenimiento creado: " + nombre + " " + apellido + " (DNI: " + dni + ")");
        }
        System.out.println("Total: " + numMecanicos + " mecánicos y " + numMantenimiento + " personal de mantenimiento creados.");
    }

    // --- Inicializar Administradores ---
    private void inicializarAdministradores(int numAdministradores) {
        System.out.println("Inicializando administradores adicionales...");
        for (int i = 1; i <= numAdministradores; i++) {
            String dni = String.format("%08d", i) + "A";
            String nombre = "Administrador" + i;
            String apellido = "Apellido" + i;
            gestorPersonas.addPersona(nombre, apellido, dni, RolEnum.ADMINISTRADOR);
            System.out.println("- Administrador creado: " + nombre + " " + apellido + " (DNI: " + dni + ")");
        }
        System.out.println("Total: " + numAdministradores + " administradores adicionales creados.");
    }

    // --- Inicializar Usuarios Standard ---
    private void inicializarUsuariosStandard(int numUsuariosStandard, double saldoInicial) {
        System.out.println("Inicializando usuarios estándar...");
        for (int i = 1; i <= numUsuariosStandard; i++) {
            String dni = String.format("%08d", i) + "S";
            String nombre = "Standard" + i;
            String apellido = "Apellido" + i;
            gestorPersonas.addPersona(nombre, apellido, dni, RolEnum.USUARIO_STANDARD);
            Usuario usuario = (Usuario) gestorPersonas.getPersonaPorDNI(dni);
            if (usuario != null) {
                usuario.agregarSaldo(saldoInicial);
            }
            System.out.println("- Usuario estándar creado: " + nombre + " " + apellido + " (DNI: " + dni + ", Saldo: " + saldoInicial + "€)");
        }
        System.out.println("Total: " + numUsuariosStandard + " usuarios estándar creados con saldo inicial de " + saldoInicial + "€.");
    }

    // --- Inicializar Bases ---
    private void inicializarBases(int numeroBases, int capacidad) {
        System.out.println("Inicializando bases en el sistema...");
        int i;
        int maxX = mapa.getMaxCoordenadaX();
        int maxY = mapa.getMaxCoordenadaY();
        Random random = new Random();
        for (i = 1; i <= numeroBases; i++) {
            int x, y;
            boolean libre;
            do {
                x = random.nextInt(maxX);
                y = random.nextInt(maxY);
                libre = true;
                for (Base b : mapa.getListaBases()) {
                    if (b.getCoordenadaX() == x && b.getCoordenadaY() == y) {
                        libre = false;
                        break;
                    }
                }
            } while (!libre);
            gestorBases.addBasePorCoordenadas("Base" + i, x, y, capacidad);
            System.out.println("Base" + i + " creada en la posición (" + x + ", " + y + ").");
        }
        System.out.println((i - 1) + " bases inicializadas correctamente.");
    }

    // --- Inicializar Vehículos ---
    private void inicializarVehiculos(Map<VehiculoEnum, Integer> cantidadPorTipo) {
        System.out.println("Inicializando vehículos en el sistema...");
        int totalVehiculos = 0;
        int maxX = mapa.getMaxCoordenadaX();
        int maxY = mapa.getMaxCoordenadaY();
        Random random = new Random();
        for (Map.Entry<VehiculoEnum, Integer> entry : cantidadPorTipo.entrySet()) {
            VehiculoEnum tipo = entry.getKey();
            int cantidad = entry.getValue();
            for (int i = 0; i < cantidad; i++) {
                if (tipo == VehiculoEnum.BICICLETA || tipo == VehiculoEnum.PATINETE) {
                    Base base = getBaseMenosVehiculosDisponibles();
                    if (base != null && gestorVehiculos.addVehiculoBase(tipo, base) != null) {
                        totalVehiculos++;
                    }
                } else if (tipo == VehiculoEnum.MOTOGRANDE || tipo == VehiculoEnum.MOTOPEQUENA) {
                    int x, y;
                    boolean libre;
                    do {
                        x = random.nextInt(maxX);
                        y = random.nextInt(maxY);
                        libre = true;
                        for (Vehiculo v : gestorVehiculos.getListaVehiculos()) {
                            if ((v.getVehiculoEnum() == VehiculoEnum.MOTOGRANDE || v.getVehiculoEnum() == VehiculoEnum.MOTOPEQUENA)
                                    && v instanceof GestorVehiculosBases.Vehiculos.VehiculoDeCoordenadas) {
                                GestorVehiculosBases.Vehiculos.VehiculoDeCoordenadas vCoord = (GestorVehiculosBases.Vehiculos.VehiculoDeCoordenadas) v;
                                if (vCoord.getCoordenadaX() == x && vCoord.getCoordenadaY() == y) {
                                    libre = false;
                                    break;
                                }
                            }
                        }
                    } while (!libre);
                    if (gestorVehiculos.addVehiculoMapa(tipo, x, y) != null) {
                        totalVehiculos++;
                    }
                }
            }
        }
        System.out.println("Total: " + totalVehiculos + " vehículos añadidos y distribuidos automáticamente.");
    }

    // --- Obtener Base con Menos Vehículos Disponibles ---
    private Base getBaseMenosVehiculosDisponibles() {
        Base baseMenosVehiculos = null;
        int minVehiculosActivos = 0;
        boolean primeraBase = true;

        for (Base base : mapa.getListaBasesSinAverias()) {
            if (base.getEspaciosLibres() > 0) {

                List<Vehiculo> vehiculosActivos = new ArrayList<>();
                for (Vehiculo vehiculo : base.getListaVehiculos()) {
                    if (!vehiculo.getAverias() && vehiculo.getBateria() > 20 && !vehiculo.getReservado()) {
                        vehiculosActivos.add(vehiculo);
                    }
                }

                if (primeraBase || vehiculosActivos.size() < minVehiculosActivos) {
                    minVehiculosActivos = vehiculosActivos.size();
                    baseMenosVehiculos = base;
                    primeraBase = false;
                }
            }
        }
        return baseMenosVehiculos;
    }

    // --- Inicializar Viajes ---
    private void inicializarViajes(int minViajesPorUsuario, int maxViajesPorUsuario, int seed) {
        System.out.println("Generando viajes de ejemplo para usuarios...");
        Random random = new Random(seed);
        List<Usuario> usuarios = gestorPersonas.obtenerTodosLosUsuarios();
        VehiculoEnum[] tiposVehiculo = {
            VehiculoEnum.BICICLETA,
            VehiculoEnum.PATINETE,
            VehiculoEnum.MOTOGRANDE,
            VehiculoEnum.MOTOPEQUENA
        };
        int totalViajes = 0;
        int usuariosConViajes = 0;
        LocalDateTime ahora = LocalDateTime.now();

        List<Base> bases = mapa.getListaBases();
        int maxX = mapa.getMaxCoordenadaX();
        int maxY = mapa.getMaxCoordenadaY();

        for (Usuario usuario : usuarios) {
            int numViajes = random.nextInt(maxViajesPorUsuario - minViajesPorUsuario + 1) + minViajesPorUsuario;
            boolean usuarioTieneViajes = false;
            LocalDateTime fechaViaje = ahora.minusDays(random.nextInt(30));

            for (int i = 0; i < numViajes; i++) {
                VehiculoEnum tipoVehiculo = tiposVehiculo[random.nextInt(tiposVehiculo.length)];

                List<Vehiculo> listaVehiculos = gestorVehiculos.getListaVehiculos();
                Vehiculo vehiculo = null;
                List<Vehiculo> listaVehiculosPosibles = new ArrayList<>();
                for (Vehiculo v : listaVehiculos) {
                    if (v.getVehiculoEnum() == tipoVehiculo && v.getDisponible(usuario)) {
                        listaVehiculosPosibles.add(v);
                    }
                }
                if (!listaVehiculosPosibles.isEmpty()) {
                    vehiculo = listaVehiculosPosibles.get(random.nextInt(listaVehiculosPosibles.size()));
                }

                if (vehiculo == null) {
                    continue;
                }

                int minutos = 1 + random.nextInt(120);
                LocalDateTime fechaFin = fechaViaje.plusMinutes(minutos);

                if (tipoVehiculo == VehiculoEnum.BICICLETA || tipoVehiculo == VehiculoEnum.PATINETE) {
                    Base baseOrigen = bases.get(random.nextInt(bases.size()));
                    Base baseDestino = bases.get(random.nextInt(bases.size()));
                    while (baseDestino == baseOrigen && bases.size() > 1) {
                        baseDestino = bases.get(random.nextInt(bases.size()));
                    }
                    Viaje viaje = new Viaje(vehiculo, usuario, fechaViaje, fechaFin, baseOrigen, baseDestino);
                    gestorViajes.registrarViaje(viaje);

                    double duracionHoras = (double)(fechaFin.atZone(java.time.ZoneId.systemDefault()).toInstant().toEpochMilli() -
                            fechaViaje.atZone(java.time.ZoneId.systemDefault()).toInstant().toEpochMilli()) / 3600000.0;
                    double tarifaBase = tipoVehiculo.getTarifa();
                    double costoBase = duracionHoras * tarifaBase;
                    double costoFinal = costoBase;
                    if (usuario.getRol() == RolEnum.USUARIO_PREMIUM) {
                        double descuento = tipoVehiculo.getDescuento();
                        costoFinal = costoBase * (1 - descuento / 100.0);
                    }
                    usuario.descontarCosto(costoFinal);
                    viaje.setCosto(costoFinal);

                    vehiculo.setEnUso(false);
                    GestorVehiculosBases.Vehiculos.VehiculoDeBase vBase = (GestorVehiculosBases.Vehiculos.VehiculoDeBase) vehiculo;
                    if (vBase.getBase() == null || !vBase.getBase().getNombre().equals(baseDestino.getNombre())) {
                        gestorVehiculos.moverVehiculoABase(vehiculo.getID(), baseDestino.getNombre());
                        baseDestino.incrementarViajesFinalizadosBase();
                    }
                } else {
                    int origenX = random.nextInt(maxX);
                    int origenY = random.nextInt(maxY);
                    int destinoX = random.nextInt(maxX);
                    int destinoY = random.nextInt(maxY);
                    while (origenX == destinoX && origenY == destinoY) {
                        destinoX = random.nextInt(maxX);
                        destinoY = random.nextInt(maxY);
                    }
                    Viaje viaje = new Viaje(vehiculo, usuario, fechaViaje, fechaFin, origenX, origenY, destinoX, destinoY);
                    gestorViajes.registrarViaje(viaje);

                    double duracionHoras = (double)(fechaFin.atZone(java.time.ZoneId.systemDefault()).toInstant().toEpochMilli() -
                            fechaViaje.atZone(java.time.ZoneId.systemDefault()).toInstant().toEpochMilli()) / 3600000.0;
                    double tarifaBase = tipoVehiculo.getTarifa();
                    double costoBase = duracionHoras * tarifaBase;
                    double costoFinal = costoBase;
                    if (usuario.getRol() == RolEnum.USUARIO_PREMIUM) {
                        double descuento = tipoVehiculo.getDescuento();
                        costoFinal = costoBase * (1 - descuento / 100.0);
                    }
                    usuario.descontarCosto(costoFinal);
                    viaje.setCosto(costoFinal);

                    vehiculo.setEnUso(false);
                    GestorVehiculosBases.Vehiculos.VehiculoDeCoordenadas vCoord = (GestorVehiculosBases.Vehiculos.VehiculoDeCoordenadas) vehiculo;
                    if (vCoord.getCoordenadaX() != destinoX || vCoord.getCoordenadaY() != destinoY) {
                        gestorVehiculos.moverVehiculoACoordenadas(vehiculo.getID(), destinoX, destinoY);
                    }
                }

                totalViajes++;
                usuarioTieneViajes = true;

                fechaViaje = fechaViaje.minusHours(random.nextInt(24)).minusMinutes(random.nextInt(60));
            }
            if (usuarioTieneViajes) {
                usuariosConViajes++;
            }
        }
        System.out.println("Viajes generados: " + totalViajes + " | Usuarios con viajes: " + usuariosConViajes);
    }
}
import Enum.RolEnum;
import Enum.VehiculoEnum;
import GestorPersonas.GestorPersonas;
import GestorPersonas.Personas.Administrador;
import GestorPersonas.Personas.Persona;
import GestorPersonas.Personas.Usuario;
import GestorVehiculosBases.GestorVehiculos;
import GestorVehiculosBases.Localizaciones.Mapa;
import GestorViajes.Beneficios;
import GestorViajes.GestorViajes;
import GestorViajes.Penalizaciones;
import GestorViajes.Viaje;
import Menus.Menu;
import Utilidades.UtilidadesEntradaDatos;
import java.util.List;

public final class Movilidad {

    // ===========================
    // ATRIBUTOS PRINCIPALES
    // ===========================
    private final GestorPersonas gestorPersonas;
    private final GestorViajes gestorViajes;
    private final GestorVehiculos gestorVehiculos;
    private final Mapa mapa;
    private final InicializadorSistema inicializadorSistema;

    // ===========================
    // CONSTRUCTOR Y FLUJO PRINCIPAL
    // ===========================
    public Movilidad() {
        System.out.println("Constructor de Movilidad ejecutado.");

        // Instancia los componentes principales del sistema
        mapa = Mapa.getInstancia();
        gestorPersonas = GestorPersonas.getInstancia();
        gestorViajes = GestorViajes.getInstancia();
        gestorVehiculos = GestorVehiculos.getInstancia();
        inicializadorSistema = new InicializadorSistema();

        // Crea el superusuario administrador
        crearSuperUser();

        // Muestra el menú de inicialización y ejecuta la opción elegida
        menuInicializacion();

        // Dibuja el mapa inicial en consola
        mapa.dibujarMapa();

        // Muestra un resumen del estado inicial del sistema
        mostrarResumenInicializacion();

        // Inicia el menú principal de la aplicación
        iniciarMenu();

        System.out.println("Aplicación finalizada.");
    }

    // ===========================
    // INICIALIZACIÓN DEL SISTEMA
    // ===========================

    // Crea el usuario administrador principal (superuser)
    private void crearSuperUser() {
        // Crea un administrador por defecto
        Administrador superuser = new Administrador("Super", "User", "00000000A");
        // Añade el superuser al gestor de personas
        gestorPersonas.addAdministradorInicial(superuser);
        System.out.println("Administrador inicial (superuser) creado correctamente.");
    }

    // Muestra el menú de inicialización y ejecuta la opción seleccionada
    private void menuInicializacion() {
        System.out.println("\n==== MENÚ DE INICIALIZACIÓN ====");
        System.out.println("1. Inicializar sistema vacío (solo superuser)");
        System.out.println("2. Inicializar sistema con semilla predeterminada");
        System.out.println("3. Inicializar sistema con semilla personalizada");
        System.out.println("4. Configuración manual");

        // Solicita al usuario una opción válida
        int opcion = UtilidadesEntradaDatos.getEnteroPositivo("Seleccione una opción", 1, 4);

        switch (opcion) {
            case 1:
                // Inicializa el sistema vacío
                inicializadorSistema.inicializarVacio();
                break;
            case 2:
                // Inicializa el sistema con una semilla predeterminada
                inicializadorSistema.inicializarConSemilla(12345);
                break;
            case 3:
                // Solicita una semilla personalizada y la usa para inicializar
                int semilla = solicitarSemilla();
                inicializadorSistema.inicializarConSemilla(semilla);
                break;
            case 4:
                // Permite la configuración manual del sistema
                inicializadorSistema.inicializarManualmente();
                break;
        }
    }

    // Solicita una semilla de inicialización de 5 dígitos al usuario
    private int solicitarSemilla() {
        int semilla;
        do {
            System.out.print("Introduzca una semilla de inicialización (5 dígitos): ");
            try {
                // Solicita un número entre 10000 y 99999
                semilla = UtilidadesEntradaDatos.getEnteroPositivo("Semilla", 10000, 99999);
                if (semilla < 10000 || semilla > 99999) {
                    // Si la semilla no tiene 5 dígitos, muestra un mensaje de error
                    System.out.println("La semilla debe tener exactamente 5 dígitos.");
                    semilla = -1;
                }
            } catch (NumberFormatException e) {
                // Si la entrada no es válida, muestra un mensaje de error
                System.out.println("Por favor, introduzca un número válido.");
                semilla = -1;
            }
        } while (semilla == -1); // Repite hasta que la semilla sea válida
        return semilla;
    }

    // ===========================
    // MENÚ PRINCIPAL
    // ===========================

    // Inicia el menú principal de la aplicación
    private void iniciarMenu() {
        // Crea una instancia del menú principal
        Menu menu = new Menu();
        // Inicia la interacción con el usuario
        menu.iniciar();
    }

    // ===========================
    // RESUMEN DE INICIALIZACIÓN
    // ===========================

    // Muestra un resumen del estado inicial del sistema
    private void mostrarResumenInicializacion() {
        System.out.println("\n==== RESUMEN DE INICIALIZACIÓN DEL SISTEMA ====");

        // Información del mapa
        System.out.println("\n--- INFORMACIÓN DEL MAPA ---");
        System.out.printf("Nombre: %s | Dimensiones: %d x %d | Bases: %d\n",
                mapa.getNombre(), mapa.getMaxCoordenadaX(), mapa.getMaxCoordenadaY(), mapa.getListaBases().size());

        // Resumen de usuarios
        System.out.println("\n--- RESUMEN DE USUARIOS ---");
        List<Usuario> usuarios = gestorPersonas.obtenerTodosLosUsuarios();
        int usuariosStandard = 0, usuariosPremium = 0;
        // Cuenta usuarios estándar y premium
        for (Usuario usuario : usuarios) {
            if (usuario.getRol() == RolEnum.USUARIO_STANDARD) usuariosStandard++;
            else if (usuario.getRol() == RolEnum.USUARIO_PREMIUM) usuariosPremium++;
        }
        System.out.printf("Total: %d | Estándar: %d | Premium: %d\n",
                usuarios.size(), usuariosStandard, usuariosPremium);

        // Resumen de personal
        System.out.println("\n--- RESUMEN DE PERSONAL ---");
        int totalMecanicos = 0, totalMantenimiento = 0, totalAdmins = 0;
        // Cuenta el personal por rol
        for (Object persona : gestorPersonas.getPersonas()) {
            RolEnum rol = ((Persona) persona).getRol();
            if (rol == RolEnum.MECANICO) totalMecanicos++;
            else if (rol == RolEnum.MANTENIMIENTO) totalMantenimiento++;
            else if (rol == RolEnum.ADMINISTRADOR) totalAdmins++;
        }
        int totalPersonal = totalMecanicos + totalMantenimiento + totalAdmins;
        System.out.printf("Total: %d | Administradores: %d | Mecánicos: %d | Mantenimiento: %d\n",
                totalPersonal, totalAdmins, totalMecanicos, totalMantenimiento);

        // Resumen de vehículos
        System.out.println("\n--- RESUMEN DE VEHÍCULOS ---");
        int enAlmacen = gestorVehiculos.getListaVehiculosAlmacenados().size();
        int enMapa = gestorVehiculos.getVehiculosEnMapa().size();
        int enBases = gestorVehiculos.getVehiculosEnBases().size();
        int totalVehiculos = enAlmacen + enMapa + enBases;
        // Muestra el total y el desglose de vehículos
        System.out.printf("Total: %d | En almacén: %d | En mapa: %d | En bases: %d\n",
                totalVehiculos, enAlmacen, enMapa, enBases);

        // Desglose por tipo de vehículo
        int bicicletas = 0, patinetes = 0, motosGrandes = 0, motosPequenas = 0;
        // Contar en almacén
        for (var v : gestorVehiculos.getListaVehiculosAlmacenados()) {
            switch (v.getVehiculoEnum()) {
                case BICICLETA: bicicletas++; break;
                case PATINETE: patinetes++; break;
                case MOTOGRANDE: motosGrandes++; break;
                case MOTOPEQUENA: motosPequenas++; break;
            }
        }
        // Contar en mapa
        for (var v : gestorVehiculos.getVehiculosEnMapa()) {
            switch (v.getVehiculoEnum()) {
                case BICICLETA: bicicletas++; break;
                case PATINETE: patinetes++; break;
                case MOTOGRANDE: motosGrandes++; break;
                case MOTOPEQUENA: motosPequenas++; break;
            }
        }
        // Contar en bases
        for (var v : gestorVehiculos.getVehiculosEnBases()) {
            switch (v.getVehiculoEnum()) {
                case BICICLETA: bicicletas++; break;
                case PATINETE: patinetes++; break;
                case MOTOGRANDE: motosGrandes++; break;
                case MOTOPEQUENA: motosPequenas++; break;
            }
        }
        System.out.printf("Bicicletas: %d | Patinetes: %d | Motos grandes: %d | Motos pequeñas: %d\n",
                bicicletas, patinetes, motosGrandes, motosPequenas);

        // Resumen de viajes
        System.out.println("\n--- RESUMEN DE VIAJES ---");
        List<Viaje> todosLosViajes = gestorViajes.getListaTodosViajes();
        int viajesBicicleta = 0, viajesPatinete = 0;
        int viajesMotoGrande = 0, viajesMotoPequena = 0;
        // Cuenta los viajes por tipo de vehículo
        for (Viaje viaje : todosLosViajes) {
            VehiculoEnum tipoVehiculo = viaje.getVehiculo().getVehiculoEnum();
            switch (tipoVehiculo) {
                case BICICLETA: viajesBicicleta++; break;
                case PATINETE: viajesPatinete++; break;
                case MOTOGRANDE: viajesMotoGrande++; break;
                case MOTOPEQUENA: viajesMotoPequena++; break;
            }
        }
        System.out.printf("Total viajes: %d | Bicicletas: %d | Patinetes: %d | Motos grandes: %d | Motos pequeñas: %d\n",
                todosLosViajes.size(), viajesBicicleta, viajesPatinete, viajesMotoGrande, viajesMotoPequena);

        // Información de tarifas y descuentos
        System.out.println("\n--- INFORMACIÓN DE TARIFAS Y DESCUENTOS ---");
        gestorViajes.mostrarTarifasActuales();
        gestorViajes.mostrarDescuentosActuales();

        // Estado del sistema (reservas y privilegios)
        Beneficios beneficios = new Beneficios();
        System.out.println("\n--- ESTADO DEL SISTEMA ---");
        // Muestra si las reservas están habilitadas
        if (beneficios.getReservasPermitidas()) {
            System.out.println("Reservas: HABILITADAS\n");
        } else {
            System.out.println("Reservas: DESHABILITADAS\n");
        }
        // Muestra si el usuario premium puede usar vehículos con poca batería
        if (beneficios.getBateriaPremiumPermitida()) {
            System.out.println("Usuario Premium puede utilizar vehiculo con bateria entre 10%-20%: HABILITADO\n");
        } else {
            System.out.println("Usuario Premium puede utilizar vehiculo con bateria entre 10%-20%: DESHABILITADA\n");
        }

        // Penalización por agotar la batería antes de entregar el vehículo
        System.out.println("Penalización por agotar la batería antes de entregar el vehículo: " +
                Penalizaciones.obtenerPenalizacionPorBateriaAgotada() + "€\n");

        System.out.println("\n==== SISTEMA INICIADO Y LISTO PARA USAR ====");
    }
}





